{"1611.04684v1": {"paper_id": "1611.04684v1", "all_figures": {"1611.04684v1-Table3-1.png": {"caption": "Table 3: Evaluation results on answer selection", "content_type": "table", "figure_type": "N/A"}, "1611.04684v1-Table2-1.png": {"caption": "Table 2: Statistics of the answer selection data set", "content_type": "table", "figure_type": "N/A"}, "1611.04684v1-Table1-1.png": {"caption": "A difficult example from QA", "content_type": "table", "figure_type": "other"}, "1611.04684v1-Table4-1.png": {"caption": "Table 4: Evaluation results on response selection", "content_type": "table", "figure_type": "N/A"}, "1611.04684v1-Table5-1.png": {"caption": "Accuracy on different length of text", "content_type": "table", "figure_type": "table"}, "1611.04684v1-Table6-1.png": {"caption": "Comparison of different channels", "content_type": "table", "figure_type": "table"}, "1611.04684v1-Figure1-1.png": {"caption": "Architecture of KEHNN", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "What are the main differences between the educational philosophies of the Bonaparte and Voltaire schools?", "answer": "The Bonaparte school focuses on outdoor physical activities, maneuvers, and strategies, with a specialization in horse riding, lances, and swords. They aim to develop students into good leaders. The Voltaire school, on the other hand, encourages independent thinking and focuses on indoor activities. They aim to instill good moral values and develop students into philosophical thinkers.", "explanation": "The figure presents a question and answer format, where the answer explicitly describes the contrasting educational approaches of the two schools.", "reference": "1611.04684v1-Table1-1.png"}, {"question": "Which model performs the best for response selection, and how can we tell?", "answer": "The KEHNN model performs the best for response selection. This is evident because it achieves the highest scores across all metrics (R$2$@1, R${10}$@1, R${10}$@2, and R${10}$@5) compared to all other models in the table.", "explanation": "Table 1 presents the performance of different models on the task of response selection. Each column represents a specific evaluation metric, and each row represents a different model. By comparing the values in each column, we can identify the model with the best performance for each metric. In this case, KEHNN consistently outperforms all other models, indicating its superior performance in response selection.", "reference": "1611.04684v1-Table4-1.png"}, {"question": "Which model performs best on the Ubuntu dataset for text lengths between 60 and 90 words?", "answer": "KEHNN", "explanation": "The table shows the accuracy of three models (LSTM, MV-LSTM, and KEHNN) on two datasets (QA and Ubuntu) for different text lengths. For text lengths between 60 and 90 words on the Ubuntu dataset, KEHNN has the highest accuracy of 0.785.", "reference": "1611.04684v1-Table5-1.png"}, {"question": "What is the role of the knowledge gates in the KEHNN architecture?", "answer": "The knowledge gates are responsible for selecting relevant information from the knowledge base and incorporating it into the model's hidden state.", "explanation": "The figure shows that the knowledge gates take as input the knowledge base (K) and the current hidden state (h_t) of the BiGRU. The output of the knowledge gates is then used to update the hidden state of the BiGRU. This suggests that the knowledge gates are used to selectively incorporate information from the knowledge base into the model's hidden state.", "reference": "1611.04684v1-Figure1-1.png"}, {"question": "How does the average number of answers per question differ between the training and development sets? What might be a possible explanation for this difference?", "answer": "The training set has a higher average number of answers per question (6.36) compared to the development set (5.48). This suggests that questions in the training set tend to have more potential answers associated with them than those in the development set.", "explanation": "The table provides the number of questions and answers in each data set. By dividing the number of answers by the number of questions, we can calculate the average number of answers per question. The difference observed could be due to various factors, such as:\n\n* **Sampling bias:** The training and development sets might have been drawn from different parts of the forum, leading to different distributions of questions and answers. \n* **Question complexity:** Perhaps the training set contains more complex or open-ended questions that naturally elicit a wider range of responses compared to the questions in the development set. \n\nUnderstanding such differences between data sets is crucial for interpreting model performance and identifying potential biases in the data.", "reference": "1611.04684v1-Table2-1.png"}]}, "1611.05742v3": {"paper_id": "1611.05742v3", "all_figures": {"1611.05742v3-Figure1-1.png": {"caption": "Conceptual illustration of the proposed Grassmann Network (GrNet) architecture. The rectangles in blue represent three basic blocks, i.e., Projection, Pooling and Output blocks, respectively.", "content_type": "figure", "figure_type": "schematic"}, "1611.05742v3-Figure2-1.png": {"caption": "(a) Results of using single and multiple FRMap (S-FRMap, M-FRMap), ProjPoolings across or within projections (A-ProjPooling, W-ProjPooling) for the three used databases. (b) (c) Convergence and accuracy curves of SPDNet and the proposed GrNet for the AFEW.", "content_type": "figure", "figure_type": "plot"}, "1611.05742v3-Table1-1.png": {"caption": "Table 1: Results for the AFEW, HDM05 and PaSC datasets. PaSC1/PaSC2 are the control/handheld testings.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "What is the function of the ReOrth Layer in the Projection Block of the Grassmann Network architecture?", "answer": "The ReOrth Layer re-orthogonalizes the output of the FRMap Layer.", "explanation": "The figure shows that the ReOrth Layer takes the output of the FRMap Layer as its input and outputs a re-orthogonalized version of that input.", "reference": "1611.05742v3-Figure1-1.png"}, {"question": "Which pooling method is the most accurate for the AFEW database?", "answer": "W-ProjPooling", "explanation": "The accuracy of each pooling method for each database is shown in the bar graph in part (a) of the figure. The bar for W-ProjPooling for the AFEW database is the highest, indicating that it is the most accurate pooling method for that database.", "reference": "1611.05742v3-Figure2-1.png"}, {"question": "Which method performs best on the PaSC dataset for the handheld testing scenario (PaSC2), and how does its performance compare to other methods?", "answer": "The method that performs best on the PaSC dataset for the handheld testing scenario (PaSC2) is SPDNet, with an accuracy of 72.83%. This performance is slightly higher than GrNet-2Blocks (72.76%) and significantly higher than other methods like VGGDeepFace (68.24%) and DeepO2P (60.14%).", "explanation": "By looking at the column corresponding to PaSC2 in Table 1, we can directly compare the accuracy of all the methods for this specific testing scenario. We can see that SPDNet has the highest accuracy value, indicating its superior performance compared to the other methods.", "reference": "1611.05742v3-Table1-1.png"}]}, "1611.07718v2": {"paper_id": "1611.07718v2", "all_figures": {"1611.07718v2-Figure1-1.png": {"caption": "Illustrating the building blocks: (a) Two residual blocks; (b) An inception-like block; (c) A merge-and-run block. (a) corresponds to two blocks in ResNets and assembles two residual branches sequentially while (b) and (c) both assemble the same two residual branches in parallel. (b) and (c) adopt two different skip connections: identity mappings and our proposed merge-andrun mappings. The dot circle denotes the average operation, and the solid circle denotes the sum operation.", "content_type": "figure", "figure_type": "schematic"}, "1611.07718v2-Table2-1.png": {"caption": "Empirical comparison of DILNets, DMRNets, and ResNets. The average classification error from 5 runs and the standard deviation (mean \u00b1 std.) are reported. Refer to Table 1 for network structure descriptions.", "content_type": "table", "figure_type": "table"}, "1611.07718v2-Figure2-1.png": {"caption": "(a) a deep residual network; (b) a network built by stacking inception-like blocks; (c) our deep merge-and-run neural network built by stacking merge-and-run blocks. The trapezoid shape indicates that down-sampling occurs in the corresponding layer, and the dashed line denotes a projection shortcut as in [7].", "content_type": "figure", "figure_type": "Schematic"}, "1611.07718v2-Table3-1.png": {"caption": "Classification error comparison with state-of-the-arts. The results of DenseNets are based on the networks without bottlenecks. The DMRNet-Wide is the wide version of a DMRNet, 4\u00d7 wider, i.e., the widths of the threes stages are 64, 128, and 256, respectively.", "content_type": "table", "figure_type": "table"}, "1611.07718v2-Figure7-1.png": {"caption": "Comparing the optimization of ResNets and the DMRNets with the same number of layers/parameters. The vertical axis corresponds to training losses and testing errors, and the horizontal axis corresponds to #epochs.", "content_type": "figure", "figure_type": "plot"}, "1611.07718v2-Figure3-1.png": {"caption": "Comparing the distributions of the path lengths for three networks. Different networks: (avg length \u00b1 std). Left: L = 9. Right: L = 24.", "content_type": "figure", "figure_type": "plot"}, "1611.07718v2-Table4-1.png": {"caption": "The validation (single 224\u00d7224 center crop) and training errors (%) of ResNet-101 (44.5M) and our DMRNet (43.3M) on ImageNet.", "content_type": "table", "figure_type": "table"}, "1611.07718v2-Table5-1.png": {"caption": "Comparison between merge-and-run mappings and identity mappings. Sharing = share the first conv. and the last FC.", "content_type": "table", "figure_type": "table"}, "1611.07718v2-Figure8-1.png": {"caption": "Training error and validation error curves of ResNet-101 (44.5M) and DFN-MR (43.3M) with the same optimization setting on ImageNet. We report the (top-1 error) results for training and single-crop validation. It can be observed that our approach performs better for both training errors and validation errors.", "content_type": "figure", "figure_type": "plot"}, "1611.07718v2-Figure4-1.png": {"caption": "Illustrating the two residual branches shown in (a) are transformed to a single residual branch shown in (b). (a) All 4 convolutions are (16, 3 \u00d7 3, 16). (b) The 2 convolutions are (16, 3\u00d73, 32) and (32, 3\u00d73, 16), from narrow (16) to wide (32), and then from wide (32) back to narrow (16).", "content_type": "figure", "figure_type": "schematic"}, "1611.07718v2-Figure5-1.png": {"caption": "Transform the merge-and-run block shown in (a) to a two-branch block shown in (b). (b) The 2 convolutions are group convolutions. A group convolution contains two (G = 2) convolutions of (16, 3\u00d7 3, 16): each receives a different 16-channel input and the two outputs are concatenated as the final output with 32 channels. The width is greater than 16. The skip connection (dot line) is a linear transformation, where the transformation matrix of size 32\u00d7 32 is idempotent.", "content_type": "figure", "figure_type": "schematic"}, "1611.07718v2-Figure6-1.png": {"caption": "Illustrating how the testing errors of residual networks change as the average path length increases. The results are reported on CIFAR-10.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which network architecture has the highest accuracy on the CIFAR-10 dataset?", "answer": "DMRNet-Wide", "explanation": "The table shows the classification error rates for different network architectures on the CIFAR-10 dataset. The network with the lowest error rate is DMRNet-Wide (ours), which has an error rate of 19.00%.", "reference": "1611.07718v2-Table3-1.png"}, {"question": "What is the difference between a deep residual network and a network built by stacking inception-like blocks?", "answer": "Deep residual networks have skip connections that allow the gradient to flow directly from one layer to another, while networks built by stacking inception-like blocks do not.", "explanation": "The figure shows that deep residual networks have dashed lines connecting layers, which represent skip connections. Networks built by stacking inception-like blocks do not have these dashed lines.", "reference": "1611.07718v2-Figure2-1.png"}, {"question": "What is the difference between the residual block and the merge-and-run block?", "answer": "The residual block assembles two residual branches sequentially, while the merge-and-run block assembles the same two residual branches in parallel.", "explanation": "The figure shows the different building blocks of a convolutional neural network. The residual block (a) has two residual branches that are connected sequentially, while the merge-and-run block (c) has two residual branches that are connected in parallel.", "reference": "1611.07718v2-Figure1-1.png"}, {"question": "How does the training loss of DMRNet compare to that of ResNet on the CIFAR-10 dataset with L = 30?", "answer": "The training loss of DMRNet is lower than that of ResNet on the CIFAR-10 dataset with L = 30.", "explanation": "The plot in Figure (a) shows that the training loss of DMRNet (dashed red line) is consistently lower than that of ResNet (dashed blue line) throughout the training process.", "reference": "1611.07718v2-Figure7-1.png"}, {"question": "Which network has the shortest average path length when L = 9?", "answer": "DMRNet", "explanation": "The figure shows the distribution of path lengths for three networks. The average path length for each network is shown in the legend. When L = 9, DMRNet has the shortest average path length (8.0 \u00b1 2.83).", "reference": "1611.07718v2-Figure3-1.png"}, {"question": "Which model has the lowest Top-1 validation error on ImageNet?", "answer": "ResNet-101 from the reference paper reports top-1 validation error of 23.60 which is lower than ResNet-101 reevaluated (26.41) and DMRNet (23.66)", "explanation": "The table shows that DMRNet has a Top-1 validation error of 23.66%, which is lower than the 26.41% error of ResNet-101.", "reference": "1611.07718v2-Table4-1.png"}, {"question": "Does sharing the first convolutional layer and the last fully connected layer improve the accuracy of the merge-and-run mapping?", "answer": "Yes.", "explanation": "The table shows that the accuracy of the merge-and-run mapping is higher when the first convolutional layer and the last fully connected layer are shared. For example, on CIFAR-10, the accuracy of the merge-and-run mapping is 4.99% with sharing and 4.41% without sharing.", "reference": "1611.07718v2-Table5-1.png"}, {"question": "How does the classification error of a residual network change as the average path length increases?", "answer": "The classification error of a residual network generally increases as the average path length increases.", "explanation": "The figure shows two lines, one for a residual network with 3 residual blocks and one for a residual network with 6 residual blocks. Both lines show an overall increase in classification error as the average path length increases. This suggests that as the network becomes deeper, it becomes more difficult for it to learn the underlying patterns in the data.", "reference": "1611.07718v2-Figure6-1.png"}]}, "1611.03780v2": {"paper_id": "1611.03780v2", "all_figures": {"1611.03780v2-Figure4-1.png": {"caption": "Figure 4: The GeoCUTS algorithm applied to user queries from the United States. The algorithm automatically identifies metropolitan areas, correctly predicting, for example, that the Bay Area includes San Francisco, Berkeley, and Palo Alto, but not Sacramento.", "content_type": "figure", "figure_type": "Map"}, "1611.03780v2-Figure5-1.png": {"caption": "Figure 5: The GeoCUTS algorithm applied to user queries from France. It correctly identifies metropolitan areas such as Paris, Bordeaux, and Lyon, and regions such as Alsace and Normandy.", "content_type": "figure", "figure_type": "Map."}, "1611.03780v2-Figure3-1.png": {"caption": "Figure 3: The graph built by the GeoCUTS algorithm, with nodes shown on corresponding locations of the US. White represents large edge weights (high traffic areas), while black represents low edge weights. Larger edge weights often do not match larger vertex weights, showing the difference between GeoCUTS and an algorithm simply measuring population density. Gaps in the colored regions represent locations for which no search data is available. For example, in regions such as deserts, Search queries come disproportionately from narrow strips corresponding to major roads.", "content_type": "figure", "figure_type": "** schematic"}, "1611.03780v2-Table3-1.png": {"caption": "Table 3: Cut size comparison against different clustering algorithms for highly active (HA) and highly mobile (HM) users within the US. \u201cGrid\u201d denotes the grid partition, \u201cLE\u201d denotes the Linear Embedding algorithm [4], and \u201cHilbert\u201d denotes partitions along a Hilbert curve [21]. We see that GeoCUTS and Linear Embedding give the best cut size.", "content_type": "table", "figure_type": "N/A"}, "1611.03780v2-Table1-1.png": {"caption": "(a) Average and query-weighted average (Query-w. avg) of Q-metric, (b) Percentage of queries from clusters with a Q-metric of at least x%. \u223c 200 clusters were used for the US and \u223c 50 for France. For both highly active and highly mobile graphs, GeoCUTS performs comparably to DMAs and outperforms the baseline grid clustering.", "content_type": "table", "figure_type": "Table"}, "1611.03780v2-Table2-1.png": {"caption": "B-metrics across clusterings, reported with a multiplicative constant of 100. We see that GeoCUTS performs comparably to other clusterings for highly active users, and somewhat better for highly mobile users.", "content_type": "table", "figure_type": "table"}, "1611.03780v2-Figure1-1.png": {"caption": "Hilbert space-filling curves are constructed recursively up to any desired resolution.", "content_type": "figure", "figure_type": "Schematic"}, "1611.03780v2-Table4-1.png": {"caption": "Table 4: Percentage of queries from clusters with a Q-metric \u2265 x% for different numbers of clusters in France.", "content_type": "table", "figure_type": "N/A"}, "1611.03780v2-Table5-1.png": {"caption": "Table 5: Comparison of weighted average Q-metrics and B-metrics for GeoCUTS applied to US query data across (a) varying normalizations, (b) varying coarsenesses of location discretization. The B-metrics are reported with a multiplicative factor of 100.", "content_type": "table", "figure_type": "N/A"}, "1611.03780v2-Figure2-1.png": {"caption": "Diagram of the bipartite user-region graph and the resulting \u201cfolded\u201d interference graph between regions. The edge weights of the folded graph correspond to the unnormalized weights qkk (cf. Equation 1).", "content_type": "figure", "figure_type": "** Schematic"}}, "qa": [{"question": "How does GeoCUTS perform compared to other clusterings for highly active users?", "answer": "GeoCUTS performs comparably to other clusterings for highly active users.", "explanation": "The table shows that the B-metrics for GeoCUTS are similar to the B-metrics for DMA and Grid for highly active users in the US and France.", "reference": "1611.03780v2-Table2-1.png"}, {"question": "How is the Hilbert space-filling curve constructed?", "answer": "The Hilbert space-filling curve is constructed recursively. The curve starts with a simple square, and then at each subsequent iteration, the curve is subdivided into four smaller squares. The curve is then drawn through each of these squares in a specific order.", "explanation": "The figure shows the first four iterations of the Hilbert space-filling curve. Each iteration is shown in a different color. The curve starts with a simple square (shown in red), and then at each subsequent iteration, the curve is subdivided into four smaller squares. The curve is then drawn through each of these squares in a specific order.", "reference": "1611.03780v2-Figure1-1.png"}, {"question": "How does the performance of GeoCUTS compare to the Grid method in identifying highly mobile clusters when the number of clusters is increased from approximately 25 to 50?", "answer": "GeoCUTS consistently outperforms the Grid method in identifying highly mobile clusters, regardless of the number of clusters. However, the performance of both methods decreases as the number of clusters increases.", "explanation": "Table 1 shows the percentage of queries from highly mobile clusters identified by each method for different Q-metric thresholds and cluster numbers. In both the \"$\\sim25$ clusters\" and \"$\\sim50$ clusters\" scenarios, GeoCUTS identifies a higher percentage of highly mobile clusters than the Grid method across all Q-metric thresholds. For example, with approximately 25 clusters and a Q-metric threshold of 0.8, GeoCUTS identifies 56% of highly mobile clusters, while the Grid method only identifies 30%. This trend holds true even when the number of clusters increases to approximately 50. \n\nThe passage also emphasizes that GeoCUTS significantly outperforms the Grid method regardless of the number of clusters, supporting the conclusion drawn from the table.", "reference": "1611.03780v2-Table4-1.png"}, {"question": "What is the relationship between the query graph and the interference graph?", "answer": " The interference graph is a folded version of the query graph. The nodes in the interference graph represent regions, and the edges represent the interference between regions. The edge weights in the interference graph are calculated from the edge weights in the query graph.", "explanation": " The figure shows how the query graph is folded to create the interference graph. The nodes in the query graph represent users and regions, and the edges represent the relationships between them. The folding process involves combining the user nodes into a single node for each region. The edge weights in the interference graph are then calculated by summing the weights of the edges between the corresponding user nodes in the query graph.", "reference": "1611.03780v2-Figure2-1.png"}, {"question": "Which metropolitan area is predicted by the GeoCUTS algorithm to include San Francisco, Berkeley, and Palo Alto, but not Sacramento?", "answer": "The Bay Area.", "explanation": "The figure shows the clusters generated by the GeoCUTS algorithm for data from the United States. The Bay Area is shown as a single cluster that includes San Francisco, Berkeley, and Palo Alto, but not Sacramento.", "reference": "1611.03780v2-Figure4-1.png"}, {"question": "Which metropolitan areas are correctly identified by the GeoCUTS algorithm in France?", "answer": "Paris, Bordeaux, and Lyon.", "explanation": "The figure shows the clusters generated by the GeoCUTS algorithm for data from France. The clusters corresponding to Paris, Bordeaux, and Lyon are clearly visible.", "reference": "1611.03780v2-Figure5-1.png"}, {"question": "Which clustering algorithm produced the smallest cut size for highly active users in the US dataset, and how much smaller was it compared to the cut size produced by grid partitioning?", "answer": "Both GeoCUTS and Linear Embedding produced the smallest cut size for highly active users, with a cut size of 4%. This is 11% smaller than the cut size produced by grid partitioning, which had a cut size of 15%.", "explanation": "The table shows the cut size percentages for different clustering algorithms applied to highly active (HA) and highly mobile (HM) users. The \"HA\" row shows that GeoCUTS and LE have the lowest percentage (4%), while Grid has a significantly higher percentage (15%). The difference between these percentages (15% - 4% = 11%) indicates how much smaller the cut size is for GeoCUTS and LE compared to Grid partitioning.", "reference": "1611.03780v2-Table3-1.png"}, {"question": "Which method performs best for highly active users in the US?", "answer": "Both GeoCUTS and DMA perform equally well for highly active users in the US.", "explanation": "In Figure (b), for highly active users in the US, both GeoCUTS and DMA have 100% of queries from clusters with a Q-metric of at least 0.75 and 0.8.", "reference": "1611.03780v2-Table1-1.png"}]}, "1611.04363v2": {"paper_id": "1611.04363v2", "all_figures": {"1611.04363v2-Table1-1.png": {"caption": "Table 1: Performance comparison of different methods.", "content_type": "table", "figure_type": "N/A"}, "1611.04363v2-Figure2-1.png": {"caption": "Graphical representation of the WeakFG model. Variable yi indicates whether expert ei declines the invitation; vi indicates the embedding for expert ei; f(q, ei, vi, yi) and g(ei, ej , yi, yj) represent the local factor function defined for expert ei on query q, and the correlation factor function defined between experts ei and ej .", "content_type": "figure", "figure_type": "schematic"}, "1611.04363v2-Figure1-1.png": {"caption": "Figure 1: Decline probability of an expert conditioned on whether or not the expert has a correlated \u201cfriend\u201d who has already declined on two datasets: QA-Expert and Paper-Reviewer, and our online evaluation of journal reviewer recommendation.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which method performed best according to the P@1 metric for the QA-Expert task, and how much better did it perform compared to the average P@1 score of the D2V method? ", "answer": "The WeakFG method achieved the highest P@1 score for the QA-Expert task with a score of 52.8. This is 23.2% higher than the average P@1 score of the D2V method, which was 29.6. ", "explanation": "The table provides the P@1 scores for all methods under the \"QA-Expert\" column. By comparing these values, we can identify WeakFG as the best performing method for this metric. We can then calculate the difference between WeakFG's score and D2V's average score to determine the performance gap.", "reference": "1611.04363v2-Table1-1.png"}, {"question": "What is the relationship between the decline probability of an expert and whether or not they have a \"friend\" who has already declined?", "answer": "The decline probability of an expert is higher if they have a \"friend\" who has already declined.", "explanation": "The figure shows that the decline probability for experts with a \"friend\" who has declined is consistently higher than the decline probability for experts without such a friend, across all three datasets. This suggests that there is a correlation between the decline decisions of experts and their friends.", "reference": "1611.04363v2-Figure1-1.png"}]}, "1608.02784v2": {"paper_id": "1608.02784v2", "all_figures": {"1608.02784v2-Figure4-1.png": {"caption": "Figure 4: Scatter plot of SMT (statistical machine translation) and CCA BLEU scores versus human ratings.", "content_type": "figure", "figure_type": "plot"}, "1608.02784v2-Figure5-1.png": {"caption": "Figure 5: An image with the following descriptions in the dataset: (1) mike is kicking the soccer ball; (2) mike is sitting on the cat; (3) jenny is standing next to the dog; (4) jenny is kicking the soccer ball; (5) the sun is behind jenny; (6) the soccer ball is under the sun.", "content_type": "figure", "figure_type": "\"schematic\""}, "1608.02784v2-Table2-1.png": {"caption": "Table 2: Scene description evaluation results on the test set, comparing the systems from Ortiz et al. to our CCA inference algorithm (the first six results are reported from the Ortiz et al. paper). The CCA result uses m = 120 and \u03b7 = 0.05, tuned on the development set. See text for details about each of the first six baselines.", "content_type": "table", "figure_type": "N/A"}, "1608.02784v2-Figure6-1.png": {"caption": "Examples of outputs from the machine translation system and from CCA inference. The top three images give examples where the CCA inference outputs were rated highly by human evaluations (4 or 5), and the SMT ones were rated poorly (1 or 2). The bottom three pictures give the reverse case.", "content_type": "figure", "figure_type": "photograph(s)"}, "1608.02784v2-Table3-1.png": {"caption": "Table 3: Average ranking by human judges for cases in which the caption has an average rank of 3 or higher (for both CCA and SMT) and when its average rank is lower than 3. \u201cM\u201d stands for SMT average rank and \u201cC\u201d stands for CCA average rank.", "content_type": "table", "figure_type": "N/A"}, "1608.02784v2-Figure1-1.png": {"caption": "The CCA learning algorithm.", "content_type": "figure", "figure_type": "Schematic"}, "1608.02784v2-Figure2-1.png": {"caption": "Figure 2: Demonstration of CCA inference. An object from the input space X (the image on the left x) is mapped to a unit vector. Then, we find the closest unit vector which has an embodiment in the output space, Y . That embodiment is the text on the right, y. It also also holds that \u03c1(u(x), v(y)) = cos \u03b8.", "content_type": "figure", "figure_type": "schematic"}, "1608.02784v2-Figure3-1.png": {"caption": "The CCA decoding algorithm.", "content_type": "figure", "figure_type": "schematic"}, "1608.02784v2-Table1-1.png": {"caption": "Table 1: Example of phrases and their probabilities learned for the function Q(p | y, y\u2032). The marker \u3008begin\u3009 marks the beginning of a sentence.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "Which system from Ortiz et al. achieved the highest BLEU and METEOR scores, and how does it compare to the CCA inference algorithm in terms of performance?", "answer": "The SMT system from Ortiz et al. achieved the highest BLEU score (43.7) and METEOR score (35.6) among their tested systems. While the SMT system outperforms the CCA inference algorithm in terms of BLEU score, the CCA algorithm achieves a slightly higher METEOR score (25.6 vs 25.5).", "explanation": "Table 1 presents the BLEU and METEOR scores for various scene description systems, including several baselines from Ortiz et al. and the CCA inference algorithm. By examining the table, we can identify that the SMT system has the highest values for both metrics among the Ortiz et al. systems. Comparing these scores to the CCA algorithm's scores reveals that the SMT system leads in BLEU score, while the CCA algorithm has a slight edge in METEOR score.", "reference": "1608.02784v2-Table2-1.png"}, {"question": "What is the difference between the outputs of the machine translation system (SMT) and the CCA inference?", "answer": "The SMT outputs are literal translations of the images, while the CCA outputs take into account the context of the images and generate more natural-sounding descriptions.", "explanation": "The figure shows examples of outputs from both systems, side-by-side. The SMT outputs are often grammatically incorrect or awkward, while the CCA outputs are more fluent and natural. For example, in the first image, the SMT output is \"jenny is waving at mike,\" while the CCA output is \"mike and jenny are camping.\" The CCA output is more informative and natural-sounding because it takes into account the context of the image, which shows two people camping.", "reference": "1608.02784v2-Figure6-1.png"}, {"question": "Which system, CCA or SMT, generally performs better when the caption is of low quality (average rank less than 3)?", "answer": "It is difficult to definitively say which system performs better for low-quality captions based solely on the provided data. However, we can observe some trends:\n\n1. When the SMT average rank is below 3, the CCA average rank is also lower (1.64 vs. 1.77).\n2. When the SMT average rank is 3 or higher, the CCA average rank is significantly higher (3.54 vs. 3.46).\n\nThis suggests that CCA might perform relatively better for low-quality captions, but more data and analysis are needed for a conclusive answer.", "explanation": "Table 1 presents the average ranking by human judges for both CCA and SMT systems, categorized by whether the caption has an average rank above or below 3. By comparing the average ranks within each category, we can gain insights into the relative performance of the two systems for different caption quality levels. However, due to the limited data points and potential variations within each category, a definitive conclusion about which system performs better for low-quality captions requires further investigation.", "reference": "1608.02784v2-Table3-1.png"}, {"question": "What is the purpose of the singular value decomposition step in the CCA algorithm?", "answer": "The singular value decomposition step is used to find the projection matrices U and V.", "explanation": "The figure shows that the singular value decomposition step is performed on the matrix D^(-1/2) * \u03a9 * D^(-1/2). This step results in two projection matrices, U and V, which are used to project the data into a lower-dimensional space.", "reference": "1608.02784v2-Figure1-1.png"}, {"question": "What is the relationship between the input space and the output space in CCA inference?", "answer": "The input space and the output space are related by a cosine similarity measure.", "explanation": "The figure shows that an object from the input space (the image on the left) is mapped to a unit vector. Then, the closest unit vector which has an embodiment in the output space is found. The cosine similarity between the two unit vectors is used to measure the relationship between the input and output spaces.", "reference": "1608.02784v2-Figure2-1.png"}, {"question": "What is the role of the temperature variable t in the CCA decoding algorithm?", "answer": "The temperature variable t controls the probability of accepting a new candidate solution y. As t decreases, the probability of accepting a worse solution decreases.", "explanation": "The algorithm uses a simulated annealing approach, where the temperature variable t gradually decreases. The acceptance probability of a new solution y is determined by comparing the similarity scores of y and the current best solution y*. If the score of y is higher, it is always accepted. Otherwise, it is accepted with a probability that depends on the difference in scores and the current temperature t. As t decreases, the probability of accepting a worse solution decreases, ensuring that the algorithm converges to a good solution.", "reference": "1608.02784v2-Figure3-1.png"}, {"question": "What is the relationship between BLEU score and human ranking for CCA and SMT systems?", "answer": "The correlation between BLEU scores and human ranking is not high for either CCA or SMT systems.", "explanation": "The passage states that the correlation between the $x$-axis (ranking) and $y$-axis (BLEU scores) for CCA is $0.3$ and for the SMT system $0.31$. This indicates a weak positive correlation, meaning that higher BLEU scores are not necessarily associated with higher human rankings.", "reference": "1608.02784v2-Figure4-1.png"}]}, "1611.02654v2": {"paper_id": "1611.02654v2", "all_figures": {"1611.02654v2-Table4-1.png": {"caption": "Performance comparison for semantic similarity and paraphrase detection. The first row shows the best performing purely supervised methods. The last section shows our models.", "content_type": "table", "figure_type": "table"}, "1611.02654v2-Table3-1.png": {"caption": "Comparison on extractive summarization between models trained from scratch and models pre-trained with the ordering task.", "content_type": "table", "figure_type": "table"}, "1611.02654v2-Figure2-1.png": {"caption": "t-SNE embeddings of representations learned by the model for sentences from the test set. Embeddings are color coded by the position of the sentence in the document it appears.", "content_type": "figure", "figure_type": "** plot"}, "1611.02654v2-Table5-1.png": {"caption": "Table 5: Visualizing salient words (Abstracts are from the AAN corpus).", "content_type": "table", "figure_type": "N/A"}, "1611.02654v2-Table1-1.png": {"caption": "Table 1: Mean Accuracy comparison on the Accidents and Earthquakes data for the order discrimination task. The reference models are Entity-Grid (Barzilay and Lapata 2008), HMM (Louis and Nenkova 2012), Graph (Guinaudeau and Strube 2013), Window network (Li and Hovy 2014) and sequence-to-sequence (Li and Jurafsky 2016), respectively.", "content_type": "table", "figure_type": "N/A"}, "1611.02654v2-Table2-1.png": {"caption": "Comparison against prior methods on the abstracts data.", "content_type": "table", "figure_type": "table"}}, "qa": [{"question": "Which model performed the best on the SICK dataset according to the MSE metric?", "answer": "The supervised model performed the best on the SICK dataset according to the MSE metric.", "explanation": "The table shows the MSE for each model on the SICK dataset. The supervised model has the lowest MSE of 0.253.", "reference": "1611.02654v2-Table4-1.png"}, {"question": "What is the effect of pre-training with the ordering task on the ROUGE-L score for extractive summarization?", "answer": "Pre-training with the ordering task increases the ROUGE-L score for extractive summarization.", "explanation": "The table shows that the ROUGE-L score for models pre-trained with the ordering task is higher than the ROUGE-L score for models trained from scratch, for both summary lengths.", "reference": "1611.02654v2-Table3-1.png"}, {"question": "Which model performs the best for the order discrimination task on the Accidents dataset and how does it compare to the other data-driven approaches?", "answer": "The proposed model in this paper achieves the best performance for the order discrimination task on the Accidents dataset with an accuracy of 0.944. It outperforms the other data-driven approaches, namely Window (Recurrent) with 0.840, Window (Recursive) with 0.864, and Seq2seq with 0.930.", "explanation": "Table 1 presents the mean accuracy of different models on the Accidents and Earthquakes datasets for the order discrimination task. By comparing the accuracy values within the Accidents row, we can identify which model performs best. Our model has the highest value (0.944) compared to the other data-driven models listed in the table.", "reference": "1611.02654v2-Table1-1.png"}, {"question": "What can you say about the relationship between the sentences in a document based on the t-SNE embeddings?", "answer": "Sentences that are closer together in the embedding space are more semantically similar than those that are farther apart.", "explanation": " The t-SNE embeddings are color-coded by the position of the sentence in the document. We can see that sentences that are close together in the embedding space tend to be from the same part of the document, which suggests that they are semantically similar. ", "reference": "1611.02654v2-Figure2-1.png"}, {"question": "How does the proposed model compare to the other models in terms of accuracy on the NIPS Abstracts dataset?", "answer": "The proposed model has the highest accuracy on the NIPS Abstracts dataset, with an accuracy of 51.55.", "explanation": "The table shows the accuracy of different models on three different datasets. The proposed model has the highest accuracy on the NIPS Abstracts dataset.", "reference": "1611.02654v2-Table2-1.png"}]}, "1701.03077v10": {"paper_id": "1701.03077v10", "all_figures": {"1701.03077v10-Figure1-1.png": {"caption": "Our general loss function (left) and its gradient (right) for different values of its shape parameter \u03b1. Several values of \u03b1 reproduce existing loss functions: L2 loss (\u03b1 = 2), Charbonnier loss (\u03b1 = 1), Cauchy loss (\u03b1 = 0), Geman-McClure loss (\u03b1 = \u22122), and Welsch loss (\u03b1 = \u2212\u221e).", "content_type": "figure", "figure_type": "plot"}, "1701.03077v10-Figure4-1.png": {"caption": "Monocular depth estimation results on the KITTI benchmark using the \u201cBaseline\u201d network of [42]. Replacing only the network\u2019s loss function with our \u201cadaptive\u201d loss over wavelet coefficients results in significantly improved depth estimates.", "content_type": "figure", "figure_type": "photograph(s)"}, "1701.03077v10-Table2-1.png": {"caption": "Table 2. Results on unsupervised monocular depth estimation using the KITTI dataset [13], building upon the model from [42] (\u201cBaseline\u201d). By replacing the per-pixel loss used by [42] with several variants of our own per-wavelet general loss function in which our loss\u2019s shape parameters are fixed, annealed, or adaptive, we see a significant performance improvement. The top three techniques are colored red, orange, and yellow for each metric.", "content_type": "table", "figure_type": "N/A"}, "1701.03077v10-Figure8-1.png": {"caption": "Because our distribution\u2019s log partition function log(Z (\u03b1)) is difficult to evaluate for arbitrary inputs, we approximate it using cubic hermite spline interpolation in a transformed space: first we curve \u03b1 by a continuously differentiable nonlinearity that increases knot density near \u03b1 = 2 and decreases knot density when \u03b1 > 4 (top) and then we fit an evenly-sampled cubic hermite spline in that curved space (bottom). The dots shown in the bottom plot are a subset of the knots used by our cubic spline, and are presented here to demonstrate how this approach allocates spline knots with respect to \u03b1.", "content_type": "figure", "figure_type": "plot"}, "1701.03077v10-Figure13-1.png": {"caption": "The final shape parameters \u03b1 for our unsupervised monocular depth estimation model trained on KITTI data. The parameters are visualized in the same \u201cYUV + Wavelet\u201d output space as was used during training, where black is \u03b1 = 0 and white is \u03b1 = 2.", "content_type": "figure", "figure_type": "Plot"}, "1701.03077v10-Figure5-1.png": {"caption": "Performance (lower is better) of our gFGR algorithm on the task of [41] as we vary our shape parameter \u03b1, with the lowest-error point indicated by a circle. FGR (equivalent to gFGR with \u03b1 = \u22122) is shown as a dashed line and a square, and shapeannealed gFGR for each noise level is shown as a dotted line.", "content_type": "figure", "figure_type": "plot"}, "1701.03077v10-Table3-1.png": {"caption": "Table 3. Results on the registration task of [41], in which we compare their \u201cFGR\u201d algorithm to two versions of our \u201cgFGR\u201d generalization.", "content_type": "table", "figure_type": "N/A"}, "1701.03077v10-Figure7-1.png": {"caption": "Our general loss\u2019s IRLS weight function (left) and \u03a8function (right) for different values of the shape parameter \u03b1.", "content_type": "figure", "figure_type": "plot"}, "1701.03077v10-Figure12-1.png": {"caption": "As is common practice, the VAE samples shown in this paper are samples from the latent space (left) but not from the final conditional distribution (right). Here we contrast decoded means and samples from VAEs using our different output spaces, all using our general distribution.", "content_type": "figure", "figure_type": "photograph(s)"}, "1701.03077v10-Figure11-1.png": {"caption": "The final shape and scale parameters {\u03b1(i)} and {c(i)} for our \u201cWavelets + YUV\u201d VAE after training has converged. We visualize \u03b1 with black=0 and white=2 and log(c) with black=log(0.00002) and white=log(0.2).", "content_type": "figure", "figure_type": "other"}, "1701.03077v10-Figure10-1.png": {"caption": "The final shape and scale parameters {\u03b1(i)} and {c(i)} for our \u201cPixels + RGB\u201d VAE after training has converged. We visualize \u03b1 with black=0 and white=2 and log(c) with black=log(0.002) and white=log(0.02).", "content_type": "figure", "figure_type": "photograph(s)"}, "1701.03077v10-Figure16-1.png": {"caption": "Monocular depth estimation results on the KITTI benchmark using the \u201cBaseline\u201d network of [42] and our own variant in which we replace the network\u2019s loss function with our own adaptive loss over wavelet coefficients. Changing only the loss function results in significantly improved depth estimates.", "content_type": "figure", "figure_type": "photograph(s)"}, "1701.03077v10-Figure9-1.png": {"caption": "Figure 9. Here we compare the validation set ELBO of our adaptive \u201cWavelets + YUV\u201d VAE model with the ELBO achieved when setting all wavelet coefficients to have the same fixed shape parameter \u03b1. We see that allowing our distribution to individually adapt its shape parameter to each coefficient outperforms any single fixed shape parameter.", "content_type": "figure", "figure_type": "plot"}, "1701.03077v10-Table4-1.png": {"caption": "Table 4. Results on the clustering task of [32] where we compare their \u201cRCC\u201d algorithm to our \u201cgRCC*\u201d generalization in terms of AMI on several datasets. We also report the AMI increase of \u201cgRCC*\u201d with respect to \u201cRCC\u201d. Baselines are taken from [32].", "content_type": "table", "figure_type": "N/A"}, "1701.03077v10-Figure6-1.png": {"caption": "Figure 6. Performance (higher is better) of our gRCC algorithm on the clustering task of [32], for different values of our shape parameter \u03b1, with the highest-accuracy point indicated by a dot. Because the baseline RCC algorithm is equivalent to gRCC with \u03b1 = \u22122, we highlight that \u03b1 value with a dashed line and a square.", "content_type": "figure", "figure_type": "plot"}, "1701.03077v10-Figure2-1.png": {"caption": "The negative log-likelihoods (left) and probability densities (right) of the distribution corresponding to our loss function when it is defined (\u03b1 \u2265 0). NLLs are simply losses (Fig. 1) shifted by a log partition function. Densities are bounded by a scaled Cauchy distribution.", "content_type": "figure", "figure_type": "** Plot"}, "1701.03077v10-Figure17-1.png": {"caption": "Additional monocular depth estimation results, in the same format as Figure 16.", "content_type": "figure", "figure_type": "photograph(s)"}, "1701.03077v10-Figure15-1.png": {"caption": "Reconstructions from our family of trained variational autoencoders, in which we use one of three different image representations for modeling images (super-columns) and use either normal, Cauchy, Student\u2019s t, or our general distributions for modeling the coefficients of each representation (sub-columns). The leftmost column shows the images which are used as input to each autoencoder. Reconstructions from models using general distributions tend to be sharper and more detailed than reconstructions from the corresponding model that uses normal distributions, particularly for the DCT or wavelet representations, though this difference is less pronounced than what is seen when comparing samples from these models. The DCT and wavelet models trained with Cauchy distributions or Student\u2019s t-distributions systematically fail to preserve the background of the input image, as was noted when observing samples from these distributions.", "content_type": "figure", "figure_type": "photograph(s)"}, "1701.03077v10-Table1-1.png": {"caption": "Table 1. Validation set ELBOs (higher is better) for our variational autoencoders. Models using our general distribution better maximize the likelihood of unseen data than those using normal or Cauchy distributions (both special cases of our model) for all three image representations, and perform similarly to Student\u2019s tdistribution (a different generalization of normal and Cauchy distributions). The best and second best performing techniques for each representation are colored orange and yellow respectively.", "content_type": "table", "figure_type": "N/A"}, "1701.03077v10-Figure3-1.png": {"caption": "Random samples from our variational autoencoders. We use either normal, Cauchy, Student\u2019s t, or our general distributions (columns) to model the coefficients of three different image representations (rows). Because our distribution can adaptively interpolate between Cauchy-like or normal-like behavior for each coefficient individually, using it results in sharper and higher-quality samples (particularly when using DCT or wavelet representations) and does a better job of capturing low-frequency image content than Student\u2019s t-distribution.", "content_type": "figure", "figure_type": "photograph(s)"}, "1701.03077v10-Figure14-1.png": {"caption": "Random samples (more precisely, means of the output distributions decoded from random samples in our latent space) from our family of trained variational autoencoders.", "content_type": "figure", "figure_type": "photograph(s)"}}, "qa": [{"question": "How does the shape of the IRLS weight function change as the shape parameter \u03b1 increases?", "answer": "The IRLS weight function becomes more peaked and concentrated around zero as the shape parameter \u03b1 increases.", "explanation": "The left panel of the figure shows the IRLS weight function for different values of \u03b1. As \u03b1 increases, the function becomes narrower and taller, with a sharper peak at zero. This indicates that the weight function gives more importance to data points that are close to zero and less importance to data points that are further away.", "reference": "1701.03077v10-Figure7-1.png"}, {"question": "How do the reconstructed faces in the \"Mean Reconstruction\" differ from those in the \"Sampled Reconstruction\"?", "answer": "The reconstructed faces in the \"Mean Reconstruction\" are smoother and less detailed than those in the \"Sampled Reconstruction\". This is because the mean reconstruction is based on the average of all the possible reconstructions, while the sampled reconstruction is based on a single sample from the distribution.", "explanation": "The figure shows that the mean reconstruction is smoother and less detailed than the sampled reconstruction for all four output spaces. This suggests that the mean reconstruction is a less accurate representation of the original image than the sampled reconstruction.", "reference": "1701.03077v10-Figure12-1.png"}, {"question": "How does the performance of the adaptive model compare to the fixed model with different values of \u03b1?", "answer": "The adaptive model consistently outperforms the fixed model for all values of \u03b1.", "explanation": "The plot shows that the test set ELBO (evidence lower bound) of the adaptive model (blue line) is always higher than the ELBO of the fixed model (red line) for all values of \u03b1. A higher ELBO indicates better performance.", "reference": "1701.03077v10-Figure9-1.png"}, {"question": "On which dataset did the gRCC* algorithm achieve the largest relative improvement over the RCC algorithm, and by approximately how much did it improve?", "answer": "The gRCC* algorithm achieved the largest relative improvement over the RCC algorithm on the YTF dataset, with a relative improvement of approximately 31.9%.", "explanation": "The table shows the AMI values for both gRCC* and RCC algorithms on various datasets. The \"Rel. Impr.\" column shows the relative improvement of gRCC* compared to RCC. By looking at this column, we can identify that the YTF dataset has the highest value (31.9%), indicating the most significant improvement achieved by gRCC*.", "reference": "1701.03077v10-Table4-1.png"}, {"question": "What is the relationship between the shape parameter \u03b1 and the shape of the loss function?", "answer": "The shape parameter \u03b1 controls the shape of the loss function. As \u03b1 increases, the loss function becomes more peaked, and as \u03b1 decreases, the loss function becomes more flat.", "explanation": "The left plot shows the loss function for different values of \u03b1. For large values of \u03b1, the loss function is very peaked around zero, which means that small errors are penalized more heavily. For small values of \u03b1, the loss function is flatter, which means that small errors are penalized less heavily.", "reference": "1701.03077v10-Figure1-1.png"}, {"question": "What is the effect of replacing the loss function in the \"Baseline\" network with the \"adaptive\" loss over wavelet coefficients?", "answer": "Replacing the loss function in the \"Baseline\" network with the \"adaptive\" loss over wavelet coefficients results in significantly improved depth estimates.", "explanation": "The figure shows the input image, the depth estimates from the \"Baseline\" network, the depth estimates from the network with the \"adaptive\" loss, and the ground truth depth. The depth estimates from the network with the \"adaptive\" loss are much closer to the ground truth than the depth estimates from the \"Baseline\" network.", "reference": "1701.03077v10-Figure4-1.png"}, {"question": "Which method for setting the shape parameter of the proposed loss function achieved the best performance in terms of average error? How much improvement did it offer compared to the reproduced baseline?", "answer": "The \"adaptive $\\power \\in (0, 2)$\" strategy, where each wavelet coefficient has its own shape parameter that is optimized during training, achieved the best performance in terms of average error. It reduced the average error by approximately 17% compared to the reproduced baseline.", "explanation": "The table presents various error and accuracy metrics for different methods of setting the shape parameter in the proposed loss function. The \"adaptive $\\power \\in (0, 2)$\" model shows the lowest average error (0.332) among all the listed methods. The reproduced baseline has an average error of 0.398. The percentage improvement can be calculated as: \n\n(0.398 - 0.332) / 0.398 * 100% \u2248 17%", "reference": "1701.03077v10-Table2-1.png"}, {"question": "Why did the authors choose to use a nonlinearity to curve \u03b1 before fitting the cubic hermite spline?", "answer": "The authors chose to use a nonlinearity to curve \u03b1 before fitting the cubic hermite spline because it allows for increased knot density near \u03b1 = 2 and decreased knot density when \u03b1 > 4. This helps to better approximate the log partition function, which is difficult to evaluate for arbitrary inputs.", "explanation": "The top plot of the figure shows the nonlinearity that is used to curve \u03b1. The bottom plot shows the cubic hermite spline that is fit to the curved \u03b1. The dots in the bottom plot represent the knots that are used by the spline. It can be seen that the knots are more densely spaced near \u03b1 = 2 and less densely spaced when \u03b1 > 4. This is because the nonlinearity curves \u03b1 in such a way that more knots are needed to accurately approximate the log partition function in the region where \u03b1 is close to 2, and fewer knots are needed when \u03b1 is greater than 4.", "reference": "1701.03077v10-Figure8-1.png"}, {"question": "What is the range of values for the shape parameter \u03b1?", "answer": "The range of values for the shape parameter \u03b1 is from 0 to 2.", "explanation": "The caption states that \"black is \u03b1 = 0 and white is \u03b1 = 2.\"", "reference": "1701.03077v10-Figure13-1.png"}, {"question": "How does the performance of gFGR change as the shape parameter \u03b1 increases?", "answer": "The performance of gFGR generally improves as the shape parameter \u03b1 increases.", "explanation": "The figure shows that the mean RMSE and max RMSE both decrease as \u03b1 increases, indicating better performance.", "reference": "1701.03077v10-Figure5-1.png"}, {"question": "Which image representation results in the sharpest and highest-quality samples?", "answer": "DCT and wavelet representations.", "explanation": "The figure shows that the samples generated using our distribution are sharper and of higher quality when using DCT or wavelet representations than when using other representations. This is because our distribution can adaptively interpolate between Cauchy-like or normal-like behavior for each coefficient individually, which results in a better capture of low-frequency image content.", "reference": "1701.03077v10-Figure3-1.png"}, {"question": "Which dataset shows the greatest sensitivity to the choice of $\\power$?", "answer": "RCV1", "explanation": "The RCV1 dataset shows the largest range of AMI values across the different values of $\\power$, indicating that the performance of the algorithm on this dataset is highly dependent on the choice of $\\power$.", "reference": "1701.03077v10-Figure6-1.png"}, {"question": "How does the shape of the negative log-likelihood (NLL) and probability density functions change as the value of \u03b1 increases?", "answer": " As the value of \u03b1 increases, the NLL functions become more peaked and the probability density functions become more concentrated around the mean.", "explanation": " The left panel of the figure shows the NLL functions for different values of \u03b1. As \u03b1 increases, the NLL functions become more peaked, indicating that the loss function is more sensitive to deviations from the mean. The right panel of the figure shows the corresponding probability density functions. As \u03b1 increases, the probability density functions become more concentrated around the mean, indicating that the distribution is becoming more peaked.", "reference": "1701.03077v10-Figure2-1.png"}, {"question": "How do the results of the baseline and the proposed method compare in terms of accuracy?", "answer": "The proposed method appears to be more accurate than the baseline method. The depth maps generated by the proposed method are more detailed and realistic than those generated by the baseline method.", "explanation": "The figure shows that the depth maps generated by our method are closer to the ground truth than the depth maps generated by the baseline method. This indicates that our method is more accurate than the baseline method.", "reference": "1701.03077v10-Figure17-1.png"}, {"question": "How does the choice of distribution affect the quality of the reconstructions?", "answer": "Reconstructions from models using general distributions tend to be sharper and more detailed than reconstructions from the corresponding model that uses normal distributions.", "explanation": "This can be seen in the figure by comparing the reconstructions in the \"Ours\" columns to the reconstructions in the \"Normal\" columns. For example, the reconstructions in the \"Ours\" column for the DCT + YUV representation are much sharper and more detailed than the reconstructions in the \"Normal\" column.", "reference": "1701.03077v10-Figure15-1.png"}]}, "1802.07222v1": {"paper_id": "1802.07222v1", "all_figures": {"1802.07222v1-Figure4-1.png": {"caption": "Algorithm 1 when Theorem 2 holds.", "content_type": "figure", "figure_type": "plot"}, "1802.07222v1-Figure5-1.png": {"caption": "007\u2019s accuracy for varying drop rates.", "content_type": "figure", "figure_type": "plot"}, "1802.07222v1-Figure6-1.png": {"caption": "007\u2019s accuracy for varying noise levels.", "content_type": "figure", "figure_type": "plot"}, "1802.07222v1-Figure3-1.png": {"caption": "When Theorem 2 holds.", "content_type": "figure", "figure_type": "plot"}, "1802.07222v1-Table1-1.png": {"caption": "Number of ICMPs per second per switch (T ). We see max(T )\u2264 Tmax.", "content_type": "table", "figure_type": "table"}, "1802.07222v1-Figure1-1.png": {"caption": "Observations from a production network: (a) CDF of the number of flows with at least one retransmission; (b) CDF of the fraction of drops belonging to each flow in each 30 second interval.", "content_type": "figure", "figure_type": "plot"}, "1802.07222v1-Figure2-1.png": {"caption": "Overview of 007 architecture", "content_type": "figure", "figure_type": "schematic"}, "1802.07222v1-Figure16-1.png": {"caption": "Illustration of notation for Clos topology used in the proof of Lemma 2", "content_type": "figure", "figure_type": "** Schematic"}, "1802.07222v1-Figure8-1.png": {"caption": "007\u2019s accuracy under skewed traffic.", "content_type": "figure", "figure_type": "plot"}, "1802.07222v1-Figure12-1.png": {"caption": "Algorithm 1 with multiple failures. The drop rates on the links are heavily skewed.", "content_type": "figure", "figure_type": "plot"}, "1802.07222v1-Figure7-1.png": {"caption": "Varying the number of connections.", "content_type": "figure", "figure_type": "plot"}, "1802.07222v1-Figure11-1.png": {"caption": "Impact of link location on Algorithm 1.", "content_type": "figure", "figure_type": "plot"}, "1802.07222v1-Figure9-1.png": {"caption": "Impact of a hot ToR on 007\u2019s accuracy.", "content_type": "figure", "figure_type": "plot"}, "1802.07222v1-Figure10-1.png": {"caption": "Algorithm 1 with single failure.", "content_type": "figure", "figure_type": "plot"}, "1802.07222v1-Table2-1.png": {"caption": "Notation and nomenclature", "content_type": "table", "figure_type": "table"}, "1802.07222v1-Figure13-1.png": {"caption": "Distribution of the difference between votes on bad links and the maximum vote on good links for different bad link drop rates.", "content_type": "figure", "figure_type": "plot"}, "1802.07222v1-Figure15-1.png": {"caption": "Simple tomography example.", "content_type": "figure", "figure_type": "Schematic"}, "1802.07222v1-Figure14-1.png": {"caption": "Number of network related reboots in a day.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "During which hours of the day did the most network-related reboots occur?", "answer": "The most network-related reboots occurred between 18:00 and 20:00.", "explanation": "The plot shows the number of network-related reboots as a function of the hour of the day. The peak of the plot occurs between 18:00 and 20:00, indicating that the most reboots occurred during this time period.", "reference": "1802.07222v1-Figure14-1.png"}]}, "1603.00286v5": {"paper_id": "1603.00286v5", "all_figures": {"1603.00286v5-Figure5-1.png": {"caption": "Fig. 5 The points in the blue trapezoid are mapped to the points on the blue interval at the bottom side of the polygon; each point in the trapezoid is mapped to the point just below it, which is the point nearest to it on the polygon perimeter.", "content_type": "figure", "figure_type": "schematic"}, "1603.00286v5-Figure3-1.png": {"caption": "Fig. 3 Solid boxes represent the value-density of agent j within Zj ; each dotted box represents a value-density of some other agent in the same group as agent j. In this example, dn d e = 5.", "content_type": "figure", "figure_type": "schematic"}, "1603.00286v5-Figure4-1.png": {"caption": "Fig. 4 Allocation-completion with n = 4 original pieces and b = 1 blank, denoted Z\u20325.", "content_type": "figure", "figure_type": "schematic"}, "1603.00286v5-Table1-1.png": {"caption": "Table 1 Worst-case number of blanks in a maximal arrangement of pairwise-disjoint Spieces contained in a cake C. From Akopyan and Segal-Halevi (2018).", "content_type": "table", "figure_type": "N/A"}, "1603.00286v5-Figure1-1.png": {"caption": "Fig. 1 With geometric constraints, an efficient allocation might leave some cake unallocated. All figures were made with GeoGebra 5 (Hohenwarter et al., 2013).", "content_type": "figure", "figure_type": "** Schematic"}, "1603.00286v5-Figure2-1.png": {"caption": "Fig. 2 A rectilinear polygon with T = 4 reflex vertices (circled).", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "Which agent values the entire share $Z_j$?", "answer": "Agent $j$.", "explanation": "The passage states that agent $j$ values $Z_j$ at $\\lceil{n\\over d}\\rceil$, and the rest of the cake at $0$. This means that agent $j$ values the entire share $Z_j$. The figure shows that the value-density of agent $j$ is positive within the entire share $Z_j$, which is consistent with the passage.", "reference": "1603.00286v5-Figure3-1.png"}, {"question": "What is the purpose of the blank space labeled Z'5?", "answer": "The blank space labeled Z'5 is used to complete the allocation of the original pieces.", "explanation": "The figure shows how the original pieces (labeled Z1-Z4) can be allocated to the blank space (labeled Z'5) in order to complete the puzzle.", "reference": "1603.00286v5-Figure4-1.png"}, {"question": "What can you say about the relationship between the complexity of a cake shape and the minimum number of blanks required for a complete partition into smaller pieces?", "answer": "The complexity of the cake shape generally leads to a higher minimum number of blanks required for a complete partition.", "explanation": "Table 1 shows that simple shapes like polygons and simple polygons (without holes) require no blanks for a complete partition. However, as the complexity increases, like in axes-parallel rectangles, convex figures, and rectilinear polygons with reflex vertices, the minimum number of blanks also increases. This suggests that more complex shapes necessitate more blanks to achieve a complete partition into smaller pieces.", "reference": "1603.00286v5-Table1-1.png"}, {"question": " \n\nWhy does the author state that there is a qualitative difference between 2-D and 1-D division?", "answer": " \n\nIn 2-D division, there may be unallocated cake even when there are geometric constraints on the pieces, as shown in Figure 1. This is not the case in 1-D division, where the entire cake can always be allocated.", "explanation": " \n\nFigure 1 shows an example of a 2-D cake where there is unallocated cake even though the pieces must be rectangles. This is because the geometric constraints on the pieces prevent them from being placed in such a way that the entire cake is allocated. This qualitative difference between 2-D and 1-D division is important to note, as it can lead to paradoxes that are not present in 1-D division.", "reference": "1603.00286v5-Figure1-1.png"}, {"question": "What is the minimum number of sides that a rectilinear polygon with four reflex vertices must have?", "answer": "Six.", "explanation": "A reflex vertex is a vertex with an interior angle greater than 180 degrees. In a rectilinear polygon, each vertex is either a right angle or a reflex angle. Therefore, the minimum number of sides that a rectilinear polygon with four reflex vertices must have is six, as shown in the figure.", "reference": "1603.00286v5-Figure2-1.png"}]}, "1603.03833v4": {"paper_id": "1603.03833v4", "all_figures": {"1603.03833v4-Figure3-1.png": {"caption": "Figure 3: The training and evaluation phase. During the training the LSTM network is unrolled for 50 time-steps. The gripper pose and status (open/close) et and the pose of relevant objects qt at time-step t is used as input and output of the network to calculate and backpropagate the error to update the weights. During the evaluation phase, the mixture density parameters are used to form a mixture of Gaussians and draw a sample from it. The sample is used to control the robot arm.", "content_type": "figure", "figure_type": "schematic"}, "1603.03833v4-Table1-1.png": {"caption": "Table 1: The size of the datasets for the two studied tasks", "content_type": "table", "figure_type": "N/A"}, "1603.03833v4-Figure2-1.png": {"caption": "Figure 2: Creating multiple trajectories from a demonstration recorded at a higher frequency.", "content_type": "figure", "figure_type": "** Schematic"}, "1603.03833v4-Figure1-1.png": {"caption": "Figure 1: The general flow of our approach. The demonstrations of the ADL manipulation tasks are collected in a virtual environment. The collected trajectories are used to train the neural network controller.", "content_type": "figure", "figure_type": "schematic"}, "1603.03833v4-Figure4-1.png": {"caption": "A sequence of images showing the autonomous execution of pick and place in simulation (first row), pick and place in real world (second row), pushing in simulation (third row), and pushing in real world (fourth row). The robot is controlled by a mixture density network with 3 layers of LSTM.", "content_type": "figure", "figure_type": "photograph(s)"}, "1603.03833v4-Figure5-1.png": {"caption": "Figure 5: Alternative network architectures used in the comparison study: Feedforward-MSE, LSTM-MSE and Feedforward-MDN", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "What is the role of the LSTM-MDN network in the training phase?", "answer": "The LSTM-MDN network is used to learn the relationship between the gripper pose and status, the pose of relevant objects, and the joint angles of the robot arm.", "explanation": "The figure shows that the LSTM-MDN network is unrolled for 50 time-steps during the training phase. The gripper pose and status (open/close)  \ud835\udc52\ud835\udc61  and the pose of relevant objects  \ud835\udc5e\ud835\udc61  at time-step  \ud835\udc61  is used as input and output of the network to calculate and backpropagate the error to update the weights. This process allows the network to learn the relationship between the inputs and outputs.", "reference": "1603.03833v4-Figure3-1.png"}, {"question": "Why is the number of demonstrations after the shift not available for the \"Push to Pose\" task?", "answer": "The passage mentions that additional trajectories were generated for the \"Pick and Place\" task by reducing the frequency of the recorded demonstrations. This process was not applied to the \"Push to Pose\" task, therefore no \"Demonstrations after shift\" are listed for it.", "explanation": "The table shows a significant increase in the number of demonstrations for the \"Pick and Place\" task after applying the frequency reduction technique (\"Demonstrations after shift\"). This value is absent for the \"Push to Pose\" task, indicating that this specific technique was not used for that task.", "reference": "1603.03833v4-Table1-1.png"}, {"question": "How does the frequency reduction process create multiple trajectories from a single demonstration?", "answer": " The frequency reduction process takes a high-frequency trajectory and samples it at a lower frequency, resulting in multiple trajectories with different starting and ending points. ", "explanation": "Figure 0 shows how the original trajectory (recorded at 33Hz) is sampled at a lower frequency (4Hz) to generate 8 different trajectories. The waypoints are used to guide the generation of the new trajectories.", "reference": "1603.03833v4-Figure2-1.png"}, {"question": "What is the role of the virtual environment in the proposed approach?", "answer": "The virtual environment is used to collect demonstrations of the task from the user. This allows for safe and efficient data collection.", "explanation": "The left side of Figure 1 shows the virtual environment, which includes a simulation of the task and a user interface (Xbox controller) for providing demonstrations. The figure also shows that the collected trajectories are used to train the neural network controller.", "reference": "1603.03833v4-Figure1-1.png"}, {"question": "What is the difference between the pick and place task in simulation and the real world?", "answer": "In the simulation, the robot is able to pick up the object and place it in the desired location without any errors. However, in the real world, the robot makes some errors, such as dropping the object or placing it in the wrong location.", "explanation": "The first row of images shows the pick and place task in simulation, while the second row shows the same task in the real world. The images in the real world show that the robot is not as precise as it is in the simulation.", "reference": "1603.03833v4-Figure4-1.png"}, {"question": "What are the three different network architectures used in the comparison study?", "answer": "Feedforward-MSE, LSTM-MSE, and Feedforward-MDN.", "explanation": "The figure shows the three different network architectures used in the comparison study. Each network architecture is shown with its corresponding name.", "reference": "1603.03833v4-Figure5-1.png"}]}, "1605.07496v3": {"paper_id": "1605.07496v3", "all_figures": {"1605.07496v3-Table1-1.png": {"caption": "Comparison of the performance of ALOQ, MAP and RQ-ALOQ policies when p(\u03b8) must be estimated", "content_type": "table", "figure_type": "table"}, "1605.07496v3-Figure2-1.png": {"caption": "Performance and learned configurations on the robotic arm collision avoidance task.", "content_type": "figure", "figure_type": "plot"}, "1605.07496v3-Figure3-1.png": {"caption": "Performance and learned configurations on the robotic arm joint breakage task.", "content_type": "figure", "figure_type": "plot"}, "1605.07496v3-Table2-1.png": {"caption": "Quartiles of the expected cost of the final \u03c0\u0302\u2217 estimated by each algorithm across 20 independent runs for the Robotic Arm Simulator experiments.", "content_type": "table", "figure_type": "table"}, "1605.07496v3-Figure4-1.png": {"caption": "Performance of Reinforce and TRPO on the Robotic Arm Simulator experiments.", "content_type": "figure", "figure_type": "plot"}, "1605.07496v3-Figure6-1.png": {"caption": "Per-step runtime for each method on the Robotic Arm Simulator experiments", "content_type": "figure", "figure_type": "plot"}, "1605.07496v3-Figure11-1.png": {"caption": "Comparison of runtime of all methods on the FSRE test functions.", "content_type": "figure", "figure_type": "plot"}, "1605.07496v3-Figure10-1.png": {"caption": "Comparison of performance of all methods on the F-SRE test functions (higher is better) .", "content_type": "figure", "figure_type": "plot"}, "1605.07496v3-Figure1-1.png": {"caption": "ALOQ models the return f as a function of (\u03c0, \u03b8); (a) the predicted mean based on some observed data; (b) the predicted return of \u03c0 = 1.5 for different \u03b8, together with the uncertainty associated with them, given p(\u03b8); (c) ALOQ marginalises out \u03b8 and computes f\u0304(\u03c0) and its associated uncertainty, which is used to actively select \u03c0.", "content_type": "figure", "figure_type": "Plot"}, "1605.07496v3-Table3-1.png": {"caption": "Quartiles of the expected function value of the final \u03c0\u0302\u2217 estimated by each algorithm across 20 independent runs for each of the four artificial test functions.", "content_type": "table", "figure_type": "table"}, "1605.07496v3-Figure9-1.png": {"caption": "Contour plot of F-SRE1 and F-SRE2 (values in SRE region have been reduced by a factor of 10).", "content_type": "figure", "figure_type": "plot"}, "1605.07496v3-Figure8-1.png": {"caption": "Comparison of runtime of all methods on the modified Branin and Hartmann 6 test function used by Williams, Santner, and Notz.", "content_type": "figure", "figure_type": "plot"}, "1605.07496v3-Figure7-1.png": {"caption": "Comparison of performance of all methods on the modified Branin and Hartmann 6 test functions used by Williams, Santner, and Notz.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which policy resulted in the highest average cost?", "answer": "MAP Policy", "explanation": "The table shows the average cost for each policy. The MAP Policy has the highest average cost of 28.76.", "reference": "1605.07496v3-Table1-1.png"}, {"question": "Which of the algorithms performs the best on the robotic arm joint breakage task?", "answer": "ALOQ.", "explanation": "Figure (a) shows that ALOQ has the lowest expected cost compared to the other algorithms.", "reference": "1605.07496v3-Figure3-1.png"}, {"question": "Which algorithm performs the best in the Joint Breakage experiment?", "answer": "ALOQ", "explanation": "The table shows the quartiles of the expected cost of the final \u03c0\u0302\u2217 estimated by each algorithm across 20 independent runs for the Robotic Arm Simulator experiments. The lower the cost, the better the performance. In the Joint Breakage experiment, ALOQ has the lowest Q1, median, and Q2 values.", "reference": "1605.07496v3-Table2-1.png"}, {"question": "Which algorithm performed better on the arm breakage task?", "answer": "Both TRPO and Reinforce performed similarly on the arm breakage task.", "explanation": "The figure shows that the expected cost for both algorithms decreases to a similar level after around 400 simulator calls.", "reference": "1605.07496v3-Figure4-1.png"}, {"question": "Between WSN and ALOQ, which method is the most efficient in terms of runtime for both F-SRE1 and F-SRE2?", "answer": "ALOQ is significantly more efficient than WSN.", "explanation": "The figure shows that the One Step ALOQ method has the lowest runtime for both F-SRE1 and F-SRE2.", "reference": "1605.07496v3-Figure11-1.png"}, {"question": "Which method performs the best on the F-SRE1 test function?", "answer": "ALOQ", "explanation": "The figure shows that ALOQ has the highest expected function value for the F-SRE1 test function.", "reference": "1605.07496v3-Figure10-1.png"}, {"question": "How does the predicted return change as a function of \u03b8 for a fixed value of \u03c0 = 1.5?", "answer": "The predicted return decreases as \u03b8 increases, with a minimum at around \u03b8 = 0.5.", "explanation": "Figure (b) shows the predicted return for different values of \u03b8 when \u03c0 = 1.5. The blue line represents the mean predicted return, and the shaded area represents the uncertainty associated with the prediction. As \u03b8 increases, the mean predicted return decreases, and the uncertainty increases.", "reference": "1605.07496v3-Figure1-1.png"}, {"question": "What is the difference between the \"True max\" and the \"ALOQ\" curves?", "answer": "The \"True max\" curve is the true maximum of the function, while the \"ALOQ\" curve is an approximation of the maximum. The \"ALOQ\" curve is lower than the \"True max\" curve, indicating that it underestimates the maximum value of the function.", "explanation": "The figure shows that the \"True max\" curve is higher than the \"ALOQ\" curve at all points. This indicates that the \"ALOQ\" curve is an underestimate of the true maximum.", "reference": "1605.07496v3-Figure9-1.png"}, {"question": "Which method performs the best on the Branin function?", "answer": "One Step ALOQ", "explanation": "The One Step ALOQ method has the lowest expected function value for the Branin function, which is indicated by the red line in Figure (a).", "reference": "1605.07496v3-Figure7-1.png"}]}, "1612.02803v5": {"paper_id": "1612.02803v5", "all_figures": {"1612.02803v5-Table1-1.png": {"caption": "Our contribution compared with Su et al. (2014); Wibisono et al. (2016).", "content_type": "table", "figure_type": "table."}, "1612.02803v5-Figure1-1.png": {"caption": "An illustration of the harmonic oscillators: A massive particle connects to a massless spring. (Top) Undamped harmonic oscillator; (Bottom) Damped harmonic oscillator.", "content_type": "figure", "figure_type": "other"}, "1612.02803v5-Figure2-1.png": {"caption": "The algorithmic iterates and trajectories of a simple quadratic program.", "content_type": "figure", "figure_type": "other"}}, "qa": [{"question": "What is the equation that describes the motion of a mass attached to a spring?", "answer": "The equation that describes the motion of a mass attached to a spring is:\n```\nm d^2 X / dt^2 + kX = 0\n```\nwhere:\n* m is the mass of the object\n* X is the displacement of the object from its equilibrium position\n* k is the spring constant\n* t is time", "explanation": "This equation is derived from Newton's second law, which states that the force on an object is equal to its mass times its acceleration. In this case, the force on the object is the force exerted by the spring, which is proportional to the displacement of the object from its equilibrium position.", "reference": "1612.02803v5-Figure1-1.png"}]}, "1606.07384v2": {"paper_id": "1606.07384v2", "all_figures": {"1606.07384v2-Figure1-1.png": {"caption": "Experiments with synthetic data: error is reported against the size of the conditional probability table (lower is better). The error is the estimated total variation distance to the ground truth Bayes net. We use the error of MLE without noise as our benchmark. We plot the performance of our algorithm (Filtering), empirical mean with noise (MLE), and RANSAC. We report two settings: the underlying structure of the Bayes net is a random tree (left) or a random graph (right).", "content_type": "figure", "figure_type": "plot"}, "1606.07384v2-Figure2-1.png": {"caption": "Experiments with semi-synthetic data: error is reported against the fraction of corrupted samples (lower is better). The error is the estimated total variation distance to the ALARM network. We use the sampling error without noise as a benchmark, and compare the performance of our algorithm (Filtering), empirical mean with noise (MLE), and RANSAC.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "How does the performance of the Filtering algorithm compare to the performance of MLE with noise?", "answer": "The Filtering algorithm performs better than MLE with noise in both the random tree and random graph settings.", "explanation": "The figure shows that the error of the Filtering algorithm is lower than the error of MLE with noise for all values of the number of parameters. This is true for both the random tree and random graph settings.", "reference": "1606.07384v2-Figure1-1.png"}, {"question": "Which method performs the best when there is a high fraction of corrupted samples?", "answer": "RANSAC", "explanation": "The plot shows that RANSAC has the lowest error when the fraction of corrupted samples is high.", "reference": "1606.07384v2-Figure2-1.png"}]}, "1803.01128v3": {"paper_id": "1803.01128v3", "all_figures": {"1803.01128v3-Table4-1.png": {"caption": "Table 4: Results of targeted keywords attack in text summarization. |K| is the number of keywords. We found that our method can make the summarization include 1 or 2 target keywords with a high success rate, while the changes made to the input sentences are relatively small, as indicated by the high BLEU scores and low average number of changed words. When |K| = 3, this task becomes more challenging, but our algorithm can still find many adversarial examples.", "content_type": "table", "figure_type": "N/A"}, "1803.01128v3-Table5-1.png": {"caption": "Results of non-overlapping method and targeted keywords method in machine translation.", "content_type": "table", "figure_type": "table"}, "1803.01128v3-Table6-1.png": {"caption": "Table 6: Perplexity score for adversarial example", "content_type": "table", "figure_type": "N/A"}, "1803.01128v3-Table7-1.png": {"caption": "Machine translation adversarial examples. Upper 4 lines: non-overlap; Bottom 4 lines: targeted keyword \u201dHund sitzt\u201d", "content_type": "table", "figure_type": "table"}, "1803.01128v3-Table8-1.png": {"caption": "Table 8: Text summarization adversarial examples using non-overlapping method. Surprisingly, it is possible to make the output sequence completely different by changing only one word in the input sequence.", "content_type": "table", "figure_type": "N/A"}, "1803.01128v3-Table9-1.png": {"caption": "Table 9: Text summarization examples with targeted keywords \u201cpolice arrest \u201d", "content_type": "table", "figure_type": "N/A"}, "1803.01128v3-Table1-1.png": {"caption": "Table 1: Summary of existing works that are designed to attack RNN models. \u201cBINARY\u201d indicates the attack is for binary classifications, and there is no difference between untargeted and targeted attack in this case. \u201cCLASS\u201d means targeted attack to a specific class. \u201cKEYWORD\u201d means targeted attack to a specific keyword. Here we omit follow-up works based on Seq2Sick.", "content_type": "table", "figure_type": "N/A"}, "1803.01128v3-Table2-1.png": {"caption": "Table 2: Statistics of the datasets. \u201c# Samples\u201d is the number of test examples we used for robustness evaluations", "content_type": "table", "figure_type": "N/A"}, "1803.01128v3-Table3-1.png": {"caption": "Table 3: Results of non-overlapping attack in text summarization. # changed is how many words are changed in the input sentence. The high BLEU scores and low average number of changed words indicate that the crafted adversarial inputs are very similar to their originals, and we achieve high success rates to generate a summarization that differs with the original at every position for all three datasets.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "What are the key differences between Seq2Sick and existing attack methods on RNN-based models?", "answer": "Seq2Sick differs from existing attack methods in two key aspects:\n\n1. Search Strategy: While previous methods primarily rely on greedy search, which becomes increasingly inefficient for longer sequences, Seq2Sick employs group lasso regularization and projected gradient descent with gradient regularization. This allows for simultaneous searching of all replacement positions, leading to improved efficiency.\n\n2. Targeted Attack Type: Existing methods focus on targeting specific classes or binary classifications, while Seq2Sick introduces a novel \"keyword\" target type, allowing attacks to be directed towards specific keywords within the generated sequence.", "explanation": "Table 1 provides a comparative overview of different attack methods, highlighting their characteristics in terms of gradient-based approach, word-level RNN usage, sequential output, and targeted attack type. By analyzing this information in conjunction with the passage's emphasis on Seq2Sick's unique search strategy and keyword targeting capability, we can identify the key differences between this method and existing approaches.", "reference": "1803.01128v3-Table1-1.png"}, {"question": "What is the relationship between the success rate of the non-overlapping attack and the number of words changed in the input sentence?", "answer": "There is a negative correlation between the success rate of the non-overlapping attack and the number of words changed in the input sentence. In other words, the fewer words that are changed, the higher the success rate of the attack.", "explanation": "This can be observed by comparing the \"Success%\" and \"# changed\" columns in the table. For example, the Gigaword dataset has the highest success rate (86.0%) and the lowest average number of changed words (2.17). Conversely, the DUC2004 dataset has the lowest success rate (84.2%) and a higher average number of changed words (2.50). This suggests that the attack is more effective when it can achieve its goal (generating a completely different summarization) with minimal changes to the original sentence.", "reference": "1803.01128v3-Table3-1.png"}, {"question": "How does the difficulty of performing a successful targeted keywords attack change as the number of targeted keywords increases?", "answer": "The difficulty of performing a successful targeted keywords attack increases as the number of targeted keywords increases.", "explanation": "The table shows that the success rate of the attack drops significantly when the number of targeted keywords ($|K|$) goes from 2 to 3, for all datasets. When $|K|=1$ or $|K|=2$, the success rate is very high (above 87%). However, when $|K|=3$, the success rate falls to around 40%. This indicates that it is much harder to manipulate the summarization process to include three specific keywords compared to one or two.", "reference": "1803.01128v3-Table4-1.png"}, {"question": "Which method resulted in the highest BLEU score?", "answer": "The 1-keyword method resulted in the highest BLEU score of 0.705.", "explanation": "The table shows the BLEU score for each method. The 1-keyword method has the highest BLEU score.", "reference": "1803.01128v3-Table5-1.png"}, {"question": "Do adversarial examples generated with the 2-keyword constraint maintain a similar syntactic structure to the original sentences?", "answer": "No, adversarial examples generated with the 2-keyword constraint deviate significantly from the original syntactic structure.", "explanation": "The table shows the perplexity scores of different types of adversarial examples. Perplexity measures how well a language model predicts a given text, with lower perplexity indicating better prediction and thus a more natural and expected syntactic structure. While the original sentences and those with non-overlap or 1-keyword constraints have relatively low perplexity scores, the 2-keyword examples show a dramatic increase in perplexity. This suggests that these examples deviate significantly from the original syntactic structure and are less predictable by the language model.", "reference": "1803.01128v3-Table6-1.png"}]}, "1703.00899v2": {"paper_id": "1703.00899v2", "all_figures": {"1703.00899v2-Figure1-1.png": {"caption": "Picturing the continual observation technique for preserving privacy [7, 10]. Each dqt is a trade. The true market state at t is qt = \u2211t j=1 dq j and the goal is to release a noisy version q\u0302t Each arrow originates at t, points backwards to s(t), and is labeled with independent Laplace noise vector zt. Now q\u0302t = qt + zt + zs(t) + zs(s(t)) + \u00b7 \u00b7 \u00b7 . In other words, the noise added at t is a sum of noises obtained by following the arrows all the way back to 0. There are two key properties: Each t has only log T arrows passing above it, and each path backwards takes only log T jumps.", "content_type": "figure", "figure_type": "Schematic"}}, "qa": [{"question": "What is the relationship between the true market state qt and the noisy version q\u0302t at time t?", "answer": "The noisy version q\u0302t at time t is equal to the true market state qt plus a sum of Laplace noise vectors obtained by following the arrows all the way back to 0.", "explanation": "The figure shows a directed graph where each node represents a trade (dqt) at a given time t. The arrows in the graph represent the relationship between the true market state and the noisy version. Each arrow originates at t, points backwards to s(t), and is labeled with an independent Laplace noise vector zt. The noisy version q\u0302t at time t is then calculated by adding the true market state qt to the sum of all the noise vectors encountered by following the arrows backwards to 0.", "reference": "1703.00899v2-Figure1-1.png"}]}, "1703.02507v3": {"paper_id": "1703.02507v3", "all_figures": {"1703.02507v3-Table1-1.png": {"caption": "Comparison of the performance of different models on different supervised evaluation tasks. An underline indicates the best performance for the dataset. Top 3 performances in each data category are shown in bold. The average is calculated as the average of accuracy for each category (For MSRP, we take the accuracy). )", "content_type": "table", "figure_type": "table"}, "1703.02507v3-Table2-1.png": {"caption": "Unsupervised Evaluation Tasks: Comparison of the performance of different models on Spearman/Pearson correlation measures. An underline indicates the best performance for the dataset. Top 3 performances in each data category are shown in bold. The average is calculated as the average of entries for each correlation measure.", "content_type": "table", "figure_type": "table"}, "1703.02507v3-Figure1-1.png": {"caption": "Figure 1: Left figure: the profile of the word vector L2norms as a function of log(fw) for each vocabulary word w, as learnt by our unigram model trained on Toronto books. Right figure: down-weighting scheme proposed by Arora et al. (2017): weight(w) = a a+fw .", "content_type": "figure", "figure_type": "plot"}, "1703.02507v3-Table4-1.png": {"caption": "Comparison of the performance of the unsupervised and semi-supervised sentence embeddings by (Arora et al., 2017) with our models. Unsupervised comparisons are in terms of Pearson\u2019s correlation, while comparisons on supervised tasks are stating the average described in Table 1.", "content_type": "table", "figure_type": "table"}, "1703.02507v3-Table3-1.png": {"caption": "Best unsupervised and semi-supervised methods ranked by macro average along with their training times. ** indicates trained on GPU. * indicates trained on a single node using 30 threads. Training times for non-Sent2Vec models are due to Hill et al. (2016a). For CPU based competing methods, we were able to reproduce all published timings (+-10%) using our same hardware as for training Sent2Vec.", "content_type": "table", "figure_type": "table"}, "1703.02507v3-Table7-1.png": {"caption": "Unsupervised Evaluation: Comparison of the performance of different Sent2Vec models with semi-supervised/supervised models on Spearman/Pearson correlation measures. An underline indicates the best performance for the dataset and Sent2Vec model performances are bold if they perform as well or better than all other non-Sent2Vec models, including those presented in Table 2.", "content_type": "table", "figure_type": "table"}, "1703.02507v3-Table8-1.png": {"caption": "Average sentence lengths for the datasets used in the comparison.", "content_type": "table", "figure_type": "table."}, "1703.02507v3-Table6-1.png": {"caption": "Comparison of the performance of different Sent2Vec models with different semisupervised/supervised models on different downstream supervised evaluation tasks. An underline indicates the best performance for the dataset and Sent2Vec model performances are bold if they perform as well or better than all other non-Sent2Vec models, including those presented in Table 1.", "content_type": "table", "figure_type": "table"}, "1703.02507v3-Table5-1.png": {"caption": "Training parameters for the Sent2Vec models", "content_type": "table", "figure_type": "** Table"}}, "qa": [{"question": "Which model performed the best on the MSRP task for the Ordered Sentences dataset?", "answer": "SkipThought", "explanation": "The table shows the performance of different models on different supervised evaluation tasks. For the Ordered Sentences dataset, the model with the highest accuracy for the MSRP task is SkipThought, with an accuracy of 83.0.", "reference": "1703.02507v3-Table1-1.png"}, {"question": "Which model performs best on the SICK 2014 dataset in terms of average Spearman and Pearson correlation?", "answer": "C-PHRASE", "explanation": "The table shows the performance of different models on the SICK 2014 dataset in terms of Spearman and Pearson correlation. The C-PHRASE model has the highest average score of 63.67.", "reference": "1703.02507v3-Table2-1.png"}, {"question": "What is the relationship between the $L_2$-norm of a word vector and its frequency?", "answer": "The $L_2$-norm of a word vector is inversely proportional to its frequency.", "explanation": "The left figure in Figure 1 shows that the $L_2$-norm of a word vector decreases as the frequency of the word increases. This is consistent with Luhn's hypothesis, which states that mid-rank terms are the most significant to discriminate content.", "reference": "1703.02507v3-Figure1-1.png"}, {"question": "Which dataset has the shortest average sentence length?", "answer": "Headlines.", "explanation": "The table shows the average sentence lengths for the different datasets. The Headlines dataset has the lowest average sentence length of 7.82.", "reference": "1703.02507v3-Table8-1.png"}, {"question": "Which model performed the best on the MSRP task for the Twitter dataset?", "answer": "The Sent2Vec uni. + bi. model performed the best on the MSRP task for the Twitter dataset.", "explanation": "The table shows the performance of different models on different downstream supervised evaluation tasks. The MSRP task is one of these tasks, and the Twitter dataset is one of the datasets used. The Sent2Vec uni. + bi. model achieved the highest score (72.4 / 80.6) on the MSRP task for the Twitter dataset.", "reference": "1703.02507v3-Table6-1.png"}]}, "1802.07351v2": {"paper_id": "1802.07351v2", "all_figures": {"1802.07351v2-Table4-1.png": {"caption": "Table 4. Results on KITTI. (ft) denotes the fine-tuning. EPE denotes end-point error. Fl-all denotes the ratio of pixels where the flow estimate is incorrect by both \u2265 3 pixels and \u2265 5%.", "content_type": "table", "figure_type": "N/A"}, "1802.07351v2-Table3-1.png": {"caption": "Table 3. Detailed results on Sintel (end-point error) for different distances from motion boundaries (d) and velocities (s).", "content_type": "table", "figure_type": "N/A"}, "1802.07351v2-Table2-1.png": {"caption": "Table 2. Results on Sintel (end-point error). (ft) denotes the finetuning.", "content_type": "table", "figure_type": "N/A"}, "1802.07351v2-Figure1-1.png": {"caption": "Artifacts of using image warping. From (d), we can see the duplicates of the dragon head and wings. The images and the ground truth optical flow are from the Sintel dataset [5]. Warping is done with function image.warp() in the Torch-image toolbox.", "content_type": "figure", "figure_type": ""}, "1802.07351v2-Figure8-1.png": {"caption": "FlyingChairs (validation set). Green arrows indicate the small object that moves fast.", "content_type": "figure", "figure_type": "photograph(s)"}, "1802.07351v2-Figure9-1.png": {"caption": "Sintel (training set). Green arrows indicate the small object that moves fast.", "content_type": "figure", "figure_type": "photograph(s)"}, "1802.07351v2-Figure10-1.png": {"caption": "KITTI 2015 (training set). Green arrows indicate the small object that moves fast.", "content_type": "figure", "figure_type": "photograph(s)"}, "1802.07351v2-Figure2-1.png": {"caption": "Cost Volumes", "content_type": "figure", "figure_type": "schematic"}, "1802.07351v2-Table5-1.png": {"caption": "Table 5. Results of ablation experiments after training on FlyingChairs (end-point error).", "content_type": "table", "figure_type": "N/A"}, "1802.07351v2-Table6-1.png": {"caption": "Table 6. Runtime (ms).", "content_type": "table", "figure_type": "N/A"}, "1802.07351v2-Figure4-1.png": {"caption": "Encoding module f . The residual connection denotes the output of a layer is added to the output of another layer.", "content_type": "figure", "figure_type": "schematic"}, "1802.07351v2-Figure3-1.png": {"caption": "Deformable Volume Network (Devon) with three stages. I denotes the first image, J denotes the second image, f denotes the encoding module (\u00a74.1), Rt denotes the relation module (\u00a74.2), gt denotes the decoding module (\u00a74.3) and Ft denotes the estimated optical flow for stage t.", "content_type": "figure", "figure_type": "** schematic"}, "1802.07351v2-Figure5-1.png": {"caption": "Relation module R. C1 \u223c C5 denote the deformable cost volumes. k1 \u223c k5 denote the neighborhood sizes. r1 \u223c r5 denote the dilation rates. Concat denotes concatenation. Norm denotes normalization.", "content_type": "figure", "figure_type": "schematic"}, "1802.07351v2-Figure6-1.png": {"caption": "Concatenation of deformable cost volumes creates a retinal structure of correspondences. In this example, three cost volumes of neighborhood sizes (k1, k2, k3) = (3, 5, 3) and dilation rates (r1, r2, r3) = (1, 2, 7) respectively are concatenated.", "content_type": "figure", "figure_type": "schematic"}, "1802.07351v2-Table1-1.png": {"caption": "Table 1. Hyperparameters of deformable cost volumes in Devon.", "content_type": "table", "figure_type": "N/A"}, "1802.07351v2-Figure7-1.png": {"caption": "Decoding module g. The residual connection denotes the output of a layer is added to the output of another layer.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "What is the purpose of the residual connection in the decoding module?", "answer": "The residual connection allows the output of a layer to be added to the output of another layer, which helps to improve the flow of information through the network.", "explanation": "The figure shows a schematic of the decoding module, and the residual connection is labeled as such.", "reference": "1802.07351v2-Figure7-1.png"}, {"question": "What are the differences between the results of the three methods, LiteFlowNet, PWC-Net, and Devon, compared to the ground truth?", "answer": "LiteFlowNet, PWC-Net, and Devon all produce results that are similar to the ground truth, but there are some subtle differences. For example, LiteFlowNet tends to overestimate the motion of the small object, while PWC-Net and Devon tend to underestimate it. Additionally, all three methods produce some artifacts around the edges of the moving object.", "explanation": "The figure shows the results of three different methods for estimating optical flow, compared to the ground truth. The ground truth is the actual motion of the objects in the scene, and the other methods are trying to estimate this motion. The figure shows that all three methods are able to estimate the motion of the objects fairly accurately, but there are some differences between the results.", "reference": "1802.07351v2-Figure9-1.png"}, {"question": "What is the difference between a standard cost volume and a deformable cost volume?", "answer": "A standard cost volume computes the matching costs for a neighborhood of the same location on the feature maps of the first and second images. A deformable cost volume computes the matching costs for a dilated neighborhood of the same location on the feature maps of the first and second images, offset by a flow vector.", "explanation": "The figure shows the difference between a standard cost volume and a deformable cost volume. In the standard cost volume, the matching costs are computed for a fixed neighborhood around each location. In the deformable cost volume, the matching costs are computed for a neighborhood that is offset by a flow vector, which allows for more flexibility in matching features.", "reference": "1802.07351v2-Figure2-1.png"}, {"question": "Based on the ablation study, which modification to the Devon model architecture had the most significant negative impact on performance for the KITTI 2015 dataset?", "answer": "Removing the normalization in the relation modules had the most significant negative impact on performance for the KITTI 2015 dataset.", "explanation": "Table 1 shows the results of various modifications to the Devon model architecture on different datasets. For the KITTI 2015 dataset, the \"Without norm\" configuration resulted in the highest end-point error of 15.64, which is considerably higher than the baseline model's error of 13.25. This indicates that removing the normalization significantly reduces the model's accuracy on this particular dataset.", "reference": "1802.07351v2-Table5-1.png"}, {"question": "Which modification to the Devon model resulted in the fastest processing time for both forward and backward passes, and how much faster was it compared to the full model in terms of the backward pass? ", "answer": "The \"Without dilation\" configuration resulted in the fastest processing time for both forward and backward passes. It was approximately 29.43 ms faster than the full model in terms of the backward pass (147.74 ms vs. 177.17 ms).", "explanation": "Table 1 shows the runtime (in milliseconds) for different configurations of the Devon model. The \"Without dilation\" configuration has the lowest values in both the \"Forward\" and \"Backward\" columns, indicating the fastest processing time in both directions. The difference between the \"Without dilation\" and \"Full model\" values in the \"Backward\" column (177.17 - 147.74) gives us the improvement in processing time.", "reference": "1802.07351v2-Table6-1.png"}, {"question": "What is the purpose of the residual connection in the encoding module?", "answer": "The residual connection adds the output of a layer to the output of another layer, which helps to prevent the vanishing gradient problem.", "explanation": "The figure shows that the residual connection connects the output of the Conv 512 \u00d7 3 \u00d7 3, stride 2 layer to the output of the Conv 512 \u00d7 3 \u00d7 3, stride 1 layer. This allows the gradient to flow more easily through the network, which can help to improve training performance.", "reference": "1802.07351v2-Figure4-1.png"}, {"question": "What is the role of the relation module (Rt) in the Deformable Volume Network (Devon)?", "answer": "The relation module (Rt) is responsible for capturing the spatial relationships between the features extracted from the first and second images.", "explanation": "The figure shows that the relation module (Rt) takes as input the features extracted from the encoding module (f) for both the first and second images. The output of the relation module is then fed into the decoding module (gt). This suggests that the relation module is used to compute some kind of similarity or correspondence between the features of the two images.", "reference": "1802.07351v2-Figure3-1.png"}, {"question": "Explain the rationale behind using five deformable cost volumes with different hyperparameter settings in Devon's relation module.", "answer": "The five deformable cost volumes in Devon's relation module are designed to capture multi-scale motion by combining dense correspondences near the image center with sparser correspondences in the periphery. This is achieved by using different neighborhood sizes (k) and dilation rates (r) for each cost volume, as shown in Table 1. Smaller neighborhood sizes and dilation rates result in denser correspondences, focusing on finer details and small displacements, while larger values capture broader context and larger motions.", "explanation": "Table 1 shows that the first four cost volumes share the same neighborhood size (k=5) but have increasing dilation rates (r = 1, 3, 8, 12). This suggests a focus on increasingly larger displacements while maintaining a relatively dense sampling. The fifth cost volume, however, uses a larger neighborhood size (k=9) and the largest dilation rate (r=20), indicating a focus on capturing sparse correspondences and large motions in the image periphery. This multi-scale approach aligns with the observation that small displacements are more frequent in natural videos and mimics the structure of the retina, which has higher resolution near the center and lower resolution in the periphery.", "reference": "1802.07351v2-Table1-1.png"}, {"question": "Based on the table, which model achieved the best performance on the KITTI 2015 test set in terms of F1-all score, and how does its performance compare to Devon (ft) on the same dataset?", "answer": "PWC-Net (ft) achieved the best performance on the KITTI 2015 test set with an F1-all score of 9.16%. This is significantly better than Devon (ft), which achieved an F1-all score of 14.31% on the same dataset. ", "explanation": "The table shows the performance of different models on the KITTI 2015 dataset, including both training and testing sets. The F1-all score is listed for each model on the test set. By comparing the F1-all scores, we can see that PWC-Net (ft) has the lowest score, indicating the best performance. Additionally, we can directly compare the F1-all scores of PWC-Net (ft) and Devon (ft) to see that PWC-Net (ft) performs significantly better.", "reference": "1802.07351v2-Table4-1.png"}, {"question": "Based on the table, which method performs best on the Sintel \"Final\" test set, and how does its performance compare to Devon (ft) on the same set? ", "answer": "PWC-Net (ft) performs best on the Sintel \"Final\" test set with an error of 5.04. Devon (ft) has a higher error of 6.35 on the same set. ", "explanation": "The table shows the end-point error for various methods on both the \"Clean\" and \"Final\" versions of the Sintel test set. The lowest error value indicates the best performance. Comparing the values in the \"Final\" column, we can see PWC-Net (ft) has the lowest error (5.04), while Devon (ft) has a higher error of 6.35.", "reference": "1802.07351v2-Table2-1.png"}, {"question": "Which of the three methods, LiteFlowNet, PWC-Net, or Devon, most accurately predicts the motion of the small object in the scene?", "answer": "Devon.", "explanation": "The ground truth image shows the actual motion of the small object, which is indicated by the green arrows. Devon's prediction is closest to the ground truth, as it correctly predicts the direction and magnitude of the object's motion. LiteFlowNet and PWC-Net, on the other hand, underestimate the object's motion.", "reference": "1802.07351v2-Figure8-1.png"}]}, "1702.03584v3": {"paper_id": "1702.03584v3", "all_figures": {"1702.03584v3-Table1-1.png": {"caption": "The overall clustering performance of all the proposed and baseline methods. The notation < denotes the number (percentage in parenthesis) of datasets over which the baseline methods perform worse than our method SPIRAL-MSM-kMeans.", "content_type": "table", "figure_type": "table"}, "1702.03584v3-Figure1-1.png": {"caption": "Figure 1: Two error rates as a function of CPU time on UCR Non-Invasive Fetal ECG Thorax1 dataset", "content_type": "figure", "figure_type": "plot"}, "1702.03584v3-Figure2-1.png": {"caption": "Comparison of our method with existing clustering algorithms over all the 85 UCR time series datasets. Top two: comparison between our method SPIRAL-DTW-kMeans with two state-of-the-art methods k-Shape, and CLDS. Bottom two: comparisons between MSM based methods, our method SPIRAL-MSM-kMeans with Laplace-MSM-kMeans and kMedoids-MSM. Circles below the diagonal indicate datasets over which our method yields better clustering performance in terms of NMI.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "How does the observed error compare to the underlying true error as CPU time increases?", "answer": "The observed error is initially higher than the underlying true error, but it quickly decreases and converges to the true error as CPU time increases.", "explanation": "The figure shows two lines, one representing the observed error and the other representing the underlying true error. Both lines decrease as CPU time increases, but the observed error line decreases more quickly and eventually converges to the true error line.", "reference": "1702.03584v3-Figure1-1.png"}, {"question": "How does the performance of SPIRAL-DTW-kMeans compare to k-Shape and CLDS?", "answer": "SPIRAL-DTW-kMeans performs better than k-Shape and CLDS on most datasets.", "explanation": "In Figure (a) and (b), the circles below the diagonal line indicate datasets where SPIRAL-DTW-kMeans yields better clustering performance in terms of NMI than k-Shape and CLDS, respectively.", "reference": "1702.03584v3-Figure2-1.png"}, {"question": "Which method performs the best in terms of NMI and what percentage of datasets does it outperform the other methods on?", "answer": "The SPIRAL-MSM-kMeans method performs the best in terms of NMI with a score of 0.365. It outperforms the other methods on 89.4% of the datasets.", "explanation": "The table shows the NMI scores and the percentage of datasets on which each method outperforms the other methods. The SPIRAL-MSM-kMeans method has the highest NMI score and the highest percentage of datasets on which it outperforms the other methods.", "reference": "1702.03584v3-Table1-1.png"}]}, "1802.07459v2": {"paper_id": "1802.07459v2", "all_figures": {"1802.07459v2-Table1-1.png": {"caption": "Table 1: Description of evaluation datasets.", "content_type": "table", "figure_type": "N/A"}, "1802.07459v2-Figure1-1.png": {"caption": "An example to show a piece of text and its Concept Interaction Graph representation.", "content_type": "figure", "figure_type": "schematic"}, "1802.07459v2-Table2-1.png": {"caption": "Table 2: Accuracy and F1-score results of different algorithms on CNSE and CNSS datasets.", "content_type": "table", "figure_type": "N/A"}, "1802.07459v2-Figure2-1.png": {"caption": "An overview of our approach for constructing the Concept Interaction Graph (CIG) from a pair of documents and classifying it by Graph Convolutional Networks.", "content_type": "figure", "figure_type": "schematic"}, "1802.07459v2-Figure3-1.png": {"caption": "The events contained in the story \u201c2016 U.S. presidential election\u201d.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": " How many negative samples are there in the training set of the CNSE dataset?", "answer": "There are approximately 9,719 negative samples in the training set of the CNSE dataset.", "explanation": "Table 1 shows that the CNSE dataset has a total of 16,198 negative samples. The passage states that 60% of all samples are used for training. Therefore, to find the number of negative samples in the training set, we can calculate: \n\n0.6 * 16,198 = 9,718.8 \n\nSince we cannot have fractions of samples, we round this number to the nearest whole number, which is 9,719.", "reference": "1802.07459v2-Table1-1.png"}, {"question": "Which model variant achieves the best performance on the CNSS dataset in terms of F1-score, and what are its key components?", "answer": "Model XVIII, CIG-Sim&Siam-GCN-Sim$^{g}$, achieves the best performance on the CNSS dataset with an F1-score of 90.29%. This model utilizes the following key components:\n\n1. CIG: It directly uses keywords as concepts without community detection.\n2. Sim & Siam: It employs both term-based similarity encoder (\"Sim\") and Siamese encoder (\"Siam\") for generating matching vectors on vertices.\n3. GCN: It performs convolution on local matching vectors through GCN layers.\n4. Sim$^{g}$: It incorporates additional global features based on the five term-based similarity metrics.", "explanation": "Table 1 presents the performance of various models on both CNSE and CNSS datasets, with columns specifically indicating Accuracy and F1-score for each dataset. By looking at the F1-score column for CNSS, we can identify model XVIII as having the highest score. \n\nThe passage then helps us understand the specific components of this model by explaining the abbreviations used in the model names. We can see that model XVIII combines various techniques, including both \"Sim\" and \"Siam\" encoders, GCN for local information aggregation, and global features from term-based similarity metrics (\"Sim$^{g}$\").", "reference": "1802.07459v2-Table2-1.png"}, {"question": "What are the different stages involved in constructing the Concept Interaction Graph (CIG) from a pair of documents?", "answer": "The different stages involved in constructing the Concept Interaction Graph (CIG) from a pair of documents are: (a) Representation, (b) Encoding, (c) Transformation, and (d) Aggregation.", "explanation": "The figure shows the different stages involved in constructing the CIG. The first stage, Representation, involves constructing a KeyGraph from the document pair by word co-occurrence and detecting concepts by community detection. The second stage, Encoding, involves getting edge weights by vertex similarities and assigning sentences by similarities. The third stage, Transformation, involves using a Siamese encoder to generate vertex features and a term-based feature extractor to generate vertex features. The fourth stage, Aggregation, involves performing Siamese-based matching, term-based matching, and global matching to generate the final CIG.", "reference": "1802.07459v2-Figure2-1.png"}]}, "1702.08694v3": {"paper_id": "1702.08694v3", "all_figures": {"1702.08694v3-Figure1-1.png": {"caption": "Figure 1: Although there is a clear correlation between Features 1 and 2 in the left panel and none in the right panel, after median-based binarization of Feature 1 and Feature 2, the estimated probability of the occurrence of the feature combination (the number of points for which Feature 1 = Feature 2 = 1, or the number of points in the red box) will be exactly the same in both examples. Hence if the left case is a significant interaction, the right uncorrelated case also becomes a significant interaction in binarization-based methods.", "content_type": "figure", "figure_type": "plot"}, "1702.08694v3-Figure2-1.png": {"caption": "Figure 2: Results on synthetic data with the minor class ratio r1 = 0.5. Regarding the scale of precision and F-measure, see comment at the last paragraph just before Section 3. The number of features is d = 20 in the left column and the sample size is N = 1,000 in the right column. Both xand y-axes are in logarithmic scale. C-Tarone is shown in red circles, the binarization approach in blue triangles.", "content_type": "figure", "figure_type": "plot"}, "1702.08694v3-Table1-1.png": {"caption": "Contingency tables.", "content_type": "table", "figure_type": "table"}, "1702.08694v3-Figure5-1.png": {"caption": "Figure 5: Results on synthetic data with the minor class ratio r1 = 0.2. The number of features is d = 20 in the left column and the sample size is N = 3,000 in the right column. Both x- and y-axes are in logarithmic scale. C-Tarone is shown in red circles, the binarization approach in blue triangles. Missing points in (b) mean that no significant combination is detected.", "content_type": "figure", "figure_type": "plot"}, "1702.08694v3-Figure3-1.png": {"caption": "Figure 3: Results on real data. Regarding the scale of precision and F-measure, see the comment at the last paragraph just before Section 3. The y-axis is in logarithmic scale. C-Tarone is shown in red and the binarization approach is shown in blue. Higher (taller) is better in precision, recall, and F-measure, while lower is better in running time.", "content_type": "figure", "figure_type": "plot"}, "1702.08694v3-Figure4-1.png": {"caption": "Figure 4: The upper bound B(a, b) of the KL divergence (left) and the corresponding p-value (right) with N = 100 with respect to changes in a when b = 0.3.", "content_type": "figure", "figure_type": "plot"}, "1702.08694v3-Table2-1.png": {"caption": "Table 2: Statistics of real data.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "Which method, C-Tarone or Binarization, achieves higher precision when the number of features is small and the number of data points is large?", "answer": "C-Tarone.", "explanation": "The top left panel of Figure 2 shows that when the number of features is small (around 1e+03) and the number of data points is large (around 1e+05), the red circles (C-Tarone) are higher than the blue triangles (Binarization).", "reference": "1702.08694v3-Figure5-1.png"}, {"question": "How does the C-Tarone method compare to the binarization method in terms of precision, recall, F-measure, and running time?", "answer": "The C-Tarone method has higher precision and F-measure than the binarization method in all datasets. The C-Tarone method has better or competitive recall than the binarization method. The running time of the C-Tarone method is competitive with the binarization method.", "explanation": "The figure shows the precision, recall, F-measure, and running time of the C-Tarone method and the binarization method for different datasets. The bars for the C-Tarone method are higher than the bars for the binarization method for precision and F-measure, which means that the C-Tarone method performs better than the binarization method in terms of precision and F-measure. The bars for the C-Tarone method are similar to the bars for the binarization method for recall, which means that the C-Tarone method performs similarly to the binarization method in terms of recall. The bars for the C-Tarone method are similar to the bars for the binarization method for running time, which means that the C-Tarone method performs similarly to the binarization method in terms of running time.", "reference": "1702.08694v3-Figure3-1.png"}, {"question": "For a fixed value of $b$, how does the maximum achievable KL divergence and the corresponding minimum achievable p-value change with increasing values of $a$?", "answer": "The maximum achievable KL divergence initially increases with increasing values of $a$ until it reaches a peak. Then, it decreases with increasing values of $a$. The minimum achievable p-value initially decreases with increasing values of $a$ until it reaches a minimum. Then, it increases with increasing values of $a$.", "explanation": "The left panel of the figure shows the maximum achievable KL divergence as a function of $a$ for a fixed value of $b$. The right panel shows the corresponding minimum achievable p-value. The KL divergence initially increases and then decreases with increasing values of $a$, while the p-value initially decreases and then increases. This behavior is consistent with the analysis in the passage, which shows that the KL divergence is monotonically increasing for $a < b$ and monotonically decreasing for $b < a < 1/2$.", "reference": "1702.08694v3-Figure4-1.png"}, {"question": "Which dataset would likely require the most computational resources for C-Tarone to analyze?", "answer": "The \"wdbc\" dataset would likely require the most computational resources for C-Tarone to analyze.", "explanation": "The table shows that the \"wdbc\" dataset has the largest number of candidate combinations (search space) at 1,073,741,824. This means that C-Tarone needs to explore over a billion possible combinations of features during its analysis, which is significantly higher than any other dataset listed. The passage also mentions that the search space grows exponentially with the number of features (d). Since \"wdbc\" has a relatively high number of features (30), this contributes to its massive search space and the need for greater computational resources.", "reference": "1702.08694v3-Table2-1.png"}]}, "1803.02750v3": {"paper_id": "1803.02750v3", "all_figures": {"1803.02750v3-Figure1-1.png": {"caption": "Experiment setup: 15 nodes in a partial mesh topology replicating an always-growing set. The left plot depicts the number of elements being sent throughout the experiment, while the right plot shows the CPU processing time ratio with respect to state-based. Not only does delta-based synchronization not improve state-based in terms of state transmission, it even incurs a substantial processing overhead.", "content_type": "figure", "figure_type": "plot"}, "1803.02750v3-TableI-1.png": {"caption": "TABLE I: Description of micro-benchmarks.", "content_type": "table", "figure_type": "table"}, "1803.02750v3-Figure6-1.png": {"caption": "Network topologies employed: a 15-node partial-mesh (to the left) and a 15-node tree (to the right).", "content_type": "figure", "figure_type": "schematic"}, "1803.02750v3-Figure7-1.png": {"caption": "Transmission of GSet and GCounter with respect to delta-based BP+RR \u2013 tree and mesh topologies.", "content_type": "figure", "figure_type": "plot."}, "1803.02750v3-Figure13-1.png": {"caption": "Hasse diagram of P({a, b}) P({a, b}), a nondistributive lattice.", "content_type": "figure", "figure_type": "schematic"}, "1803.02750v3-Figure2-1.png": {"caption": "Specifications of two data types, replica i \u2208 I.", "content_type": "figure", "figure_type": "schematic"}, "1803.02750v3-Figure3-1.png": {"caption": "Hasse diagram of two data types.", "content_type": "figure", "figure_type": "schematic"}, "1803.02750v3-Figure8-1.png": {"caption": "Transmission of GMap 10%, 30%, 60% and 100% \u2013 tree and mesh topologies.", "content_type": "figure", "figure_type": "plot"}, "1803.02750v3-Figure4-1.png": {"caption": "Delta-based synchronization of a GSet with 2 replicas A,B \u2208 I. Underlined elements represent the BP optimization.", "content_type": "figure", "figure_type": "** Schematic."}, "1803.02750v3-Figure5-1.png": {"caption": "Delta-based synchronization of a GSet with 4 replicas A,B,C,D \u2208 I. The overlined element represents the RR optimization.", "content_type": "figure", "figure_type": "schematic"}, "1803.02750v3-Figure9-1.png": {"caption": "Metadata required per node when synchronizing a GSet in a mesh topology. Each node has 4 neighbours (as in Figure 6) and each node identifier has size 20B.", "content_type": "figure", "figure_type": "plot"}, "1803.02750v3-Figure10-1.png": {"caption": "Average memory ratio with respect to BP+RR for GCounter, GSet, GMap 10% and 100% \u2013 mesh topology", "content_type": "figure", "figure_type": "plot"}, "1803.02750v3-TableII-1.png": {"caption": "TABLE II: Retwis workload characterization: for each operation, the number of CRDT updates performed and its workload percentage.", "content_type": "table", "figure_type": "N/A"}, "1803.02750v3-TableIII-1.png": {"caption": "TABLE III: Composition techniques that yield lattices satisfying DCC and distributive lattices, given lattices A and B, chain C, partial order P and (unordered) set U .", "content_type": "table", "figure_type": "N/A"}, "1803.02750v3-TableIV-1.png": {"caption": "TABLE IV: Composition techniques that yield finite ideals or quotients, given lattices A and B, chain C, partial order P , all satisfying DCC, and (unordered) set U .", "content_type": "table", "figure_type": "N/A"}, "1803.02750v3-Figure12-1.png": {"caption": "CPU overhead of classic delta-based when compared to delta-based BP+RR.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which synchronization method is the most efficient in terms of CPU processing time?", "answer": "The proposed method compared to state-based and delta-based methods.", "explanation": "The right plot shows that this paper's method has the lowest CPU processing time ratio compared to the other two methods.", "reference": "1803.02750v3-Figure1-1.png"}, {"question": "What is the difference between GCounter and GSet?", "answer": "GCounter measures the number of times an event has occurred, while GSet measures the number of unique elements in a set.", "explanation": "The table shows that GCounter is incremented each time a periodic event occurs, while GSet is only incremented when a unique element is added. This means that GCounter can be used to count the total number of events, while GSet can be used to count the number of unique events.", "reference": "1803.02750v3-TableI-1.png"}, {"question": "Which of the algorithms is most efficient in terms of transmission in a tree topology?", "answer": "Op-based GSet.", "explanation": "The figure shows that Op-based GSet has the lowest transmission ratio compared to all other algorithms in a tree topology.", "reference": "1803.02750v3-Figure7-1.png"}, {"question": "What is the role of the RR optimization in the delta-based synchronization of a GSet?", "answer": "The RR optimization helps to reduce the number of messages that need to be exchanged between replicas.", "explanation": "The figure shows that the RR optimization allows replica C to send a single message to replica D, which contains the updates from both replicas A and B. This is because replica C knows that replica D has already received the updates from replica B. Without the RR optimization, replica C would have to send two messages, one to replica D and one to replica B.", "reference": "1803.02750v3-Figure5-1.png"}, {"question": "How does the average metadata required per node for the Op-based BP+RR approach change as the number of nodes in the network increases?", "answer": "The average metadata required per node for the Op-based BP+RR approach increases as the number of nodes in the network increases.", "explanation": "This can be seen in the figure, where the height of the yellow bar for the Op-based BP+RR approach increases from 0.2 MB for 16 nodes to 155.5 MB for 64 nodes.", "reference": "1803.02750v3-Figure9-1.png"}, {"question": "Which algorithm performs the best in terms of average memory ratio with respect to BP+RR for GMap 10%?", "answer": "Delta-based BP+RR", "explanation": "The figure shows that the bar for Delta-based BP+RR is the shortest for GMap 10%, indicating that it has the lowest average memory ratio with respect to BP+RR.", "reference": "1803.02750v3-Figure10-1.png"}, {"question": "What is the difference between the `inc_i(p)` and `inc_i'(p)` operations in the Grow-only Counter data type?", "answer": "The `inc_i(p)` operation increments the value associated with the key `i` in the counter `p`, while the `inc_i'(p)` operation increments the value associated with the key `i` in the counter `p` only if the key `i` is not already present in the counter.", "explanation": "The figure shows the specifications of the Grow-only Counter data type. The `inc_i(p)` operation is defined as `p[i \u21a6 p(i) + 1]`, which means that it increments the value associated with the key `i` in the counter `p`. The `inc_i'(p)` operation is defined as `[{i \u21a6 p(i) + 1}]`, which means that it increments the value associated with the key `i` in the counter `p` only if the key `i` is not already present in the counter.", "reference": "1803.02750v3-Figure2-1.png"}, {"question": "Which topology has the highest transmission rate for GMap 100%?", "answer": "Mesh", "explanation": "The figure shows that the transmission rate for GMap 100% is higher for the mesh topology than for the tree topology. This can be seen by comparing the curves for the two topologies in the top right panel of the figure.", "reference": "1803.02750v3-Figure8-1.png"}, {"question": "If a user with 100 followers posts a tweet, how many CRDT updates will be performed in total, and what percentage of the overall workload does this represent?", "answer": "Posting a tweet will result in 1 + 100 = 101 CRDT updates. This represents 35% of the overall workload.", "explanation": "The table shows that a \"Post Tweet\" operation requires 1 + #Followers updates. In this case, the user has 100 followers, so the total updates are 1 + 100. The table also tells us that \"Post Tweet\" operations make up 35% of the total workload.", "reference": "1803.02750v3-TableII-1.png"}, {"question": "If we use the lexicographic product with a chain as the first component and a distributive lattice as the second component to design a CRDT, will the resulting CRDT lattice be guaranteed to be distributive and satisfy the descending chain condition (DCC)?", "answer": "Yes, the resulting CRDT lattice will be guaranteed to be both distributive and satisfy the DCC.", "explanation": "Table 1 shows that when the first component of the lexicographic product is a chain and the second component is a distributive lattice, the resulting lattice is both distributive and satisfies the DCC. This is indicated by the checkmarks in the corresponding cells of the table. The passage further emphasizes this point by highlighting that this specific use of the lexicographic product is typical in designing CRDTs and that the resulting construct inherits distributivity from the second component.", "reference": "1803.02750v3-TableIII-1.png"}, {"question": "How does the CPU overhead of classic delta-based compare to delta-based BP+RR as the Zipf coefficient increases?", "answer": "The CPU overhead of classic delta-based is consistently higher than that of delta-based BP+RR as the Zipf coefficient increases.", "explanation": "The plot shows the CPU overhead of both classic delta-based and delta-based BP+RR for different Zipf coefficients. The green line represents classic delta-based, and the blue line represents delta-based BP+RR. As the Zipf coefficient increases, the CPU overhead of both algorithms increases, but the CPU overhead of classic delta-based increases at a faster rate.", "reference": "1803.02750v3-Figure12-1.png"}]}, "1701.06171v4": {"paper_id": "1701.06171v4", "all_figures": {"1701.06171v4-Figure4-1.png": {"caption": "Illustration of the proposed greedy EM-type learning process. The part models are composed of 5 Gabor filters which are represented as colored ellipses. (a) The first t = 22 iterations of the greedy learning scheme. Each row shows the evolution of a part model over time. Each column shows the learning result at one iteration of the learning process. When a new part is initialized (t = 1, 6, 11, . . . ), also a generic background model is learned from the training image (marked by dashed rectangles). The background model and the learned part models are not adapted in the subsequent iterations (gray background) but serve as competitors for data in the E-step. For more details refer to Section 4.1. (b) An example encoding of a training image with the learned part models.", "content_type": "figure", "figure_type": "schematic"}, "1701.06171v4-Figure1-1.png": {"caption": "Comparison of different types of hierarchical compositional models. (a) A sample of the training data; (b & c) Hierarchical compositional models with black strokes indicating edge features at the different location and orientation. (b) The approach as proposed by Dai et al. [5] learns an unnatural rather arbitrary decomposition of the object. (c) Our proposed greedy compositional clustering process learns a semantically meaningful hierarchical compositional model without the need of any a-priori knowledge about the object\u2019s geometry.", "content_type": "figure", "figure_type": "schematic"}, "1701.06171v4-Table1-1.png": {"caption": "Table 1: Unsupervised domain adaptation: Classification scores on the Four Domain Dataset. The four domains are Amazon (A), Webcam (W), Caltech256(C), DSLR (D). We compare our results to dictionary learning with K-SVD, subspace geodesic flow (SGF), and the hierarchical active basis model (HABM). Our approach outperforms other generative approaches in six out of eight experiments.", "content_type": "table", "figure_type": "N/A"}, "1701.06171v4-Table2-1.png": {"caption": "Table 2: Semi-supervised domain adaptation: Classification scores on the Four Domain Dataset. The four domains are Amazon (A), Webcam (W), Caltech256(C), DSLR (D). We compare our results to subspace geodesic flow (SGF), fisher discriminant dictionary learning (FDDL), shared domain-adapted dictionary learning, hierarchical matching pursuit (HMP), and the hierarchical active basis model (HABM). Our approach outperforms the other approaches in five out of eight experiments.", "content_type": "table", "figure_type": "N/A"}, "1701.06171v4-Figure2-1.png": {"caption": "The dependence structure between random variables in a Compositional Active Basis Model. (a) The simplest possible CABM, a binary-tree structured Markov random field. (b) The graphical model of a generalized multi-layer CABM (Section 3.3). We learn the full multi-layer structure of a CABM including the number of layers L, the number of parts per layer NL, . . . , N0 as well as their hierarchical dependence structure.", "content_type": "figure", "figure_type": "** Schematic"}, "1701.06171v4-Figure5-1.png": {"caption": "Learned hierarchical compositional models. (a) Samples from the training data. (b) The hierarchical part dictionary learned with our the bottom-up process. (c) The holistic object model after the top-down process. (d) The HCM learned with the HABM approach [5]. The gray squares indicate the parts of their HCM. Compared to the HABM, our method is able to learn the number of parts and layers of the hierarchy. Both approaches are not able to learn the holistic structure of the windmill due to the strong relative rotation between its parts.", "content_type": "figure", "figure_type": "schematic"}, "1701.06171v4-Figure3-1.png": {"caption": "Illustration of the joint bottom-up and top-down compositional learning scheme. During the bottom-up process (blue box) basis filters (black strokes) are grouped into higher-order parts until no further compositions are found. The subsequent top-down process (green box) composes the learned hierarchical part dictionary into a holistic object model (orange box).", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "How many iterations did the greedy EM-type learning process take to learn the part models for the watch image?", "answer": "22 iterations", "explanation": "The figure shows the evolution of the part models over time, with each column representing one iteration of the learning process. The last column shows the final learned part models, which were learned after 22 iterations.", "reference": "1701.06171v4-Figure4-1.png"}, {"question": "What is the relationship between the variables in the Compositional Active Basis Model?", "answer": "The variables in the Compositional Active Basis Model are hierarchically dependent. The variables at each layer are dependent on the variables at the layer above it.", "explanation": " This is shown in Figure (a) and (b), where the variables at each layer are connected to the variables at the layer above it by arrows. ", "reference": "1701.06171v4-Figure2-1.png"}, {"question": "What is the difference between the hierarchical part dictionary learned with the bottom-up process and the holistic object model learned with the top-down process?", "answer": "The hierarchical part dictionary learned with the bottom-up process is a set of parts that can be combined to create objects. The holistic object model learned with the top-down process is a single model that represents the entire object.", "explanation": "The figure shows that the hierarchical part dictionary is a set of parts that are arranged in a hierarchy. The holistic object model is a single model that represents the entire object.", "reference": "1701.06171v4-Figure5-1.png"}, {"question": "What is the difference between the top-down and bottom-up compositional learning schemes?", "answer": "The top-down compositional learning scheme starts with a holistic object model and decomposes it into smaller parts, while the bottom-up compositional learning scheme starts with basic parts and composes them into a holistic object model.", "explanation": "The figure shows the two learning schemes side-by-side. The top-down scheme is shown in the green box, where the clock image is decomposed into smaller parts. The bottom-up scheme is shown in the blue box, where basic parts are composed into a clock image.", "reference": "1701.06171v4-Figure3-1.png"}]}, "1703.00060v2": {"paper_id": "1703.00060v2", "all_figures": {"1703.00060v2-Table2-1.png": {"caption": "Table 2: Measured discrimination after discrimination removal (decision tree as the classifier).", "content_type": "table", "figure_type": "N/A"}, "1703.00060v2-Table1-1.png": {"caption": "Table 1: Measured discrimination before discrimination removal (values larger than threshold are highlighted as bold).", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "How does the discrimination in the prediction of the two-phase framework (MSG) compare to that of DI, both with and without classifier tweaking, when the sample size is 2000?", "answer": "When the sample size is 2000, the two-phase framework (MSG) achieves lower discrimination in prediction compared to DI, both with and without classifier tweaking.\n\nWith classifier tweaking: MSG achieves a discrimination level of 0.016 \u00b1 5.3E-4, while DI shows a significantly higher level of 0.095 \u00b1 1.6E-3.\nWithout classifier tweaking: MSG still demonstrates lower discrimination with 0.067 \u00b1 4.3E-3 compared to DI's 0.095 \u00b1 1.6E-3.\n\nThis indicates that the two-phase framework is more effective in removing discrimination from predictions than DI, regardless of whether classifier tweaking is applied.", "explanation": "Table 2 presents the measured discrimination after discrimination removal for both MSG and DI methods. The rows correspond to different sample sizes, and the columns represent different discrimination measures. By comparing the values in the \"DE_M_h*\" columns for both methods at the row where the sample size is 2000, we can directly assess the difference in their prediction discrimination levels. The lower values for MSG in both scenarios (with and without tweaking) demonstrate its superior performance in eliminating prediction discrimination.", "reference": "1703.00060v2-Table2-1.png"}]}, "1703.07015v3": {"paper_id": "1703.07015v3", "all_figures": {"1703.07015v3-Table1-1.png": {"caption": "Table 1: Dataset Statistics, whereT is length of time series,D is number of variables, L is the sample rate.", "content_type": "table", "figure_type": "N/A"}, "1703.07015v3-Figure3-1.png": {"caption": "Autocorrelation graphs of sampled variables form four datasets.", "content_type": "figure", "figure_type": "plot"}, "1703.07015v3-Figure1-1.png": {"caption": "The hourly occupancy rate of a road in the bay area for 2 weeks", "content_type": "figure", "figure_type": "plot"}, "1703.07015v3-Figure56-1.png": {"caption": "Several observations from these results are worth highlighting:", "content_type": "figure", "figure_type": "other"}, "1703.07015v3-Table2-1.png": {"caption": "Table 2: Results summary (in RSE and CORR) of all methods on four datasets: 1) each row has the results of a specific method in a particular metric; 2) each column compares the results of all methods on a particular dataset with a specific horizon value; 3) bold face indicates the best result of each column in a particular metric; and 4) the total number of bold-faced results of each method is listed under the method name within parentheses.", "content_type": "table", "figure_type": "N/A"}, "1703.07015v3-Figure6-1.png": {"caption": "The predicted time series (red) by LSTw/oAR (a) and by LST-Skip (b) vs. the true data (blue) on Electricity dataset with horizon = 24", "content_type": "figure", "figure_type": "plot"}, "1703.07015v3-Figure7-1.png": {"caption": "The true time series (blue) and the predicted ones (red) by VAR (a) and by LSTNet (b) for one variable in the Traffic occupation dataset. The X axis indicates the week days and the forecasting horizon = 24. VAR inadequately predicts similar patterns for Fridays and Saturdays, and ones for Sundays andMondays, while LSTNet successfully captures both the daily and weekly repeating patterns.", "content_type": "figure", "figure_type": "plot"}, "1703.07015v3-Figure2-1.png": {"caption": "Figure 2: An overview of the Long- and Short-term Time-series network (LSTNet)", "content_type": "figure", "figure_type": "Schematic"}, "1703.07015v3-Figure4-1.png": {"caption": "Simulation Test: Left side is the training set and right side is test set.", "content_type": "figure", "figure_type": "plot"}, "1703.07015v3-Figure5-1.png": {"caption": "Results of LSTNet in the ablation tests on the Solar-Energy, Traffic and Electricity dataset", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which dataset exhibits the strongest seasonality?", "answer": "The Traffic dataset.", "explanation": "The Traffic dataset's autocorrelation graph shows a clear, repeating pattern with a period of approximately 24 hours. This indicates that the data is strongly seasonal, with values tending to be similar at the same time of day on different days.", "reference": "1703.07015v3-Figure3-1.png"}, {"question": "What component of LSTNet is most important for its performance?", "answer": "The AR component.", "explanation": "Removing the AR component from the model caused the most significant performance drops on most of the datasets, indicating its importance.", "reference": "1703.07015v3-Figure56-1.png"}, {"question": "Which of the two models, LSTw/oAR or LST-Skip, seems to perform better in predicting electricity consumption?", "answer": "LST-Skip seems to perform better in predicting electricity consumption.", "explanation": "The figure shows the predicted time series (red) by LSTw/oAR (a) and by LST-Skip (b) vs. the true data (blue) on Electricity dataset with horizon = 24. It can be seen that the predicted time series by LST-Skip is closer to the true data than the predicted time series by LSTw/oAR.", "reference": "1703.07015v3-Figure6-1.png"}, {"question": "Which model, VAR or LSTNet, is better at capturing both daily and weekly repeating patterns in the data?", "answer": "LSTNet", "explanation": "The figure shows that LSTNet is able to predict similar patterns for Fridays and Saturdays, and ones for Sundays and Mondays, while VAR is not. This suggests that LSTNet is better at capturing both daily and weekly repeating patterns in the data.", "reference": "1703.07015v3-Figure7-1.png"}, {"question": "Which dataset has the highest temporal resolution, meaning it provides data points at the most frequent intervals?", "answer": "The solar dataset has the highest temporal resolution.", "explanation": "The sample rate, represented by $L$ in the table, indicates how frequently data points are collected for each dataset. The solar dataset has a sample rate of 10 minutes, which is the smallest interval compared to the other datasets. This means that the solar dataset provides more data points per unit of time than any other dataset in the table.", "reference": "1703.07015v3-Table1-1.png"}, {"question": "What are the different types of layers in the LSTNet model and how are they connected?", "answer": "The LSTNet model has four main types of layers:\n\n1. Convolutional layer: This layer extracts local dependency patterns from the input data. \n2. Recurrent and recurrent-skip layer: These layers capture long-term dependencies in the data. \n3. Fully connected and element-wise sum output layer: This layer combines the outputs from the convolutional and recurrent layers to produce the final prediction.\n4. Autoregressive layer: This layer provides a linear bypass to the non-linear neural network part of the model. \n\nThe convolutional layer receives the input data and passes its output to the recurrent and recurrent-skip layers. These layers then pass their output to the fully connected and element-wise sum output layer. The autoregressive layer receives the input data directly and its output is also fed into the fully connected and element-wise sum output layer.", "explanation": "The figure shows the different layers of the LSTNet model and how they are connected. The arrows indicate the direction of data flow.", "reference": "1703.07015v3-Figure2-1.png"}, {"question": "How does the performance of LSTNet-attn vary with the horizon on the Solar-Energy dataset?", "answer": "The performance of LSTNet-attn generally improves as the horizon increases on the Solar-Energy dataset. This is evident from the fact that both the RMSE and correlation values improve with increasing horizon.", "explanation": "The figure shows the RMSE and correlation values for different horizons on the Solar-Energy dataset. The LSTNet-attn model is represented by the green bars.", "reference": "1703.07015v3-Figure5-1.png"}]}, "1703.04887v4": {"paper_id": "1703.04887v4", "all_figures": {"1703.04887v4-Table3-1.png": {"caption": "Table 3: The translation performance of the BRCSGAN with different N for Monte Carlo search. \u201d-\u201d means that the proposed model shows no improvement than the pre-trained generator or it can not be trained stably. With N set as 0, it is referred to as the pretrained generator. Similarly, we only report results on the RNNSearch and \u03bb is set as 0.7.", "content_type": "table", "figure_type": "N/A"}, "1703.04887v4-Figure2-1.png": {"caption": "BLEU score on the development set for the BR-CSGAN where the discriminators have different initial accuracy. \u201d0.6-acc\u201d means the initial accuracy is 0.6. We report the results on the Chinese-English translation tasks. RNNSearch is taken as the generator.", "content_type": "figure", "figure_type": "plot"}, "1703.04887v4-Table2-1.png": {"caption": "Table 2: BLEU score on Chinese-English and EnglishGerman translation tasks for MRT and BR-CSGAN.", "content_type": "table", "figure_type": "N/A"}, "1703.04887v4-Table1-1.png": {"caption": "Table 1: BLEU score on Chinese-English and English-German translation tasks. The hyper-parameter \u03bb is selected according to the development set. For the Transformer, following (Vaswani et al., 2017), we report the result of a single model obtained by averaging the 5 checkpoints around the best model selected on the development set.", "content_type": "table", "figure_type": "N/A"}, "1703.04887v4-Figure1-1.png": {"caption": "The Illustration of the proposed BR-CSGAN. Left: D is trained over the real sentence pairs translated by the human and the generated sentence pairs by G. Note that D is a conditional discriminator. Right: G is trained by police gradient where the final reward is provided by D and Q.", "content_type": "figure", "figure_type": "** Schematic"}}, "qa": [{"question": "What is the relationship between the number of Monte Carlo samples (N) and the translation performance of the BR-CSGAN model? Why is there a trade-off when choosing the value of N?", "answer": "The table and passage show that the translation performance of the BR-CSGAN model generally improves as the number of Monte Carlo samples (N) increases. However, this improvement plateaus after N reaches a certain point (around 20 in this case).\n\nThere is a trade-off when choosing the value of N because increasing N also increases the computational complexity and training time. While a higher N leads to more accurate reward estimations and better performance, it also requires more computational resources and longer training times. Therefore, choosing the optimal N involves balancing the desired performance with the available computational resources and time constraints.", "explanation": "Table 2 presents the BLEU scores of the BR-CSGAN model with different N values. As N increases from 15 to 20, the BLEU scores consistently improve across all datasets. However, further increasing N to 25 and 30 shows minimal improvement, indicating a plateau in performance. The passage explains that this is because a higher N leads to more accurate reward estimations, guiding the model towards better performance. However, it also clarifies that higher N values require more sampling, significantly increasing computation time. Therefore, the choice of N involves a trade-off between accuracy and computational efficiency.", "reference": "1703.04887v4-Table3-1.png"}, {"question": "How does the initial accuracy of the discriminator affect the BLEU score?", "answer": "The BLEU score decreases as the initial accuracy of the discriminator increases.", "explanation": "The plot shows that the BLEU score decreases as the initial accuracy of the discriminator increases. This is likely because a more accurate discriminator is able to better distinguish between real and generated data, which makes it more difficult for the generator to produce realistic data.", "reference": "1703.04887v4-Figure2-1.png"}, {"question": "How does BR-CSGAN compare to MRT in terms of translation performance and what is the likely reason for this difference?", "answer": "BR-CSGAN consistently outperforms MRT on both Chinese-English and English-German translation tasks, achieving higher BLEU scores.\n\nWhile both methods optimize similar objectives, BR-CSGAN uses a reinforcement learning procedure with a dynamic discriminator to maximize rewards for the generator. This dynamic feedback seems to be more effective than the static objective and random sampling approach used by MRT, leading to better translation performance.", "explanation": "The table directly provides the BLEU scores for both methods, allowing for a comparison of their translation performance. The passage then sheds light on the possible reason for this difference by describing the key differences in their training procedures. Specifically, the use of reinforcement learning and a dynamic discriminator in BR-CSGAN is highlighted as a potential advantage over MRT's static objective and random sampling approach.", "reference": "1703.04887v4-Table2-1.png"}, {"question": "Which model and configuration achieves the best performance on the Chinese-English translation task, and how much improvement does it offer compared to the baseline RNNSearch model?", "answer": "The Transformer+BR-CSGAN model with \u03bb=0.8 achieves the best performance on the Chinese-English translation task with an average BLEU score of 42.61. This represents an improvement of 0.81 BLEU points compared to the baseline RNNSearch model.", "explanation": "Table 1 shows the BLEU scores for different models and configurations on the Chinese-English translation task. We can compare the average BLEU scores across different models to identify the best performing one. The table also allows us to compare the performance of the BR-CSGAN augmented models with their respective baseline models (RNNSearch and Transformer) by looking at the difference in BLEU scores.", "reference": "1703.04887v4-Table1-1.png"}, {"question": "What is the role of the discriminator (D) in the proposed BR-CSGAN model?", "answer": " The discriminator (D) is responsible for distinguishing between real sentence pairs translated by humans and generated sentence pairs produced by the generator (G). It provides feedback to G in the form of rewards, helping G improve its ability to generate realistic sentence pairs.", "explanation": " The left side of the figure shows that D receives both real sentence pairs (x, y_d) and generated sentence pairs (x, y_g). By comparing these pairs, D learns to differentiate between human-translated and machine-generated sentences. This information is then used to reward G for generating more realistic sentence pairs.", "reference": "1703.04887v4-Figure1-1.png"}]}, "1703.10730v2": {"paper_id": "1703.10730v2", "all_figures": {"1703.10730v2-Figure1-1.png": {"caption": "Figure 1: The proposed algorithm is able to synthesize an image from key local patches without geometric priors, e.g., restoring broken pieces of ancient ceramics found in ruins. Convolutional neural networks are trained to predict locations of input patches and generate the entire image based on adversarial learning.", "content_type": "figure", "figure_type": "schematic"}, "1703.10730v2-Figure6-1.png": {"caption": "Examples of generated masks and images on six datasets. The generated images for each class are shown in 12 columns. Three key local patches (Input 1, Input 2, and Input 3) from a real image (Real). The key parts are top-3 regions in terms of the objectness score. Given inputs, images (Gen) and masks (Gen M) are generated. Real M is the ground truth mask.", "content_type": "figure", "figure_type": ""}, "1703.10730v2-Figure8-1.png": {"caption": "Figure 8: For each generated image in the green box, nearest neighbors in the corresponding training dataset are displayed.", "content_type": "figure", "figure_type": "photograph(s)"}, "1703.10730v2-Figure7-1.png": {"caption": "Figure 7: Sample generated masks and images at different epochs.", "content_type": "figure", "figure_type": "photograph(s)"}, "1703.10730v2-Figure13-1.png": {"caption": "Image generation results with two input patches. Input 1 and 2 are local patches from the image Real.", "content_type": "figure", "figure_type": "photograph(s)"}, "1703.10730v2-Figure2-1.png": {"caption": "Figure 2: Proposed network architecture. A bar represents a layer in the network. Layers of the same size and the same color have the same convolutional feature maps. Dashed lines in the part encoding network represent shared weights. In addition, E denotes an embedded vector and z is a random noise vector.", "content_type": "figure", "figure_type": "schematic"}, "1703.10730v2-Figure3-1.png": {"caption": "Examples of detected key patches on faces [14], vehicles [9], flowers [18], and waterfall scenes. Three regions with top scores from the EdgeBox algorithm are shown in red boxes after pruning candidates of an extreme size or aspect ratio.", "content_type": "figure", "figure_type": "photograph(s)"}, "1703.10730v2-Figure9-1.png": {"caption": "Figure 9: Examples of generated results when the input image contains noises. We add a Gaussian noise at each pixel of Input 3. Gen 1 and Gen M1 are generated without noises. Gen 2 and Gen M2 are generated with noises.", "content_type": "figure", "figure_type": "photograph(s)"}, "1703.10730v2-Figure4-1.png": {"caption": "Figure 4: Different structures of networks to predict a mask from input patches. We choose (e) as our encoder-decoder model.", "content_type": "figure", "figure_type": "schematic"}, "1703.10730v2-Figure12-1.png": {"caption": "Figure 12: Results of the proposed algorithm on the CompCars dataset when input patches are from different cars. Input 1 and Input 2 are patches from Real 1. Input 3 is a local region of Real 2. Given inputs, the proposed algorithm generates the image (Gen) and mask (Gen M). The size of the generated image is of 128\u00d7 128 pixels.", "content_type": "figure", "figure_type": ""}, "1703.10730v2-Figure11-1.png": {"caption": "Figure 11: Examples of failure cases of the proposed algorithm.", "content_type": "figure", "figure_type": "photograph(s)"}, "1703.10730v2-Figure10-1.png": {"caption": "Figure 10: Results of the proposed algorithm on the CelebA dataset when input patches are came from other images. Input 1 and Input 2 are patches from Real 1. Input 3 is a local region of Real 2. Given inputs, the proposed algorithm generates the image (Gen) and mask (Gen M).", "content_type": "figure", "figure_type": ""}, "1703.10730v2-Figure14-1.png": {"caption": "Image generation results on the CelebA dataset. Gen 1 and GenM1 are generated by (5). Gen 2 and GenM2 are obtained using (4) in the paper.", "content_type": "figure", "figure_type": "photograph(s)"}}, "qa": [{"question": "What are the three goals that the proposed algorithm must achieve simultaneously?", "answer": "The three goals that the proposed algorithm must achieve simultaneously are: \n1. To predict the locations of the input patches. \n2. To generate the entire image based on the predicted locations of the input patches. \n3. To do so without any geometric priors.", "explanation": "The figure shows that the algorithm takes as input a set of local patches and outputs a complete image. This suggests that the algorithm must be able to predict the locations of the input patches and then generate the rest of the image based on those predictions. Additionally, the caption states that the algorithm does not require any geometric priors, which means that it must be able to infer the structure of the image from the input patches alone.", "reference": "1703.10730v2-Figure1-1.png"}, {"question": "How does the network's focus change as the training epoch increases?", "answer": "The network initially focuses on predicting a good mask. As the epoch increases, the input parts become sharper. Finally, the network concentrates on generating realistic images.", "explanation": "Figure 0 shows how the generated images and masks change as the training epoch increases. In the early epochs, the masks are blurry and the images are unrealistic. However, as the training progresses, the masks become sharper and the images become more realistic. This suggests that the network is learning to focus on different aspects of the image generation process at different stages of training.", "reference": "1703.10730v2-Figure7-1.png"}, {"question": "What is the relationship between the input patches and the generated images?", "answer": "The input patches are used to generate the images. The generator network takes the input patches as input and generates new images that are similar to the input patches.", "explanation": "The figure shows two input patches (Input 1 and Input 2) and the corresponding generated images (Gen). The generated images are similar to the input patches, but they are not identical. This suggests that the generator network is able to learn the features of the input patches and generate new images that are similar to the input patches.", "reference": "1703.10730v2-Figure13-1.png"}, {"question": "What are the inputs to the image generation network?", "answer": "The inputs to the image generation network are the observed images (x) and a random noise vector (z).", "explanation": "The figure shows that the image generation network takes two inputs: one from the part encoding network (which represents the observed images) and one from a random noise vector.", "reference": "1703.10730v2-Figure2-1.png"}, {"question": "How does the presence of noise in the input image affect the quality of the generated images?", "answer": "The presence of noise in the input image can degrade the quality of the generated images, but the proposed algorithm is still able to generate realistic images even with a certain amount of noise.", "explanation": "The figure shows that the generated images with noise (Gen 2 and Gen M2) are still recognizable as faces, even though they are not as clear as the generated images without noise (Gen 1 and Gen M1). This suggests that the proposed algorithm is robust to noise and can still generate realistic images even when the input image is degraded.", "reference": "1703.10730v2-Figure9-1.png"}]}, "1803.03467v4": {"paper_id": "1803.03467v4", "all_figures": {"1803.03467v4-Figure1-1.png": {"caption": "Illustration of knowledge graph enhanced movie recommender systems. The knowledge graph provides fruitful facts and connections among items, which are useful for improving precision, diversity, and explainability of recommended results.", "content_type": "figure", "figure_type": "** Schematic"}, "1803.03467v4-Table1-1.png": {"caption": "Basic statistics of the three datasets.", "content_type": "table", "figure_type": "table"}, "1803.03467v4-Table2-1.png": {"caption": "Table 2: Hyper-parameter settings for the three datasets.", "content_type": "table", "figure_type": "N/A"}, "1803.03467v4-Figure4-1.png": {"caption": "The average number of k-hop neighbors that two items share in the KG w.r.t. whether they have common raters in (a) MovieLens-1M, (b) Book-Crossing, and (c) BingNews datasets. (d) The ratio of the two average numberswith different hops.", "content_type": "figure", "figure_type": "plot"}, "1803.03467v4-Figure5-1.png": {"caption": "Precision@K , Recall@K , and F1@K in top-K recommendation for MovieLens-1M.", "content_type": "figure", "figure_type": "plot"}, "1803.03467v4-Figure6-1.png": {"caption": "Precision@K , Recall@K , and F1@K in top-K recommendation for Book-Crossing.", "content_type": "figure", "figure_type": "plot"}, "1803.03467v4-Table3-1.png": {"caption": "The results of AUC and Accuracy in CTR prediction.", "content_type": "table", "figure_type": "** table"}, "1803.03467v4-Figure7-1.png": {"caption": "Precision@K , Recall@K , and F1@K in top-K recommendation for Bing-News.", "content_type": "figure", "figure_type": "plot"}, "1803.03467v4-Figure2-1.png": {"caption": "Figure 2: The overall framework of theRippleNet. It takes one user and one item as input, and outputs the predicted probability that the user will click the item. The KGs in the upper part illustrate the corresponding ripple sets activated by the user\u2019s click history.", "content_type": "figure", "figure_type": "schematic"}, "1803.03467v4-Figure3-1.png": {"caption": "Illustration of ripple sets of \"Forrest Gump\" in KG ofmovies. The concentric circles denotes the ripple setswith different hops. The fading blue indicates decreasing relatedness between the center and surrounding entities.Note that the ripple sets of different hops are not necessarily disjoint in practice.", "content_type": "figure", "figure_type": "schematic"}, "1803.03467v4-Table4-1.png": {"caption": "The results of AUC w.r.t. different sizes of a user\u2019s ripple set.", "content_type": "table", "figure_type": "** Table"}, "1803.03467v4-Table5-1.png": {"caption": "The results of AUC w.r.t. different hop numbers.", "content_type": "table", "figure_type": "table"}, "1803.03467v4-Figure8-1.png": {"caption": "Visualization of relevance probabilities for a randomly sampled user w.r.t. a piece of candidate news with label 1. Links with value lower than \u22121.0 are omitted.", "content_type": "figure", "figure_type": "schematic"}, "1803.03467v4-Figure9-1.png": {"caption": "Parameter sensitivity of RippleNet.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which dataset has the most 4-hop triples?", "answer": "Bing-News.", "explanation": "The table shows the number of 4-hop triples for each dataset. Bing-News has the highest number of 4-hop triples, with 6,322,548.", "reference": "1803.03467v4-Table1-1.png"}, {"question": "How does the number of common k-hop neighbors change as the hop distance increases for items with and without common raters?", "answer": "The number of common k-hop neighbors generally decreases as the hop distance increases for both items with and without common raters. However, the number of common k-hop neighbors is consistently higher for items with common raters than for items without common raters.", "explanation": "The figure shows that the bars representing items with common raters are consistently higher than the bars representing items without common raters for all three datasets and for all hop distances. This indicates that items with common raters are more likely to have common neighbors than items without common raters.", "reference": "1803.03467v4-Figure4-1.png"}, {"question": "Which model performs the best in terms of AUC on the MovieLens-1M dataset?", "answer": "RippleNet*", "explanation": " The table shows the AUC and ACC values for different models on three datasets. The highest AUC value for the MovieLens-1M dataset is 0.921, which corresponds to the RippleNet* model.", "reference": "1803.03467v4-Table3-1.png"}, {"question": "What is the role of the ripple sets in the RippleNet framework?", "answer": "The ripple sets are used to propagate a user's preferences from his or her click history to his or her relevant entities.", "explanation": "The figure shows how the ripple sets are used to propagate a user's preferences. The user's click history is used to generate the first-order ripple set, which is then used to generate the second-order ripple set, and so on. Each ripple set contains entities that are relevant to the user's interests, and the relevance probabilities are used to weight the entities in each ripple set. The weighted average of the entities in each ripple set is then used to generate the user's embedding, which is used to predict the probability that the user will click on a particular item.", "reference": "1803.03467v4-Figure2-1.png"}, {"question": "What is the relationship between the movies \"Forrest Gump\" and \"Cast Away\"?", "answer": "The movies \"Forrest Gump\" and \"Cast Away\" are connected by the actor Tom Hanks.", "explanation": "The figure shows that Tom Hanks is connected to both \"Forrest Gump\" and \"Cast Away\" by the \"actor.film\" relationship. This indicates that Tom Hanks starred in both movies.", "reference": "1803.03467v4-Figure3-1.png"}, {"question": "Which dataset has the highest AUC for all ripple set sizes?", "answer": "MovieLens-1M", "explanation": " The table shows the AUC values for three datasets (MovieLens-1M, Book-Crossing, and Bing-News) for different ripple set sizes. The values in the MovieLens-1M row are consistently higher than the values in the other two rows, indicating that MovieLens-1M has the highest AUC for all ripple set sizes.", "reference": "1803.03467v4-Table4-1.png"}, {"question": "How does the dimension of embedding affect the AUC of RippleNet on MovieLens-1M?", "answer": "The AUC of RippleNet first increases and then decreases with the increase of the dimension of embedding.", "explanation": "The figure shows that the AUC reaches its peak when the dimension of embedding is 8, and then starts to decrease.", "reference": "1803.03467v4-Figure9-1.png"}]}, "1803.04572v2": {"paper_id": "1803.04572v2", "all_figures": {"1803.04572v2-Table6-1.png": {"caption": "Table 6: Speedups (running time of SPARTan divided by running time of COPA for various constraint configurations) and corresponding p-values. COPA is faster (up to 2.5\u00d7) on the majority of constraint configurations as compared to the baseline SPARTan approach which can only handle non-negativity constraints.", "content_type": "table", "figure_type": "N/A"}, "1803.04572v2-Figure3-1.png": {"caption": "Figure 3: Comparison of FIT for different approaches with various constraints on two target ranks R = 15 and R = 40 on real world datasets. Overall, COPA achieves comparable fit to SPARTan while supporting more constraints. The missing purple bar in the forth column is out of memory failure for Helwig method.", "content_type": "figure", "figure_type": "plot"}, "1803.04572v2-Table7-1.png": {"caption": "Table 7: Phenotypes discovered by COPA . The red color corresponds to diagnosis and blue color corresponds to medication. The meaningfulness of phenotypes endorsed by a medical expert. No additional post-processing was performed on these results.", "content_type": "table", "figure_type": "N/A"}, "1803.04572v2-Figure1-1.png": {"caption": "An illustration of the constraints imposed by COPA on PARAFAC2 model factors, targeting temporal phenotyping via EHR data.", "content_type": "figure", "figure_type": "Schematic"}, "1803.04572v2-Table1-1.png": {"caption": "Table 1: Comparison of PARAFAC2 models and constrained tensor factorization applied to phenotyping", "content_type": "table", "figure_type": "N/A"}, "1803.04572v2-Figure2-1.png": {"caption": "7 Basis functions for a patient with sickle cell anemia. Figure 2a shows the basis functions that COPA used for incorporating the smoothness that considers the gap between two visits while figure 2b related to basis functions for Helwig which divide the range [0,80] based on a equal distance.", "content_type": "figure", "figure_type": "plot"}, "1803.04572v2-Table4-1.png": {"caption": "Table 4: Values of parameters (l, \u00b5) for different data sets and various target ranks for COPA.", "content_type": "table", "figure_type": "N/A"}, "1803.04572v2-Table5-1.png": {"caption": "Table 5: The average and standard deviation of sparsity metric (fraction of zero elements divided by the matrix size) comparison for the factor matrix V on CHOA and CMS using two different target ranks for 5 different random initializations.", "content_type": "table", "figure_type": "N/A"}, "1803.04572v2-Figure8-1.png": {"caption": "The temporal patterns extracted for two patients by COPA , Helwig, and SPARTan. The first row is associated with a patient who has sickle cell anemia while the second row is for a patient with Leukemia.", "content_type": "figure", "figure_type": "plot"}, "1803.04572v2-Table2-1.png": {"caption": "Table 2: Symbols and notations used throughout the paper.", "content_type": "table", "figure_type": "N/A"}, "1803.04572v2-Figure6-1.png": {"caption": "The best convergence of COPA and SPARTan out of 5 different random initializations with non-negativity constraint on H, {Sk}, and V on CMS data with K=843,162, J=284 and maximum number of observations are 1500. Algorithms tested on different target ranks (two cases considered: R={15,40}).", "content_type": "figure", "figure_type": "plot"}, "1803.04572v2-Figure7-1.png": {"caption": "Time in seconds for one iteration (as an average of 5 different random initializations) for different values of R. The left figure is the comparison on CHOA and the right figure shows the comparison on CMS. For R=40 COPA achieves 32\u00d7 over the Helwig approach on CHOA while for CMS dataset, execution in Helwig failed due to the excessive amount of memory request and COPA finished an iteration with the average of 224.21 seconds.", "content_type": "figure", "figure_type": "plot"}, "1803.04572v2-Figure4-1.png": {"caption": "The Total Running Time comparison (average and standard deviation) in seconds for different versions of COPA and SPARTan for 5 different random initializations. Note that even with smooth constraint COPA performs just slightly slower than SPARTan, which does not support such smooth constraints.", "content_type": "figure", "figure_type": "plot"}, "1803.04572v2-Figure5-1.png": {"caption": "The best Convergence of COPA and SPARTan out of 5 different random initializations with non-negativity constraint on H, {Sk}, and V on CHOA data set for different target ranks (two cases considered: R={15,40}).", "content_type": "figure", "figure_type": "plot"}, "1803.04572v2-Table3-1.png": {"caption": "Summary statistics of real datasets that we used in the experiments. K denotes the number of patients, J is the number of medical features and Ik denotes the number of clinical visits for kth patient.", "content_type": "table", "figure_type": "table"}}, "qa": [{"question": "Which constraint has the most significant impact on the FIT values for the CMS data set when the target rank is 15?", "answer": "The smoothness constraint on $\\M{U_k}$ has the most significant impact on the FIT values for the CMS data set when the target rank is 15.", "explanation": "From Figure 0, we can see that the FIT value for COPA (Smoothness on $\\M{U_k}$) is the highest among all the versions of COPA for the CMS data set when the target rank is 15. This indicates that the smoothness constraint on $\\M{U_k}$ has the most significant impact on the FIT values.", "reference": "1803.04572v2-Figure3-1.png"}, {"question": "What are some common medications used to treat Sickle Cell Anemia?", "answer": "According to the table, some common medications used to treat Sickle Cell Anemia include:\n\nBeta-adrenergic agents\nAnalgesics (narcotics and non-narcotics)\nNSAIDs (cyclooxygenase inhibitor - type)\nPotassium replacement\nSodium/saline preparations\nGeneral inhalation agents\nLaxatives and cathartics\nIV solutions (dextrose-saline)\nAntiemetic/antivertigo agents\nSedative-hypnotics (non-barbiturate)\nGlucocorticoids (orally inhaled)\nFolic acid preparations\nAnalgesic narcotic anesthetic adjunct agents", "explanation": "The table presents various phenotypes discovered by the mentioned method, including Sickle Cell Anemia. Under each phenotype, the associated diagnoses and medications are listed. Therefore, by looking at the medications listed under the \"Sickle Cell Anemia\" phenotype, we can identify the common medications used for its treatment.", "reference": "1803.04572v2-Table7-1.png"}, {"question": "What are the three constraints imposed by COPA on PARAFAC2 model factors?", "answer": "Non-negativity, smoothness, and sparsity.", "explanation": "The figure shows how COPA imposes three constraints on PARAFAC2 model factors: non-negativity, smoothness, and sparsity. The non-negativity constraint ensures that all factor values are non-negative. The smoothness constraint ensures that the factor values change smoothly over time. The sparsity constraint ensures that only a small number of factor values are non-zero.", "reference": "1803.04572v2-Figure1-1.png"}, {"question": "How do the temporal patterns of phenotype magnitude differ between sickle cell anemia and leukemia patients?", "answer": "The temporal patterns of phenotype magnitude differ between sickle cell anemia and leukemia patients in terms of both shape and magnitude. For sickle cell anemia patients, the patterns are generally smoother and more periodic, with lower overall magnitude. For leukemia patients, the patterns are more erratic and have higher overall magnitude.", "explanation": "The figure shows the temporal patterns of phenotype magnitude for two patients, one with sickle cell anemia and one with leukemia. The patterns for the sickle cell anemia patient are smoother and more periodic, with lower overall magnitude, while the patterns for the leukemia patient are more erratic and have higher overall magnitude.", "reference": "1803.04572v2-Figure8-1.png"}, {"question": "Which algorithm converged faster in both cases of target rank?", "answer": "SPARTan converged faster in both cases of target rank.", "explanation": "The figure shows that the SPARTan curve reaches a higher F-measure value in a shorter amount of time than the COPA curve in both cases of target rank.", "reference": "1803.04572v2-Figure6-1.png"}, {"question": "Which method is faster, COPA or Helwig?", "answer": "COPA is faster than Helwig.", "explanation": "The figure shows that COPA has a lower time than Helwig for all values of R on both the CHOA and CMS data sets.", "reference": "1803.04572v2-Figure7-1.png"}, {"question": "Which dataset has the largest number of clinical visits per patient?", "answer": "CMS", "explanation": "The table shows that the maximum number of clinical visits for the CMS dataset is 1500, which is larger than the maximum number of clinical visits for the CHOA dataset (857).", "reference": "1803.04572v2-Table3-1.png"}]}, "1704.05426v4": {"paper_id": "1704.05426v4", "all_figures": {"1704.05426v4-Table4-1.png": {"caption": "Table 4: Test set accuracies (%) for all models; Match. represents test set performance on the MultiNLI genres that are also represented in the training set, Mis. represents test set performance on the remaining ones; Most freq. is a trivial \u2018most frequent class\u2019 baseline.", "content_type": "table", "figure_type": "N/A"}, "1704.05426v4-Table1-1.png": {"caption": "Table 1: Randomly chosen examples from the development set of our new corpus, shown with their genre labels, their selected gold labels, and the validation labels (abbreviated E, N, C) assigned by individual annotators.", "content_type": "table", "figure_type": "N/A"}, "1704.05426v4-Figure1-1.png": {"caption": "The main text of a prompt (truncated) that was presented to our annotators. This version is used for the written non-fiction genres.", "content_type": "figure", "figure_type": "\"other\""}, "1704.05426v4-Table5-1.png": {"caption": "Dev. Freq. is the percentage of dev. set examples that include each phenomenon, ordered by greatest difference in frequency of occurrence (Diff.) between MultiNLI and SNLI. Most Frequent Label specifies which label is the most frequent for each tag in the MultiNLI dev. set, and % is its incidence. Model Acc. is the dev. set accuracy (%) by annotation tag for each baseline model (trained on MultiNLI only). (PTB) marks a tag as derived from Penn Treebank-style parser output tags (Marcus et al., 1993).", "content_type": "table", "figure_type": "table"}, "1704.05426v4-Table2-1.png": {"caption": "Key validation statistics for SNLI (copied from Bowman et al., 2015) and MultiNLI.", "content_type": "table", "figure_type": "table"}, "1704.05426v4-Table3-1.png": {"caption": "Table 3: Key statistics for the corpus by genre. The first five genres represent the matched section of the development and test sets, and the remaining five represent the mismatched section. The first three statistics provide the number of examples in each genre. #Wds. Prem. is the mean token count among premise sentences. \u2018S\u2019 parses is the percentage of sentences for which the Stanford Parser produced a parse rooted with an \u2018S\u2019 (sentence) node. Agrmt. is the percent of individual labels that match the gold label in validated examples. Model Acc. gives the test accuracy for ESIM and CBOW models (trained on either SNLI or MultiNLI), as described in Section 3.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "What are the three types of sentences that the annotators are asked to write?", "answer": "The three types of sentences are: \n1. A sentence that is definitely correct about the situation or event in the line.\n2. A sentence that might be correct about the situation or event in the line.\n3. A sentence that is definitely incorrect about the situation or event in the line.", "explanation": "The figure shows the instructions given to the annotators, which explicitly state the three types of sentences they are asked to write.", "reference": "1704.05426v4-Figure1-1.png"}, {"question": "Which type of word has the greatest difference in frequency of occurrence between MultiNLI and SNLI?", "answer": "Negation (PTB)", "explanation": "The table shows the difference in frequency of occurrence between MultiNLI and SNLI for each type of word. The \"Diff.\" column shows that negation has the greatest difference, with a difference of 26.", "reference": "1704.05426v4-Table5-1.png"}, {"question": "Which model performs better on the MultiNLI dataset when considering the percentage of individual labels that match the author's label?", "answer": "SNLI performs better than MultiNLI when considering the percentage of individual labels that match the author's label. SNLI has a score of 85.8%, while MultiNLI has a score of 85.2%.", "explanation": "The table shows the validation statistics for SNLI and MultiNLI. The \"Individual label = author's label\" row shows the percentage of individual labels that match the author's label. SNLI has a higher percentage than MultiNLI, which indicates that SNLI performs better on this metric.", "reference": "1704.05426v4-Table2-1.png"}, {"question": "Which genre in the MultiNLI corpus has the highest percentage of sentences where the Stanford Parser produced a parse rooted with an 'S' (sentence) node, and how does this compare to the overall average for the corpus?", "answer": "The genre with the highest percentage of 'S' parses is **9/11**, with **99%** of its sentences receiving this parse. This is higher than the overall average for the MultiNLI corpus, which sits at **91%**.", "explanation": "The table provides the percentage of 'S' parses for each genre under the column \"`S' parses\". By comparing these values, we can identify which genre has the highest percentage. Additionally, the overall average for the corpus is provided in the last row of the table, allowing for a comparison between the 9/11 genre and the entire dataset.", "reference": "1704.05426v4-Table3-1.png"}, {"question": "How does the performance of the ESIM model differ when trained on MNLI alone versus trained on both MNLI and SNLI combined?", "answer": "When trained on MNLI alone, the ESIM model achieves an accuracy of 60.7% on SNLI, 72.3% on matched genres in MNLI, and 72.1% on mismatched genres in MNLI. However, when trained on both MNLI and SNLI combined, the ESIM model's performance improves across all tasks, reaching 79.7% accuracy on SNLI, 72.4% on matched MNLI genres, and 71.9% on mismatched MNLI genres.", "explanation": "Table 1 shows the test set accuracies for different models trained on different data sets. By comparing the rows corresponding to ESIM trained on MNLI and ESIM trained on MNLI + SNLI, we can observe the impact of adding SNLI data to the training process. The increased accuracy across all test sets suggests that the combined dataset helps the model generalize better and improve its performance.", "reference": "1704.05426v4-Table4-1.png"}]}, "1704.05958v2": {"paper_id": "1704.05958v2", "all_figures": {"1704.05958v2-Table1-1.png": {"caption": "Table 1: Statistics of the NYT dataset.", "content_type": "table", "figure_type": "N/A"}, "1704.05958v2-Figure1-1.png": {"caption": "The wrong labeling problem of distant supervision, and how to combat it with global statistics. Left: conventional distant supervision. Each of the textual relations will be labeled with both KB relations, while only one is correct (blue and solid), and the other is wrong (red and dashed). Right: distant supervision with global statistics. The two textual relations can be clearly distinguished by their co-occurrence distribution of KB relations. Statistics are based on the annotated ClueWeb data released in (Toutanova et al., 2015).", "content_type": "figure", "figure_type": "schematic"}, "1704.05958v2-Figure4-1.png": {"caption": "Held-out evaluation: other base relation extraction models and the improved versions when augmented with GloRE.", "content_type": "figure", "figure_type": "plot"}, "1704.05958v2-Figure5-1.png": {"caption": "Held-out evaluation: the previous best-performing model can be further improved when augmented with GloRE. PCNN+ATT+TM is a recent model (Luo et al., 2017) whose performance is slightly inferior to PCNN+ATT. Because the source code is not available, we did not experiment to augment this model with GloRE. Another recent method (Wu et al., 2017) incorporates adversarial training to improve PCNN+ATT, but the results are not directly comparable (see Section 2 for more discussion). Finally, Ji et al. (2017) propose a model similar to PCNN+ATT, but the performance is inferior to PCNN+ATT and is not shown here for clarity.", "content_type": "figure", "figure_type": "plot"}, "1704.05958v2-Figure6-1.png": {"caption": "Held-out evaluation: GloRE brings the largest improvement to BASE (PCNN+ATT), which further shows that GloRE captures useful information for relation extraction that is complementary to existing models.", "content_type": "figure", "figure_type": "plot"}, "1704.05958v2-Figure2-1.png": {"caption": "Relation graph. The left node set is textual relations, and the right node set is KB relations. The raw cooccurrence counts are normalized such that the KB relations corresponding to the same textual relation form a valid probability distribution. Edges are colored by textual relation and weighted by normalized co-occurrence statistics.", "content_type": "figure", "figure_type": "schematic"}, "1704.05958v2-Figure7-1.png": {"caption": "Held-out evaluation: LoRE vs. GloRE.", "content_type": "figure", "figure_type": "plot"}, "1704.05958v2-Table2-1.png": {"caption": "Table 2: Manual evaluation: false negatives from held-out evaluation are manually corrected by human experts.", "content_type": "table", "figure_type": "N/A"}, "1704.05958v2-Table3-1.png": {"caption": "Table 3: Case studies. We select entity pairs that have only one contextual sentence, and the head and tail entities are marked. The top 3 predictions from each model with the associated probabilities are listed, with the correct relation bold-faced.", "content_type": "table", "figure_type": "N/A"}, "1704.05958v2-Figure3-1.png": {"caption": "Embedding model. Left: A RNN with GRU for embedding. Middle: embedding of textual relation. Right: a separate GRU cell to map a textual relation embedding to a probability distribution over KB relations.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "Can you estimate the percentage of entity pairs in the NYT training set that have a corresponding relational fact in the Knowledge Base (KB)?", "answer": "Approximately 6.66%.", "explanation": "The table shows that the training set contains 291,699 entity pairs and 19,429 relational facts from the KB. To find the percentage of entity pairs with a corresponding KB fact, we divide the number of facts by the number of entity pairs and multiply by 100: \n\n(19,429 / 291,699) * 100 \u2248 6.66%. \n\nThis indicates that only a small fraction of entity pairs in the training data have an explicitly defined relationship in the KB.", "reference": "1704.05958v2-Table1-1.png"}, {"question": "Why is conventional distant supervision problematic?", "answer": "Conventional distant supervision can lead to wrong labeling of textual relations with KB relations.", "explanation": "The figure shows that with conventional distant supervision, both textual relations (\"Michael_Jackson was born in the US\" and \"Michael_Jackson died in the US\") are labeled with both KB relations (\"place_of_birth\" and \"place_of_death\"), even though only one of them is correct in each case. This is because conventional distant supervision relies on local information, and does not take into account global statistics about the co-occurrence of KB relations.", "reference": "1704.05958v2-Figure1-1.png"}, {"question": "What is the role of the GRU cell in the embedding model?", "answer": "The GRU cell is used to map a textual relation embedding to a probability distribution over KB relations.", "explanation": "The figure shows a RNN with GRU for embedding, which is used to generate a textual relation embedding. This embedding is then fed into a separate GRU cell, which outputs a probability distribution over KB relations.", "reference": "1704.05958v2-Figure3-1.png"}]}, "1803.05776v2": {"paper_id": "1803.05776v2", "all_figures": {"1803.05776v2-Figure1-1.png": {"caption": "Results for the cerebellum data (a) Adjacency matrix, (b) NMSE for testing data as a function of training data size at SNR=10dB, and (c) at SNR=0dB.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which model performs the best at SNR=0dB?", "answer": "GPG-K", "explanation": "The NMSE for GPG-K is the lowest at SNR=0dB, as shown in Figure (c).", "reference": "1803.05776v2-Figure1-1.png"}]}, "1803.06506v3": {"paper_id": "1803.06506v3", "all_figures": {"1803.06506v3-Figure1-1.png": {"caption": "Figure 1. We exploit the presence of semantic commonalities within a set of image-phrase pairs to generate supervisory signals. We hypothesize that to predict these commonalities, the model must localize them correctly within each image of the set.", "content_type": "figure", "figure_type": "** photograph(s)"}, "1803.06506v3-Table2-1.png": {"caption": "Table 2. Phrase grounding evaluation on 3 datasets using the pointing game metric. See Section 5 for mask vs bbox explanation for ReferIt.", "content_type": "table", "figure_type": "N/A"}, "1803.06506v3-Figure5-1.png": {"caption": "Figure 5. Comparison of VGG16 feature maps with our generated attention maps.", "content_type": "figure", "figure_type": "photograph(s)"}, "1803.06506v3-Table3-1.png": {"caption": "Analysis of different surrogate losses while varying the concept batch size.", "content_type": "table", "figure_type": "table"}, "1803.06506v3-Figure3-1.png": {"caption": "Variation of performance with respect to bounding box area and similarity of concept with ImageNet classes.", "content_type": "figure", "figure_type": "plot"}, "1803.06506v3-Figure7-1.png": {"caption": "Figure 7. Additional qualitative examples", "content_type": "figure", "figure_type": "** photograph(s)"}, "1803.06506v3-Figure4-1.png": {"caption": "Figure 4. Qualitative results of our approach with different image and phrase pairs as input. More results and visual error analysis shown in supplementary material.", "content_type": "figure", "figure_type": "photograph(s)"}, "1803.06506v3-Figure2-1.png": {"caption": "Figure 2. An overview of our model for unsupervised visual grounding of phrases. The encoder takes in a set of image-phrase pairs, indexed by i, all sharing a common concept. The encoder embeds the image and the phrase to Vi and ti respectively. These features are used to induce a parametrization for spatial attention. Next, the decoder uses the visual attention map to predict the common concept. In addition, the decoder also predicts the common concept independently for each pair (i). For details, see Section 3.2.", "content_type": "figure", "figure_type": ""}, "1803.06506v3-Figure6-1.png": {"caption": "Figure 6. The figure shows how the quality of output heatmap changes with the alignment of the selected concept, predicted concept and the real entity to be grounded. For some sampled concept batch, the gray box refers to the chosen common concept, the red box refers to the predicted common concept and the blue box refers to the predicted independent concept. See section 10 for details about each row.", "content_type": "figure", "figure_type": "photograph(s)"}, "1803.06506v3-Table1-1.png": {"caption": "Table 1. Phrase-region related statistics for datasets used in evaluation. The numbers reflect the relative complexity of these datasets.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "What is the role of the Joint Attention Module in the model?", "answer": "The Joint Attention Module takes the embedded image and phrase features as input and uses them to induce a parameterization for spatial attention. This spatial attention map is then used by the decoder to predict the common concept.", "explanation": "The figure shows that the Joint Attention Module takes the embedded image features (V^i) and the embedded phrase features (t^i) as input. The output of the Joint Attention Module is a spatial attention map, which is used by the decoder to predict the common concept.\n\nFigure type: schematic", "reference": "1803.06506v3-Figure2-1.png"}, {"question": "How does the quality of the output heatmap change when the selected concept, predicted concept, and the real entity to be grounded are all aligned?", "answer": "When the selected concept, predicted concept, and the real entity to be grounded are all aligned, the generated heatmap produces a good localization of the phrase.", "explanation": "This is shown in the first row of Figure~\\ref{fig:fig2} with the concept \\emph{`headlight'} and \\emph{`picture'}. The heatmaps for both concepts are concentrated on the correct locations in the image.", "reference": "1803.06506v3-Figure6-1.png"}, {"question": "Why does the Semantic self-supervision model perform better on ReferIt (mask) compared to ReferIt (bbox), and how does this relate to the difference in performance between Visual Genome and Flickr30k datasets? ", "answer": "The Semantic self-supervision model performs better on ReferIt (mask) compared to ReferIt (bbox) because mask-based annotations are considered more precise and accurate for measuring localization performance than bounding boxes. Masks tightly encompass the specific region referred to by the phrase, whereas bounding boxes can include extraneous areas. \n\nThis relates to the difference in performance between Visual Genome and Flickr30k because both Visual Genome and ReferIt (mask) contain phrases that refer to very specific regions or non-salient objects. Precise localization is crucial for achieving high accuracy on these datasets. Flickr30k, on the other hand, annotates all bounding boxes referring to a phrase, leading to potentially less precise localization requirements and generally higher performance across methods. ", "explanation": "The table shows the accuracy of different models on various datasets. By comparing the performance of the Semantic self-supervision model on ReferIt (mask) and ReferIt (bbox), we can see the impact of annotation type on accuracy. Additionally, the passage highlights the importance of precise localization for datasets like Visual Genome and ReferIt, which explains the lower performance compared to Flickr30k.", "reference": "1803.06506v3-Table2-1.png"}, {"question": "How does the proposed method's attention map differ from the VGG16 feature map?", "answer": "The attention map generated by proposed method is able to localize regions that were weak or non-existent in the activations of the input maps, while the VGG16 feature map simply amplifies the activations present in VGG16 channels.", "explanation": "The figure shows that the model's attention map is more focused on specific regions of the image, such as the boy in purple and white, the drawings on the umbrella, and the surfer's face. This suggests that the model is able to learn a phrase-dependent attention map that is more relevant to the task at hand.", "reference": "1803.06506v3-Figure5-1.png"}, {"question": "Which loss type performs best when the concept batch size is 5k?", "answer": "Independent and common concept", "explanation": "The table shows that the independent and common concept loss type has the highest value (29.89) when the concept batch size is 5k.", "reference": "1803.06506v3-Table3-1.png"}, {"question": "How does the performance of the model vary with respect to the bounding box area and the similarity of the concept with ImageNet classes?", "answer": "The performance of the model increases with increasing bounding box area and decreases with increasing similarity of the concept with ImageNet classes.", "explanation": "The left plot in the figure shows that the performance of the model is positively correlated with the bounding box area, with a Pearson correlation coefficient of 0.85. This means that as the bounding box area increases, the performance of the model also increases. The right plot in the figure shows that the performance of the model is negatively correlated with the similarity of the concept with ImageNet classes, with a Pearson correlation coefficient of -0.02. This means that as the similarity of the concept with ImageNet classes increases, the performance of the model decreases.", "reference": "1803.06506v3-Figure3-1.png"}, {"question": "Which dataset would you expect to be the easiest for a model to localize phrases in, and why?", "answer": "Flickr30k is likely the easiest dataset for a model to localize phrases in. \nFlickr30k has the shortest average phrase length (2.3 words) and the lowest average noun count (1.2) per phrase. This suggests that the phrases in this dataset are simpler and often directly refer to single objects present in the image. This makes the localization task easier, almost approaching a weakly supervised setting where the object to be localized is explicitly named in the phrase.", "explanation": "Table 1 shows that Flickr30k has the shortest average phrase length (2.3 words) and the lowest average noun count (1.2) per phrase. This suggests that the phrases in this dataset are simpler and often directly refer to single objects present in the image. This makes the localization task easier, almost approaching a weakly supervised setting where the object to be localized is explicitly named in the phrase.", "reference": "1803.06506v3-Table1-1.png"}]}, "1704.04539v2": {"paper_id": "1704.04539v2", "all_figures": {"1704.04539v2-Figure3-1.png": {"caption": "Parsed AMR graph and alignments (dashed lines) for an Italian sentence, a Spanish sentence, a German sentences and a Chinese sentence.", "content_type": "figure", "figure_type": "schematic"}, "1704.04539v2-Figure4-1.png": {"caption": "Parsing examples in several languages involving common translational divergence phenomena: (a) contains a categorical divergence, (b) and (e) conflational divergences, (c) a structural divergence, (d) an head swapping and (f) a thematic divergence.", "content_type": "figure", "figure_type": "schematic"}, "1704.04539v2-Figure5-1.png": {"caption": "Linear regression lines for silver and fullcycle.", "content_type": "figure", "figure_type": "plot"}, "1704.04539v2-Table1-1.png": {"caption": "Table 1: Silver, gold and full-cycle Smatch scores for projection-based and MT-based systems.", "content_type": "table", "figure_type": "N/A"}, "1704.04539v2-Table2-1.png": {"caption": "Table 2: BLEU scores for Moses, Nematus and Google Translate (GT) on the (out-of-domain) LDC2015E86 test set", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "What is the relationship between the Silver Snatch and the Gold Snatch?", "answer": "The Silver Snatch and the Gold Snatch are positively correlated. As the Gold Snatch increases, the Silver Snatch also increases.", "explanation": "The figure shows two scatter plots, one for the Silver Snatch vs. the Gold Snatch and one for the Full-cycle Snatch vs. the Gold Snatch. The linear regression lines for both plots have a positive slope, indicating a positive correlation between the variables.", "reference": "1704.04539v2-Figure5-1.png"}, {"question": "Which system performs best on the IT domain in terms of full-cycle Smatch score, and how does its performance compare to the projection-based system in the same domain?", "answer": "The GT system achieves the highest full-cycle Smatch score in the IT domain with a score of 59. This is 14 points higher than the projection-based system in the same domain, which scored 45.", "explanation": "The table presents the Smatch scores for different systems across various domains, including IT. The \"Cycle\" column specifies the type of evaluation, with \"full-cycle\" referring to the complete parsing process. By looking at the row corresponding to the IT domain and the \"GT\" system under the \"full-cycle\" column, we can identify its score of 59. Comparing this to the score of 45 for the \"Projection\" system in the same column reveals the performance difference.", "reference": "1704.04539v2-Table1-1.png"}, {"question": "Which translation system performs the best and how does its performance compare to Google Translate (GT)? Is the comparison with GT completely fair? Explain your answer.", "answer": "According to Table 2, Moses achieves the highest BLEU scores among the listed translation systems (Moses, Nematus) across all language pairs. However, its performance still falls behind Google Translate (GT) in every case.\n\nThe comparison with GT might not be entirely fair because, as GT has the advantage of being trained on a significantly larger dataset. This suggests that GT's performance advantage might be partially due to its training data rather than solely its inherent capabilities.", "explanation": " Question: \n\nBased on Table 2 and the passage, which translation system performs the best and how does its performance compare to Google Translate (GT)? Is the comparison with GT completely fair? Explain your answer. \n\n## Answer: \n\nAccording to Table 2, Moses achieves the highest BLEU scores among the listed translation systems (Moses, Nematus) across all language pairs. However, its performance still falls behind Google Translate (GT) in every case. \n\nThe comparison with GT might not be entirely fair because, as mentioned in the passage, GT has the advantage of being trained on a significantly larger dataset. This suggests that GT's performance advantage might be partially due to its training data rather than solely its inherent capabilities.", "reference": "1704.04539v2-Table2-1.png"}, {"question": "What is the difference between the parsing trees for \"I like eating\" and \"I like grapes\"?", "answer": "The parsing tree for \"I like eating\" has only one argument, while the parsing tree for \"I like grapes\" has two arguments.", "explanation": "The parsing tree for \"I like eating\" shows that the verb \"like\" has only one argument, which is the pronoun \"I\". The parsing tree for \"I like grapes\" shows that the verb \"like\" has two arguments: the pronoun \"I\" and the noun \"grapes\". This difference in the number of arguments is an example of a thematic divergence.", "reference": "1704.04539v2-Figure4-1.png"}]}, "1803.04383v2": {"paper_id": "1803.04383v2", "all_figures": {"1803.04383v2-Figure5-1.png": {"caption": "Figure 5: The empirical CDFs of both groups are plotted along with the decision thresholds resulting from MaxUtil, DemParity, and EqOpt for a model with bank utilities set to (a) u\u2212 u+ = \u22124 and (b) u\u2212 u+ = \u221210. The threshold for active harm is displayed; in (a) DemParity causes active harm while in (b) it does not. EqOpt and MaxUtil never cause active harm.", "content_type": "figure", "figure_type": "plot"}, "1803.04383v2-Figure1-1.png": {"caption": "The above figure shows the outcome curve. The horizontal axis represents the selection rate for the population; the vertical axis represents the mean change in score. (a) depicts the full spectrum of outcome regimes, and colors indicate regions of active harm, relative harm, and no harm. In (b): a group that has much potential for gain, in (c): a group that has no potential for gain.", "content_type": "figure", "figure_type": "plot"}, "1803.04383v2-Figure6-1.png": {"caption": "Figure 6: The outcome and utility curves are plotted for both groups against the group selection rates. The relative positions of the utility maxima determine the position of the decision rule thresholds. We hold u\u2212 u+ = \u22124 as fixed.", "content_type": "figure", "figure_type": "plot"}, "1803.04383v2-Figure2-1.png": {"caption": "Figure 2: Both outcomes \u2206\u00b5 and institution utilities U can be plotted as a function of selection rate for one group. The maxima of the utility curves determine the selection rates resulting from various decision rules.", "content_type": "figure", "figure_type": "plot"}, "1803.04383v2-Figure4-1.png": {"caption": "Figure 4: The empirical payback rates as a function of credit score and CDF for both groups from the TransUnion TransRisk dataset.", "content_type": "figure", "figure_type": "plot"}, "1803.04383v2-Figure3-1.png": {"caption": "Figure 3: Considering the utility as a function of selection rates, fairness constraints correspond to restricting the optimization to one-dimensional curves. The DemParity (DP) constraint is a straight line with slope 1, while the EqOpt (EO) constraint is a curve given by the graph of G(A\u2192B). The derivatives considered throughout Section 6 are taken with respect to the selection rate \u03b2A (horizontal axis); projecting the EO and DP constraint curves to the horizontal axis recovers concave utility curves such as those shown in the lower panel of Figure 2 (where MaxUtil in is represented by a horizontal line through the MU optimal solution).", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "How do the outcome curves for the black and white groups differ?", "answer": "The outcome curve for the black group is generally lower than the outcome curve for the white group. This indicates that, for a given selection rate, the black group experiences a smaller change in credit score than the white group.", "explanation": "The outcome curves in the top panel of the figure show the average change in credit score for each group under different loaning rates. The black curve is consistently below the white curve, demonstrating the disparity in credit score changes between the two groups.", "reference": "1803.04383v2-Figure6-1.png"}, {"question": "How does the selection rate affect the expected outcome and institution utilities for different decision rules?", "answer": "The selection rate has a different effect on the expected outcome and institution utilities for different decision rules. For example, the maximum expected outcome is achieved at a higher selection rate for the MaxUtil rule than for the EqOpt rule.", "explanation": "The figure shows that the expected outcome and institution utilities are both functions of the selection rate. The different decision rules correspond to different curves in the figure, and the maximum of each curve corresponds to the selection rate that maximizes the corresponding objective function.", "reference": "1803.04383v2-Figure2-1.png"}, {"question": "Does the probability of repaying a debt increase or decrease with credit score?", "answer": "The probability of repaying a debt increases with credit score.", "explanation": "The figure shows that the empirical payback rates for both black and white groups increase with credit score. This is because individuals with higher credit scores are more likely to be able to repay their debts than individuals with lower credit scores.", "reference": "1803.04383v2-Figure4-1.png"}, {"question": "Which fairness criteria results in the highest loan approval rate for the Black group when the loss/profit ratio is -4?", "answer": "The maximum profit criteria ($\\maxprof$) results in the highest loan approval rate for the Black group when the loss/profit ratio is -4.", "explanation": "The figure shows the loan approval rates for different fairness criteria and different loss/profit ratios. The vertical lines represent the loan approval thresholds for each criteria. The higher the threshold, the more loans are approved. When the loss/profit ratio is -4, the $\\maxprof$ threshold is the highest for the Black group, indicating that it approves the most loans for this group.", "reference": "1803.04383v2-Figure5-1.png"}, {"question": "What does the outcome curve tell us about the relationship between selection rate and mean change in score?", "answer": "The outcome curve shows that the relationship between selection rate and mean change in score is complex and depends on the specific group being considered. For groups with high potential for gain, increasing the selection rate can lead to large increases in mean score. However, for groups with low potential for gain, increasing the selection rate can actually lead to decreases in mean score.", "explanation": "The figure shows that the outcome curve is divided into three regions: relative improvement, relative harm, and active harm. The relative improvement region is the area where increasing the selection rate leads to increases in mean score. The relative harm region is the area where increasing the selection rate leads to smaller increases in mean score than would be expected if the selection rate were lower. The active harm region is the area where increasing the selection rate leads to decreases in mean score.", "reference": "1803.04383v2-Figure1-1.png"}]}, "1704.07121v2": {"paper_id": "1704.07121v2", "all_figures": {"1704.07121v2-Figure1-1.png": {"caption": "Figure 1: An illustration of how the shortcuts in the Visual7W dataset (Zhu et al., 2016) should be remedied. In the original dataset, the correct answer \u201cA train\u201d is easily selected by a machine as it is far often used as the correct answer than the other decoy (negative) answers. (The numbers in the brackets are probability scores computed using eq. (2)). Our two procedures \u2014 QoU and IoU (cf. Sect. 4) \u2014 create alternative decoys such that both the correct answer and the decoys are highly likely by examining either the image or the question alone. In these cases, machines make mistakes unless they consider all information together. Thus, the alternative decoys suggested our procedures are better designed to gauge how well a learning algorithm can understand all information equally well.", "content_type": "figure", "figure_type": ""}, "1704.07121v2-Table2-1.png": {"caption": "Table 2: Summary of Visual QA datasets.", "content_type": "table", "figure_type": "N/A"}, "1704.07121v2-Table11-1.png": {"caption": "Table 11: Test accuracy (%) on Visual7W, comparing different embeddings for questions and answers. The results are reported for the IoU +QoU-decoys.", "content_type": "table", "figure_type": "N/A"}, "1704.07121v2-Table8-1.png": {"caption": "Table 8: Test accuracy (%) on COCOQA.", "content_type": "table", "figure_type": "N/A"}, "1704.07121v2-Table9-1.png": {"caption": "Table 9: Test accuracy (%) on VQA2-2017val.", "content_type": "table", "figure_type": "N/A"}, "1704.07121v2-Table10-1.png": {"caption": "Table 10: Test accuracy (%) on VQA2\u2212-2017val, which contains 134,813 triplets.", "content_type": "table", "figure_type": "N/A"}, "1704.07121v2-Table3-1.png": {"caption": "Table 3: Test accuracy (%) on Visual7W.", "content_type": "table", "figure_type": "N/A"}, "1704.07121v2-Table7-1.png": {"caption": "Table 7: Accuracy (%) on VQA\u2212-2014val, which contains 76,034 triplets.", "content_type": "table", "figure_type": "N/A"}, "1704.07121v2-Figure5-1.png": {"caption": "Illustration of attention-based Visual QA models.", "content_type": "figure", "figure_type": "schematic"}, "1704.07121v2-Table4-1.png": {"caption": "Table 4: Accuracy (%) on the validation set in VQA.", "content_type": "table", "figure_type": "N/A"}, "1704.07121v2-Table5-1.png": {"caption": "Table 5: Test accuracy (%) on qaVG.", "content_type": "table", "figure_type": "N/A"}, "1704.07121v2-Table6-1.png": {"caption": "Table 6: Using models trained on qaVG to improve Visual7W and VQA (Accuracy in %).", "content_type": "table", "figure_type": "N/A"}, "1704.07121v2-Table1-1.png": {"caption": "Table 1: Accuracy of selecting the right answers out of 4 choices (%) on the Visual QA task on Visual7W.", "content_type": "table", "figure_type": "N/A"}, "1704.07121v2-Table12-1.png": {"caption": "Table 12: Test accuracy (%) on Visual7W, comparing different random decoy strategies to our methods: (A) Orig + uniformly random decoys from unique correct answers, (B) Orig + weighted random decoys w.r.t. their frequencies, and All (Orig+IoU +QoU).", "content_type": "table", "figure_type": "N/A"}, "1704.07121v2-Figure4-1.png": {"caption": "Illustration of MLP-based models.", "content_type": "figure", "figure_type": "schematic"}, "1704.07121v2-Figure2-1.png": {"caption": "Figure 2: Example image-question-target triplets from Visual7W, VQA, and VG, together with our IoU-decoys (A, B, C.) and QoU-decoys (D, E, F). G is the target. Machine\u2019s selections are denoted by green ticks (correct) or red crosses (wrong).", "content_type": "figure", "figure_type": "photograph(s)"}, "1704.07121v2-Figure3-1.png": {"caption": "Figure 3: Ambiguous examples by our IoU-decoys (A, B, C) and QoU-decoys (D, E, F). G is the target. Ambiguous decoys F are marked.", "content_type": "figure", "figure_type": "photograph(s)"}, "1704.07121v2-Figure8-1.png": {"caption": "User interface for human evaluation on Visual7W (Orig decoys), where images are not blocked.", "content_type": "figure", "figure_type": "photograph"}, "1704.07121v2-Figure6-1.png": {"caption": "User interface for human evaluation on Visual7W (IoU-decoys+QoU-decoys).", "content_type": "figure", "figure_type": "photograph(s)"}, "1704.07121v2-Figure7-1.png": {"caption": "User interface for human evaluation on Visual7W (Orig decoys), where questions are blocked.", "content_type": "figure", "figure_type": "photograph"}}, "qa": [{"question": "Which model performed best on the \"All\" category of Visual7W, and how did its performance compare to human performance?", "answer": "The MLP-IQA model achieved the highest accuracy in the \"All\" category of Visual7W, with a score of 45.1%. However, this performance still falls significantly short of human performance, which stands at 84.1% for the same category.", "explanation": "The table displays the test accuracy of various models and humans on different categories of the Visual7W dataset. The \"All\" category likely refers to the combined performance across all question types. By looking at the final column of the table, we can identify that MLP-IQA achieved the highest accuracy among the models. Comparing this value to the human performance shown in the same column reveals the performance gap between the best model and humans.", "reference": "1704.07121v2-Table3-1.png"}, {"question": "Which method performs best overall on VQA-2014val, and how does its performance compare to human performance on the same dataset?", "answer": "MLP-IQA achieves the highest overall accuracy (46.5%) among the machine learning methods tested on VQA-2014val. However, this performance still falls short of human performance, which reaches an accuracy of 85.5% on the same dataset.", "explanation": "The table shows the accuracy of different methods on VQA$^-$-2014val, a dataset containing visual question-answering triplets. The \"All\" column presents the overall accuracy for each method. Comparing the values in this column reveals that MLP-IQA outperforms other methods like MLP-A, MLP-IA, and MLP-QA. However, when compared to the \"Human-IQA\" row, it becomes evident that even the best performing machine learning method still has a significant gap in accuracy compared to human performance.", "reference": "1704.07121v2-Table7-1.png"}, {"question": "Which model performs the best on qaVG when considering both image understanding (IU) and question understanding (QU) individually, and how does its performance compare to humans?", "answer": "MLP-QA performs the best when considering both IU and QU individually, achieving 89.3% accuracy on IU and 45.6% accuracy on QU. However, its combined performance (IU+QU) of 43.9% is still significantly lower than human performance, which stands at 82.5%.", "explanation": "The table shows the performance of different models on qaVG for IU, QU, and their combined performance (IU+QU). By looking at the individual scores for IU and QU, we can identify MLP-QA as the top performer in both aspects. However, the table also reveals a substantial gap between the best model and human performance, indicating that there is still room for improvement in developing models that can understand both images and questions as effectively as humans.", "reference": "1704.07121v2-Table5-1.png"}, {"question": "How can the shortcuts in the Visual7W dataset be remedied?", "answer": "The shortcuts in the Visual7W dataset can be remedied by creating alternative decoys that are more likely to be correct, based on either the image or the question alone. This forces the machine to consider all of the information together in order to select the correct answer.", "explanation": "The figure shows an example of how the shortcuts in the Visual7W dataset can be remedied. In the original dataset, the correct answer \"A train\" is much more likely to be chosen than the other decoy answers. However, by using the QU and IU procedures, alternative decoys can be created that are just as likely to be correct as the original answer. This forces the machine to consider all of the information together in order to select the correct answer. \n\nFigure type: Schematic", "reference": "1704.07121v2-Figure1-1.png"}, {"question": "Which dataset presents the biggest challenge for a model trying to distinguish true triplets from decoys, and why?", "answer": "The VQA dataset presents the biggest challenge.", "explanation": "The table shows that VQA has the highest number of decoys per triplet (17), compared to Visual7W (3) and VG (-). This means that for each real triplet in VQA, there are 17 other plausible, but incorrect, triplets created as decoys. This makes it significantly harder for a model to accurately identify the true triplet among the many similar options.", "reference": "1704.07121v2-Table2-1.png"}, {"question": "Which embedding method performed the best overall across all model architectures on the Visual7W dataset with IoU + QoU decoys? Was there a significant difference in performance compared to the other methods?", "answer": "The MLP-IQA model achieved the highest accuracy across all embedding methods, reaching 52.5% with GloVe, 51.4% with Translation embeddings, and 52.0% with word2vec. However, the passage notes that there was no significant difference in performance between the different embedding methods.", "explanation": "The table displays the test accuracy for various combinations of model architectures and embedding methods. By comparing the values in the table, we can identify the best performing method for each model and overall. The passage further clarifies that although MLP-IQA with GloVe achieved the highest accuracy, the difference compared to other methods is not statistically significant. This suggests that the choice of embedding method might not be a crucial factor for performance on this specific dataset and with these models.", "reference": "1704.07121v2-Table11-1.png"}, {"question": "Which model performs the best on COCOQA dataset when considering the combined accuracy of identifying irrelevant image-question pairs (IU) and irrelevant question-answer pairs (QU)? How does this compare to the performance of the model that only observes answers?", "answer": "The MLP-IQA model performs the best when considering the combined accuracy of identifying irrelevant image-question and question-answer pairs, achieving an accuracy of 75.9%. This is significantly higher than the MLP-A model, which only observes answers and achieves a combined accuracy of 26.6%, close to random performance.", "explanation": "Table 1 shows the test accuracy on COCOQA for different models with varying access to information. The \"IU+QU\" column represents the combined accuracy of identifying irrelevant pairs. By comparing the values in this column for different models, we can determine which model performs best in this task. The significant difference in performance between MLP-IQA and MLP-A highlights the importance of incorporating information from images and questions, in addition to answers, for effectively identifying irrelevant pairs.", "reference": "1704.07121v2-Table8-1.png"}, {"question": "On the VQAv2-2017 validation set, which model performs best when considering all three sources of information (images, questions, and answers) and how does its performance compare to the model that only uses answers?", "answer": "The model that performs best on VQAv2-2017 val when considering all three sources of information is MLP-IQA. It achieves an accuracy of 61.1% on the \\IU+\\QU -decoys metric, significantly outperforming the model that only uses answers (MLP-A) which achieves only 27.7% on the same metric. This demonstrates the importance of incorporating all available information for accurate prediction.", "explanation": "Table 1 presents the test accuracy of different models on the VQA2-2017val dataset. The \\IU+\\QU -decoys column represents the scenario where both incorrect image-question pairs and incorrect question-answer pairs are used as decoys. Comparing the performance of MLP-IQA (which uses images, questions, and answers) to MLP-A (which only uses answers) in this column reveals a significant difference in accuracy, highlighting the benefit of utilizing all information sources.", "reference": "1704.07121v2-Table9-1.png"}]}, "1704.00774v3": {"paper_id": "1704.00774v3", "all_figures": {"1704.00774v3-Figure1-1.png": {"caption": "PTB test PPL as K varies from 1 to 10000 (100 for gated networks). At K = 100, the r-RNTN with f mapping already closely approximates the much bigger RNTN, with little gain for bigger K , showing that dedicated matrices should be reserved for frequent words as hypothesized.", "content_type": "figure", "figure_type": "plot"}, "1704.00774v3-Table1-1.png": {"caption": "Table 1: Comparison of validation and test set perplexity for r-RNTNs with f mapping (K = 100 for PTB, K = 376 for text8) versus s-RNNs and m-RNN. r-RNTNs with the same H as corresponding s-RNNs significantly increase model capacity and performance with no computational cost. The RNTN was not run on text8 due to the number of parameters required.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "What is the effect of increasing K on the test PPL of the different models?", "answer": "The test PPL of all the models decreases as K increases.", "explanation": "The figure shows that the test PPL of all the models decreases as K increases. This is because increasing K allows the models to store more information about the input sequence, which leads to better predictions.", "reference": "1704.00774v3-Figure1-1.png"}]}, "1804.00863v3": {"paper_id": "1804.00863v3", "all_figures": {"1804.00863v3-Figure1-1.png": {"caption": "Frames from a video with a moving viewer (columns) comparing a re-synthesis using our novel deep appearance maps (DAMs) (top) and reflectance maps (RMs) (bottom) to a photo reference of a decorative sphere with a complex material under natural illumination (middle).", "content_type": "figure", "figure_type": "** photograph(s)"}, "1804.00863v3-Figure6-1.png": {"caption": "Pairs of error plots for each task. In each pair, the first is the old and the second the new view. Each curve is produced by sorting the DSSIM (less is better) of all samples in the data set. Blue colors are for point light illumination, red colors for environment maps. Dark hues are the competitor and light hues ours.", "content_type": "figure", "figure_type": "plot"}, "1804.00863v3-Table1-1.png": {"caption": "Quantitative results on synthetic data. Rows are different combination of tasks and methods (three applications, two view protocols, our two methods). Columns are different data. Error is measured as mean DSSIM across the data set (less is better).", "content_type": "table", "figure_type": "Table"}, "1804.00863v3-Figure7-1.png": {"caption": "Results of our DAM representation trained using stochastic gradient descent (1st column), our DAMs produced by our learning-to-learn network (2nd column) as well as a reference (3rd column) in a novel-view task.", "content_type": "figure", "figure_type": "photograph(s)"}, "1804.00863v3-Figure10-1.png": {"caption": "Relation of gloss and representation error.", "content_type": "figure", "figure_type": "plot"}, "1804.00863v3-Figure2-1.png": {"caption": "Reflectance and Appearance maps.", "content_type": "figure", "figure_type": "Photograph(s)"}, "1804.00863v3-Figure8-1.png": {"caption": "Failure modes for all three tasks: blurry highlights, split highlight segmentation and a overshooting DAM.", "content_type": "figure", "figure_type": "photograph(s)"}, "1804.00863v3-Figure12-1.png": {"caption": "Transfer of appearance from a real video sequence (left) to new 3D shapes (right).", "content_type": "figure", "figure_type": "photograph(s)"}, "1804.00863v3-Figure11-1.png": {"caption": "Real-world photo data and our reconstruction (from other views) of multiple materials (denoted M) in multiple illumination (L) from multiple views (V).", "content_type": "figure", "figure_type": "photograph(s)"}, "1804.00863v3-Figure9-1.png": {"caption": "Results of joint material segmentation and estimation for two samples (rows). In every part we show a re-synthesis, as well as two estimated materials and the resulting mask. The insets in the last row show that, while not all reflection details are reproduced, ours is free of color shifts around the highlights and mostly a lowfrequency approximation of the environment reflected.", "content_type": "figure", "figure_type": "photograph(s)"}, "1804.00863v3-Figure4-1.png": {"caption": "The four architectures used.", "content_type": "figure", "figure_type": "schematic"}, "1804.00863v3-Figure3-1.png": {"caption": "Different appearance processing tasks that we address using our deep appearance maps. a) The first task simply reproduces a given appearance, i. e., it maps from normal and view directions to RGB values using a NN. b) In a learning-to-learn task a network maps an image to a DAM representation. c) Finally, in the segmentation-and-estimation task, a network maps an image to multiple DAMs and multiple segmentation networks.", "content_type": "figure", "figure_type": "schematic"}, "1804.00863v3-Figure5-1.png": {"caption": "Two samples from four variants of our data set.", "content_type": "figure", "figure_type": "photograph(s)"}}, "qa": [{"question": "How does the appearance of the sphere differ between the re-synthesis using DAMs and the reference image?", "answer": "The sphere in the re-synthesis using DAMs appears to have a more even and consistent surface texture than the reference image.", "explanation": " The images in the top row of the figure show the re-synthesis using DAMs, while the images in the middle row show the reference image. By comparing the two, it can be seen that the DAMs-based re-synthesis results in a smoother and more uniform appearance of the sphere.", "reference": "1804.00863v3-Figure1-1.png"}, {"question": "Which method performs best for the \"Representation\" task when the view is \"Novel\"?", "answer": "The \"OUR\" method performs best for the \"Representation\" task when the view is \"Novel\".", "explanation": "The table shows that the \"OUR\" method has a lower error rate (0.144) than the \"RM++\" method (0.181) for the \"Representation\" task when the view is \"Novel\".", "reference": "1804.00863v3-Table1-1.png"}, {"question": "How do the reconstructions compare to the original samples?", "answer": "The reconstructions are very similar to the original samples.", "explanation": "The figure shows the original samples in the top row and the reconstructions in the bottom row. The reconstructions are very close to the original samples, indicating that the method is able to accurately reconstruct the objects.", "reference": "1804.00863v3-Figure11-1.png"}, {"question": "What is the difference between the representation module and the learning-to-learn module?", "answer": "The representation module takes an input image and outputs a feature representation. The learning-to-learn module takes a set of features and learns how to segment the image.", "explanation": "The figure shows that the representation module has a fixed number of channels, while the learning-to-learn module has a variable number of channels. This suggests that the learning-to-learn module is more flexible and can adapt to different types of images.", "reference": "1804.00863v3-Figure4-1.png"}, {"question": "What is the difference between the representation task and the learning-to-learn task?", "answer": "The representation task takes an appearance as input and outputs an RGB value, while the learning-to-learn task takes an image as input and outputs a DAM representation.", "explanation": "The figure shows that the representation task takes a normal and view direction as input, while the learning-to-learn task takes an image as input.", "reference": "1804.00863v3-Figure3-1.png"}, {"question": "What is the relationship between gloss and representation error?", "answer": "The representation error decreases as the gloss decreases.", "explanation": "The figure shows that the DSSIM (Deep Structural Similarity Index Measure) for the test, total, and train sets decreases as the gloss of the sphere decreases. This means that the representation error is lower for spheres with lower gloss.", "reference": "1804.00863v3-Figure10-1.png"}]}, "1804.01429v3": {"paper_id": "1804.01429v3", "all_figures": {"1804.01429v3-Figure1-1.png": {"caption": "Figure 1. Example agent-in-place actions and segmentation maps. Different colors represent different places. We zoom in to the agents performing the actions for clarity. An agent-in-place action is represented as <agent, action, place>. Same colors indicate same place types (e.g., green for lawn, blue for walkway, etc.).", "content_type": "figure", "figure_type": "photograph(s)"}, "1804.01429v3-Table1-1.png": {"caption": "The Path from Traditional 3D ConvNets to our Methods. B/L1 and B/L2 are baseline models with raw pixels and and ConcateMap as input, respectively. For our proposed models: V1 uses segmentation maps to extract place-based feature descriptions only. V3 applies distance-based place discretization for some places. Both V1 and V3 use a FC layer to aggregate place features; V2 and V4 uses topological feature aggregation. H and FPS2 indicates using higher resolutions and FPS, and MF means using more filters per conv layer. Besides our baselines, we also compare LIVR with two state-of-the-art action recognition methods: [50, 43].", "content_type": "table", "figure_type": "table"}, "1804.01429v3-Figure2-1.png": {"caption": "Figure 2. Framework of LIVR. Given the segmentation map, we decompose the semantic features into different places and extract place-based feature descriptions individually, then dynamically aggregate them at inference time according to the topology of the scene. denotes the masking operation for spatial decomposition. \"NN\" stands for neural network.", "content_type": "figure", "figure_type": "schematic"}, "1804.01429v3-Figure3-1.png": {"caption": "(a) illustrates distance-based place discretization. We segment the bit mask representing a given semantic class based on the distance transform of a second class, to explicitly represent the spatial-temporal order of moving agents which captures the moving direction w.r.t. that place. For example, this figure shows the partition of the walkway map into components that are \"far,\" \"middle\" and \"near\" to the porch class. We use move toward (home) action as an example: we first observe the person on the part of far and middle (distance), and after some time, the person appears in the part of near. We use orange ellipses to highlight person parts. (b) illustrates the motivation behind topological feature aggregation. We seek a representation that covers the entire body of the person, which can be accomplished by aggregating the masked images from places that are connected to walkway.", "content_type": "figure", "figure_type": "Schematic"}, "1804.01429v3-Figure8-1.png": {"caption": "Figure 8. Qualitative examples: The predicted confidences of groundtruth actions using different methods. We use 3 frames to visualize a motion and orange ellipses to highlight moving agents.", "content_type": "figure", "figure_type": "photograph(s)"}, "1804.01429v3-Figure7-1.png": {"caption": "Figure 7. Per-category average precision of the baseline 3 and our methods on unseen scenes. The blue dashed box highlights actions which require modeling moving directions. We observe that the proposed place-based feature descriptions (PD), distance-based place discretization (DD) and topological feature aggregation (Topo-Agg) significantly improve the average precision on almost all action categories. FC-Agg stands for using a FC layer to aggregate place descriptions.", "content_type": "figure", "figure_type": "plot"}, "1804.01429v3-Figure4-1.png": {"caption": "Figure 4. Layout-induced Video Representation Network: The dashed blue box indicates a shared 3D ConvNet to extract lowlevel features. We utilize the segmentation maps to decompose features into different places, and the solid blue boxes indicate that we train place-based models to extract place-based feature descriptions. When relevant to the activities of interest, we conduct distance-based place discretization to model moving directions; finally, we leverage the connectivity of places to aggregate the place-based feature descriptions at inference level.", "content_type": "figure", "figure_type": "schematic"}, "1804.01429v3-Figure9-1.png": {"caption": "Evaluation: (a) The effect of extracting place-based feature descriptions (PD) at different levels using different variants of our proposed model. (b) Different strategies for distance-based place discretization. (c) Different feature aggregation approaches on unseen scenes. (d) Performance of LIVR using groundtruth (GT) and automatically generated (Auto) segmentation map.", "content_type": "figure", "figure_type": "plot"}, "1804.01429v3-Figure10-1.png": {"caption": "Figure 10. Process of Automatically Generating Segmentation Maps. (a) is the input camera image. (b) is the output of normalized cut method. (d) is the set of all videos captured by this camera. (e) shows the heatmaps we obtained by analyzing the patterns of moving objects from the videos. (c) is the generated segmentation map. (f) is the ground truth map.", "content_type": "figure", "figure_type": "photograph(s)"}, "1804.01429v3-Figure5-1.png": {"caption": "The process of distance-based place discretization.", "content_type": "figure", "figure_type": "schematic"}, "1804.01429v3-Figure6-1.png": {"caption": "Topological feature aggregation which utilizes the connectivities between different places in a scene to guide the connections between the extracted place-based feature descriptions and the prediction labels. For clear visualization, we use the source places as porch in (b) with h = 1. The X indicates we aggregate features from a certain place to infer the probability of an action.", "content_type": "figure", "figure_type": "Schematic"}}, "qa": [{"question": "What is the difference between an \"agent-in-place\" action and a generic action category?", "answer": "An agent-in-place action is an action that is performed by an agent in a specific place, while a generic action category is a more general category of action that does not specify the place where the action is performed.", "explanation": "The figure shows examples of agent-in-place actions, such as \"vehicle, move away (home), driveway\" and \"person, move along, sidewalk.\" These actions are specific to the places where they are performed. In contrast, a generic action category, such as \"walking\" or \"running,\" does not specify the place where the action is performed.", "reference": "1804.01429v3-Figure1-1.png"}, {"question": "What are the different types of features used by the Layout-induced Video Representation Network?", "answer": "The Layout-induced Video Representation Network uses three types of features: place-based features, distance-based features, and topological features.", "explanation": "The figure shows the different types of features used by the network. Place-based features are extracted by place-based models (NN-sidewalk, NN-street, NN-porch) and describe the activities occurring in different places. Distance-based features are extracted by distance-based place discretization and model the moving directions of agents. Topological features are extracted by topological feature aggregation and capture the connectivity of places.", "reference": "1804.01429v3-Figure4-1.png"}, {"question": "What is the role of the 3D ConvNet in the distance-based place discretization process?", "answer": "The 3D ConvNet is used to extract features from the input images. These features are then used to generate place-based feature descriptions.", "explanation": "The figure shows that the 3D ConvNet is applied to the input images to extract features. These features are then concatenated and fed into another 3D ConvNet to generate place-based feature descriptions.", "reference": "1804.01429v3-Figure5-1.png"}, {"question": "How does the LIVR framework decompose semantic features into different places?", "answer": "The LIVR framework decomposes semantic features into different places by utilizing bitmaps encoded with the semantic labels of places. This decomposition encourages the network to learn features of generic place-based motion patterns that are independent of scene layouts.", "explanation": "The figure shows how the semantic features are decomposed into different places using bitmaps. The bitmaps are used to mask the video representations, which results in place-based feature descriptions.", "reference": "1804.01429v3-Figure2-1.png"}, {"question": "Why does the proposed method outperform the baselines for the action \"<person, move toward (home), walkway>\"?", "answer": "The proposed method outperforms the baselines for the action \"<person, move toward (home), walkway>\" because it is better at modeling moving directions.", "explanation": "The figure shows that the proposed method has a higher predicted probability for the groundtruth action than the baselines. This suggests that the proposed method is better at understanding the direction of movement of the person in the video.", "reference": "1804.01429v3-Figure8-1.png"}, {"question": "Which actions are most challenging for the network to recognize, and how do the proposed methods improve the performance on these actions?", "answer": "The actions that are most challenging for the network to recognize are those that include moving directions, such as \"person, move toward (home)\", \"person, move away (home)\", and \"vehicle, move toward (person)\". The proposed methods, distance-based place discretization (DD) and topological feature aggregation (Topo-Agg), significantly improve the average precision on almost all action categories, especially those that are more challenging and are associated with moving directions.", "explanation": "The figure shows the average precision for each action category, and the blue dashed box highlights the actions that include moving directions. The bars corresponding to the proposed methods (PD+FC-Agg, PD+Topo-Agg, and PD+DD+Topo-Agg) are consistently higher than the baseline method (B/L2) for these actions. This suggests that the proposed methods are more effective at recognizing actions that involve moving directions.", "reference": "1804.01429v3-Figure7-1.png"}]}, "1811.02721v3": {"paper_id": "1811.02721v3", "all_figures": {"1811.02721v3-Table4-1.png": {"caption": "Table 4: Comparison of TCP/IP links", "content_type": "table", "figure_type": "N/A"}, "1811.02721v3-Table5-1.png": {"caption": "Table 5: Header overhead with 6LoWPAN fragmentation", "content_type": "table", "figure_type": "N/A"}, "1811.02721v3-Figure9-1.png": {"caption": "Effect of batching on power consumption", "content_type": "figure", "figure_type": "plot"}, "1811.02721v3-Figure10-1.png": {"caption": "Performance with injected packet loss", "content_type": "figure", "figure_type": "plot"}, "1811.02721v3-Table1-1.png": {"caption": "Table 1: Impact of techniques to run full-scale TCP in LLNs", "content_type": "table", "figure_type": "N/A"}, "1811.02721v3-Figure3-1.png": {"caption": "TCP goodput over one IEEE 802.15.4 hop", "content_type": "figure", "figure_type": "plot"}, "1811.02721v3-Figure13-1.png": {"caption": "Hamilton-based ultrasonic anemometer", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.02721v3-Figure8-1.png": {"caption": "Goodput: CoAP vs. HTTP/TCP", "content_type": "figure", "figure_type": "plot"}, "1811.02721v3-Figure7-1.png": {"caption": "Latency of web request: CoAP vs. HTTP/TCP", "content_type": "figure", "figure_type": "plot"}, "1811.02721v3-Figure12-1.png": {"caption": "CoAP, CoCoA, and TCP with four competing flows", "content_type": "figure", "figure_type": "plot"}, "1811.02721v3-Figure5-1.png": {"caption": "Effect of varying time between link-layer retransmissions. Reported \u201csegment loss\u201d is the loss rate of TCP segments, not individual IEEE 802.15.4 frames. It includes only losses not masked by link-layer retries.", "content_type": "figure", "figure_type": "plot"}, "1811.02721v3-Table6-1.png": {"caption": "Table 6: Comparison of TCPlp to existing TCP implementations used in network studies over IEEE 802.15.4 networks.7 Goodput figures obtained by reading graphs in the original paper (rather than stated numbers) are marked with the \u2248 symbol.", "content_type": "table", "figure_type": "N/A"}, "1811.02721v3-Table2-1.png": {"caption": "Table 2: Comparison of the platforms we used (Hamilton and Firestorm) to TelosB and Raspberry Pi", "content_type": "table", "figure_type": "N/A"}, "1811.02721v3-Table7-1.png": {"caption": "Table 7: Performance in the testbed over a full day, averaged over multiple trials. The ideal protocol (\u00a78.2.2) would have a radio DC of\u2248 0.63%\u20130.70% under similarly lossy conditions.", "content_type": "table", "figure_type": "N/A"}, "1811.02721v3-Figure11-1.png": {"caption": "Radio duty cycle of TCP and CoAP in a lossy wireless environment, in one representative trial (losses are caused by natural human activity)", "content_type": "figure", "figure_type": "plot"}, "1811.02721v3-Figure6-1.png": {"caption": "Congestion behavior of TCP over IEEE 802.15.4", "content_type": "figure", "figure_type": "plot"}, "1811.02721v3-Table8-1.png": {"caption": "Table 8: Memory usage of TCPlp on TinyOS. Our implementation of TCPlp spans three modules: (1) protocol implementation, (2) event scheduler that injects callbacks into userspace, and (3) userland library.", "content_type": "table", "figure_type": "N/A"}, "1811.02721v3-Table9-1.png": {"caption": "Table 9: Comparison of core features among embedded TCP stacks: uIP (Contiki), BLIP (TinyOS), GNRC (RIOT), and", "content_type": "table", "figure_type": "N/A"}, "1811.02721v3-Figure1-1.png": {"caption": "Snapshot of uplink routes in OpenThread topology at transmission power of -8 dBm (5 hops). Node 1 is the border router with Internet connectivity.", "content_type": "figure", "figure_type": "schematic"}, "1811.02721v3-Table3-1.png": {"caption": "Table 3: Memory usage of TCPlp on RIOT OS. We also include RIOT\u2019s posix_sockets module, used by TCPlp to provide a Unix-like interface.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "How does batching affect the radio duty cycle and CPU duty cycle?", "answer": "Batching reduces both the radio duty cycle and CPU duty cycle.", "explanation": "The figure shows that the radio duty cycle and CPU duty cycle are both lower when batching is used, compared to when no batching is used. This is because batching allows the device to send and receive data in larger chunks, which reduces the number of times the radio and CPU need to be activated.", "reference": "1811.02721v3-Figure9-1.png"}, {"question": "Which technique was most effective at reducing memory consumption in both send and receive buffers?", "answer": "The \"Resource Constraints\" challenge was addressed with two techniques: \"Zero-Copy Send\" and \"In-Place Reass.\" The first led to a 50% reduction in send buffer memory usage, while the second achieved a 38% reduction in receive buffer memory. Therefore, Zero-Copy Send was slightly more effective in reducing overall memory consumption.", "explanation": "The table explicitly lists the observed improvements for each technique applied to specific challenges. By comparing the percentage reductions in memory usage for both send and receive buffers, we can determine which technique had a greater overall impact on memory consumption.", "reference": "1811.02721v3-Table1-1.png"}, {"question": "Based on Table 1 and the passage, why does TCP perform poorly on IEEE 802.15.4 networks compared to other network types listed? ", "answer": "TCP performs poorly on IEEE 802.15.4 networks because the Maximum Transmission Unit (MTU) for these networks is significantly smaller than other network types. This small MTU size results in a high percentage of overhead due to the TCP/IP headers, exceeding 50%. ", "explanation": "Table 1 shows that the MTU for 802.15.4 networks is only 104-116 bytes, while other networks like Fast Ethernet and Wi-Fi have an MTU of 1500 bytes. The passage explains that TCP/IP headers consume a significant portion of the available MTU in 802.15.4 frames. This high overhead percentage leads to inefficient data transmission and consequently, poor TCP performance.", "reference": "1811.02721v3-Table4-1.png"}, {"question": "Why is relying on fragmentation effective for reducing header overhead?", "answer": "Relying on fragmentation is effective because the TCP/IP headers are only included in the first fragment, not in subsequent fragments. This significantly reduces the overhead in later fragments.", "explanation": "Table 1 shows the header overhead for different protocols with 6LoWPAN fragmentation. While the first frame carries the full overhead of all headers (38-107 bytes), subsequent fragments only have the overhead of 6LoWPAN and 802.15.4 headers (16-35 bytes). This reduction in overhead improves efficiency by utilizing less bandwidth for header information.", "reference": "1811.02721v3-Table5-1.png"}, {"question": "How does varying the buffer size affect TCP goodput?", "answer": "Increasing the buffer size generally leads to increased TCP goodput, but only up to a certain point.", "explanation": "The figure shows that TCP goodput increases as the buffer size increases, but then plateaus. This is because a larger buffer allows for more data to be sent before the sender has to wait for an acknowledgement from the receiver. However, if the buffer is too large, it can lead to increased latency and decreased performance.", "reference": "1811.02721v3-Figure3-1.png"}, {"question": "What is the function of the Hamilton-based PCB in the ultrasonic anemometer?", "answer": "The Hamilton-based PCB is the electronic control board of the anemometer. It houses the microcontroller, sensors, and other electronic components that are necessary for the anemometer to function.", "explanation": "The photograph shows the Hamilton-based PCB with its various electronic components.", "reference": "1811.02721v3-Figure13-1.png"}, {"question": "What is the difference in response time between CoAP and HTTP for a response size of 50 KiB?", "answer": "The difference in response time between CoAP and HTTP for a response size of 50 KiB is approximately 20 seconds.", "explanation": "The figure shows the response time for CoAP and HTTP for different response sizes. For a response size of 50 KiB, the boxplot for CoAP shows a median response time of approximately 20 milliseconds, while the boxplot for HTTP shows a median response time of approximately 40 milliseconds.", "reference": "1811.02721v3-Figure8-1.png"}, {"question": "How does the maximum link delay affect the segment loss rate and goodput in a TCP connection with one hop?", "answer": "As the maximum link delay increases, the segment loss rate increases and the goodput decreases.", "explanation": "In Figure (a), we can see that the segment loss rate increases as the maximum link delay increases. This is because the longer the delay, the more likely it is that a segment will be lost. Additionally, the goodput decreases as the maximum link delay increases. This is because the longer the delay, the less data can be transmitted in a given amount of time.", "reference": "1811.02721v3-Figure5-1.png"}, {"question": "What protocol has a higher radio duty cycle in the first 7 hours of the trial?", "answer": "TCP", "explanation": "The green line, which represents TCP, is higher than the blue line, which represents CoAP, for the first 7 hours of the trial.", "reference": "1811.02721v3-Figure11-1.png"}, {"question": "How does the maximum link delay affect the number of TCP timeouts and fast retransmissions?", "answer": "The number of TCP timeouts and fast retransmissions decreases as the maximum link delay increases.", "explanation": "The figure shows that the number of timeouts and fast retransmissions decreases as the maximum link delay increases. This is because, with a longer link delay, there is more time for the sender to receive an acknowledgment before retransmitting the packet.", "reference": "1811.02721v3-Figure6-1.png"}, {"question": "Which module of TCPlp consumes the most memory in the active RAM on TinyOS, and how much memory does it utilize?", "answer": "The protocol implementation module consumes the most memory in the active RAM on TinyOS, utilizing 488 bytes.", "explanation": "Table 2 provides a breakdown of \\sys{}'s memory usage on TinyOS, categorized by module and memory type. Looking at the \"RAM (Active)\" row, we can compare the memory consumption of each module. The \"Protocol\" column shows the highest value of 488 bytes, indicating that the protocol implementation module uses the most active RAM compared to the event scheduler and user library modules.", "reference": "1811.02721v3-Table8-1.png"}, {"question": "How does the reliability of CoAP compare to TCPlp and what potential factors contribute to this difference?", "answer": "Table 1 shows that CoAP has slightly higher reliability (99.5%) compared to TCPlp (99.3%). While both protocols perform well, this difference could be attributed to several factors, including:\n\nRetransmission mechanisms: CoAP employs a built-in retransmission mechanism for lost packets, while TCPlp relies on the underlying network layer for retransmissions. This could give CoAP an edge in recovering lost packets and achieving higher reliability.\nCongestion control: CoAP includes mechanisms to adapt to network congestion, potentially reducing packet loss and improving reliability.\nPacket size: CoAP typically uses smaller packets compared to TCPlp. Smaller packets are less prone to loss in wireless networks, potentially contributing to CoAP's slightly higher reliability.", "explanation": "The table directly provides the reliability percentages for both CoAP and \\sys{}, allowing for a direct comparison. Additionally, the information about radio duty cycle and CPU duty cycle can be used to infer possible reasons for the difference in reliability. While the table doesn't explicitly state the contributing factors, it provides clues that, when combined with knowledge about the protocols themselves, allow for a reasoned explanation.", "reference": "1811.02721v3-Table7-1.png"}, {"question": "How does the memory usage of the RIOT OS posix_sockets module compare to the memory used by the protocol and socket layer combined, for both active and passive connections?", "answer": "The posix_sockets module consistently uses less memory than the combined usage of the protocol and socket layer. For an active connection, it requires about 5468 B compared to 19972 B + 6216 B = 26188 B for the other layers. Similarly, for a passive connection, it uses 5468 B compared to 19972 B + 6216 B = 26188 B for the other layers.", "explanation": "Table 1 provides the memory usage breakdown for `sys` on RIOT OS, including the individual contributions of the protocol, socket layer, and `posix_sockets` module. By comparing the values in the table, we can see that the `posix_sockets` module, while providing a Unix-like interface, consumes less memory than the combined total of the protocol and socket layer for both active and passive connections. This information supports the passage's claim that `sys` fits well within available memory despite its advanced features.", "reference": "1811.02721v3-Table3-1.png"}, {"question": "Which TCP stack provides the most complete implementation of core TCP features, and which stack lacks the most features?", "answer": "The TCP stack presented in this paper (TCPlp) provides the most complete implementation of core TCP features, including flow control, congestion control, RTT estimation, MSS option, OOO reassembly, and various advanced features like timestamps and selective ACKs. In contrast, BLIP lacks the most features, as it does not implement congestion control, RTT estimation, or several other functionalities present in other stacks.", "explanation": "The table directly compares the feature sets of different embedded TCP stacks. By analyzing the \"Yes\" and \"No\" entries, we can identify which functionalities are present or absent in each stack. The passage also provides additional information, highlighting the specific limitations of uIP and BLIP. Combining the table and passage allows us to comprehensively assess the completeness of each stack's implementation and identify the best and worst options in terms of feature richness.", "reference": "1811.02721v3-Table9-1.png"}, {"question": "How many hops are there between the Hamilton and the Internet?", "answer": "5 hops", "explanation": "The caption states that the figure shows a snapshot of uplink routes in an OpenThread topology at a transmission power of -8 dBm (5 hops). This means that there are 5 hops between the Hamilton and the Internet.", "reference": "1811.02721v3-Figure1-1.png"}]}, "1704.07854v4": {"paper_id": "1704.07854v4", "all_figures": {"1704.07854v4-Figure4-1.png": {"caption": "Ablation study for our method. We evaluated the average loss for a test data set of the different data sets discussed in the text. Left: numeric values, again as a graph (center), and a graph of the loss values normalized w.r.t. initial surface loss on the right. Our method achieves very significant and consistent reductions across the very different data sets.", "content_type": "figure", "figure_type": "plot"}, "1704.07854v4-Figure5-1.png": {"caption": "An example of our deformation learning approach. F. l. t. r.: the result after applying weighted deformations, and with an additional deformation from a trained deformation network. Both show the reference surface in light brown in the background, which is shown again for comparison on the right. The inferred deformation manages to reconstruct large parts of the two central arms which can not be recovered by any weighting of the pre-computed deformations (left).", "content_type": "figure", "figure_type": "schematic"}, "1704.07854v4-Table2-1.png": {"caption": "Overview of our 2D and 4D simulation and machine learning setups. Timings were measured on a Xeon E5-1630 with 3.7GHz. Res, SDF and Defo denote resolutions for simulation, training, and the NN deformation, respectively; Sim and Train denote simulation and training runtimes. sp, sd, \u03b31, \u03b32 denote training steps for parameters, training steps for deformation, and regularization parameters, respectively.", "content_type": "table", "figure_type": "** Table"}, "1704.07854v4-Figure6-1.png": {"caption": "Eight examples of the learned deformations for a flat initial surface. For each pair the reference surfaces are depicted in yellow and the deformed results in blue. The trained model learns to recover a significant portion of the large-scale surface motion over the whole parameters space.", "content_type": "figure", "figure_type": "photograph(s)"}, "1704.07854v4-Figure7-1.png": {"caption": "Each pair shows the reference surface in transparent brown, and in purple on the left the deformed surface after applying the precomputed deformations. These surfaces often significantly deviate from the brown target, i.e. the visible purple regions indicates misalignments. In cyan on the right, our final surfaces based on the inferred deformation field. These deformed surface match the target surface closely, and even recover thin features such as the central peak in (c).", "content_type": "figure", "figure_type": "schematic"}, "1704.07854v4-Figure11-1.png": {"caption": "This figure illustrates the forward advection process: Both deformation vsum and the correction vinv are initially located at x\u2032 in (a). vinv is applied to yield the correct deformation at location x, as shown in (b).", "content_type": "figure", "figure_type": "schematic"}, "1704.07854v4-Figure1-1.png": {"caption": "Three liquid surfaces after 60 time steps differing only by \u00b1\u03b5 in initial conditions. Even this initially very small difference can lead to large differences in surface position, e.g., the sheet in b) strongly curving downward.", "content_type": "figure", "figure_type": "Schematic"}, "1704.07854v4-Figure15-1.png": {"caption": "Training with different gradient approximations: validation loss with a simplified advection (red), and the correct gradient from forward advection (green). The simplified version does not converge.", "content_type": "figure", "figure_type": "plot"}, "1704.07854v4-Figure14-1.png": {"caption": "Loss during training both for parameter learning and deformation learning. In yellow we show the loss for the current sample, while the dark line displays the loss evaluated on the validation set.", "content_type": "figure", "figure_type": "plot"}, "1704.07854v4-Figure8-1.png": {"caption": "a) Liquid drop data set example: several 3D surfaces of a single simulation data point in \u03c6\u03b1. b) An example splash generated by our method, visualized interactively.", "content_type": "figure", "figure_type": "schematic"}, "1704.07854v4-Figure2-1.png": {"caption": "This illustration gives an overview of our algorithm. It works in two stages, a weighting and refinement stage, each of which employs a neural network to infer a weighting function and a dense deformation field, respectively.", "content_type": "figure", "figure_type": "schematic"}, "1704.07854v4-Figure16-1.png": {"caption": "Different example surfaces from the 2D parameter space of Fig. 13. From left to right: surfaces reconstructed with PCA (purple), weighted deformations using a trained parameter network (pink), the reference surfaces (brown), and on the far right the output of our full method with a deformation network (teal). Note that none of the other methods is able to reconstruct both arms of liquid in the first row, as well as the left sheet in the bottom row. The reference surfaces are shown in light brown in the background for each version.", "content_type": "figure", "figure_type": "schematic"}, "1704.07854v4-Figure13-1.png": {"caption": "The left image illustrates the initial conditions of our two dimensional parameter space setup. It consists of a set of two-dimensional liquid simulations, which vary the position of the liquid drop along x as \u03b11, and its size as \u03b12. The right half shows the data used for training at t = 30. Note the significant amount of variance in positions of small scale features such as the thin sheets. Both images show only a subset of the whole data.", "content_type": "figure", "figure_type": "Schematic"}, "1704.07854v4-Figure10-1.png": {"caption": "Illustration of our deformation alignment procedure.", "content_type": "figure", "figure_type": "schematic"}, "1704.07854v4-Figure9-1.png": {"caption": "a) Three example configurations from our stairs data set. b) The interactive version of the stair setup shown in the demo app. Notice how the flow around the central wall obstacle changes. As the wall is shifted right, the flow increases corresonpondingly.", "content_type": "figure", "figure_type": "photograph(s)"}, "1704.07854v4-Table1-1.png": {"caption": "Performance and setup details of our 4D data sets in the Android app measured on a Samsung S8 device. The \u201ddefo. align\u201d step contains alignment and rescaling of the deformations.", "content_type": "table", "figure_type": "table"}, "1704.07854v4-Figure18-1.png": {"caption": "Two frames generated with our approach (left) and with a direct SDF interpolation using a similar amount of overall memory (right). The latter looses the inital drop shape (a), and removes all splash detail (b). In addition, the direct SDF interpolation leads to strong ghosting artifacts with four repeated patterns.", "content_type": "figure", "figure_type": "other"}, "1704.07854v4-Figure17-1.png": {"caption": "Additional examples of the influence of the deformation network for three different time steps (t = 1, 4, 8 from top to bottom). Each pair shows the reference surface in transparent brown, and in purple on the left the deformed surface after applying the precomputed deformations. These surfaces often significantly deviate from the brown target, i.e. the visible purple regions indicates misalignments. In cyan on the right, our final surfaces based on the inferred deformation field. These deformed surface often match the target surface much more closely.", "content_type": "figure", "figure_type": "schematic"}, "1704.07854v4-Figure3-1.png": {"caption": "An example of our parameter learning approach. F.l.t.r.: the initial undeformed surface, the surface deformed by the weighting from the trained parameter network, and the reference surface only. The reference surface is shown again in the middle in light brown for comparison. The weighted deformations especially match the left liquid arm well, while there are not enough degrees of freedom in the pre-computed deformations to independently raise the surface on the right side.", "content_type": "figure", "figure_type": "schematic"}, "1704.07854v4-Figure12-1.png": {"caption": "Figure 12: Overview of our two neural networks. While the parameter network (left) is simple, consisting of two fully connected layers, its cost functions allows it to learn how to apply multiple long-range, non-linear deformation fields. The deformation network (right), which makes use of several de-convolutional layers, instead learns to generate dense deformation fields to refine the final surface.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "What does the parameter network do to the initial surface?", "answer": "The parameter network weights the initial surface, causing it to deform.", "explanation": "The figure shows three different surfaces: the initial surface, the surface deformed by the parameter network, and the reference surface. The deformed surface is closer in shape to the reference surface than the initial surface, which suggests that the parameter network is able to learn the desired shape of the surface.", "reference": "1704.07854v4-Figure3-1.png"}, {"question": "How do the parameter network and the deformation network differ in terms of complexity and function?", "answer": "The parameter network is a simple structure with two fully connected layers, while the deformation network is more complex and contains two fully connected layers followed by two or more four-dimensional de-convolution layers. The parameter network learns how to apply multiple long-range, non-linear deformation fields, while the deformation network learns to generate dense deformation fields to refine the final surface.", "explanation": "The figure shows the two networks side-by-side. The parameter network is on the left and is shown as a simple structure with two layers. The deformation network is on the right and is shown as a more complex structure with several layers. The figure also includes annotations that describe the function of each network.", "reference": "1704.07854v4-Figure12-1.png"}, {"question": "Which gradient approximation method leads to a more stable and lower loss value during training?", "answer": "The corrected gradient method leads to a more stable and lower loss value during training.", "explanation": "The figure shows the validation loss for two different gradient approximation methods: naive gradient and corrected gradient. The corrected gradient method results in a much lower and more stable loss value than the naive gradient method.", "reference": "1704.07854v4-Figure15-1.png"}, {"question": "How does the flow of water change as the central wall obstacle is shifted to the right?", "answer": "The flow of water increases as the central wall obstacle is shifted to the right.", "explanation": "The figure shows that the flow of water is more constricted when the central wall obstacle is in the center of the stairs. As the wall is shifted to the right, the flow of water has more space to move through, which results in an increase in flow.", "reference": "1704.07854v4-Figure9-1.png"}, {"question": "Which of the two scenes, Drop or Staris, requires more computation time for rendering?", "answer": "Staris", "explanation": "The table shows that the rendering time for Staris is 35ms, while the rendering time for Drop is 21ms.", "reference": "1704.07854v4-Table1-1.png"}, {"question": "What is the relationship between the resolution of the simulation and the training time?", "answer": " The higher the resolution of the simulation, the longer the training time. ", "explanation": " The table in the figure shows that the training time increases as the resolution of the simulation increases. For example, the 2D setup with a resolution of 100^2 has a training time of 186 seconds, while the 4D setup with a resolution of 110^3 * 110 has a training time of 186 minutes. ", "reference": "1704.07854v4-Table2-1.png"}, {"question": "What is the role of the parameter network in the weighting and refinement stage?", "answer": "The parameter network is used to infer a weighting function.", "explanation": "The parameter network takes as input the chosen point and the initial surface, and outputs a weighting function. This weighting function is then used to weight the pre-computed deformations, which are then applied to the initial surface. The result is a deformed surface that is then fed into the deformation network.", "reference": "1704.07854v4-Figure2-1.png"}, {"question": "Which of the methods is able to reconstruct the shape of the liquid properly?", "answer": "Only the full method with a deformation network is able to produce a perfect reconstruction.", "explanation": "The figure shows that the PCA reconstruction (purple) and the weighted deformations using a trained parameter network (pink) are not able to reconstruct both arms of liquid in the first row. The reference surfaces (brown) are shown in the background for each version, and it is clear that only the full method with a deformation network is able to match the reference surface.", "reference": "1704.07854v4-Figure16-1.png"}, {"question": "How do the initial conditions of the simulations vary?", "answer": "The initial conditions of the simulations vary in two dimensions: the position of the liquid drop along the x-axis (\u03b11) and the size of the drop (\u03b12).", "explanation": "The left image shows a grid of simulations with different initial conditions. The x-axis represents the position of the drop, and the y-axis represents the size of the drop.", "reference": "1704.07854v4-Figure13-1.png"}]}, "1804.04410v2": {"paper_id": "1804.04410v2", "all_figures": {"1804.04410v2-Figure1-1.png": {"caption": "Figure 1: A telescoping architecture employed in Bing\u2019s retrieval system. Documents are scanned using a pre-defined match plan. Matched documents are passed through additional rank-and-prune stages.", "content_type": "figure", "figure_type": "schematic"}, "1804.04410v2-Figure2-1.png": {"caption": "Figure 2: The reduction in index blocks accessed from the learned policy for CAT2 queries on the weighted set. We intentionally leave out the actual page access numbers on the y-axis because of confidentiality. The queries on the x-axis are sorted by page access independently for each treatment.", "content_type": "figure", "figure_type": "plot"}, "1804.04410v2-Table1-1.png": {"caption": "Table 1: Changes in NCG and the index blocks accessed u from our learned policy relative to production baselines. In both categories, we observe significant reduction in index blocks accessed, although at the cost of some loss in relevance in case of CAT1. All the differences in NCG and u are statistically significant (p < 0.01). Coverage of CAT2 queries in the unweighted set is too low to report numbers.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "How are documents ranked and pruned in the telescoping architecture?", "answer": "Documents are first matched using a pre-defined match plan. Then, they are passed through additional rank-and-prune stages, which are implemented as a cascade of machine learning models.", "explanation": "The figure shows the telescoping architecture, with the matching stage (L0) at the bottom and the rank-and-prune stages (L1, L2) above it. The arrows indicate the flow of documents through the system.", "reference": "1804.04410v2-Figure1-1.png"}, {"question": "How does the RL policy compare to the baseline in terms of index blocks accessed?", "answer": "The RL policy accesses fewer index blocks than the baseline.", "explanation": "The figure shows that the RL policy line is always below the baseline line, which means that the RL policy accesses fewer index blocks than the baseline for all queries.", "reference": "1804.04410v2-Figure2-1.png"}, {"question": "How does the performance of the learned policy compare to the production baseline for CAT2 queries in terms of relevance and efficiency?", "answer": "For CAT2 queries, the learned policy shows a slight improvement in relevance (NCG) for the weighted set and a significant reduction in index blocks accessed for both weighted and unweighted sets.", "explanation": "Table 1 shows the changes in NCG (a measure of relevance) and index blocks accessed (a measure of efficiency) for both CAT1 and CAT2 queries. Comparing the values for CAT2 to the baseline (0%), we see a small positive change in NCG for the weighted set (+0.2%) and a significant decrease in index blocks accessed for both sets (-22.7% for weighted and unspecified for unweighted). This indicates that the learned policy maintains similar relevance while significantly improving efficiency for CAT2 queries.", "reference": "1804.04410v2-Table1-1.png"}]}, "1704.08615v2": {"paper_id": "1704.08615v2", "all_figures": {"1704.08615v2-Figure3-1.png": {"caption": "We reformulated several saliency models in terms of fixation densities and evaluated AUC, sAUC, NSS, IG, CC, KL-Div and SIM on the original saliency maps (dashed line) and the saliency maps derived from the probabilistic model for the different saliency metrics (solid lines) on the MIT1003 dataset. Saliency maps derived for a given metric always yield the highest performance for that metric(thick line), and for each metric the model ranking is consistent when using the correct saliency maps \u2013 unlike for the original saliency maps and some other derived saliency maps. Note that AUC metrics yield identical results on AUC saliency maps, NSS saliency maps and log-density saliency maps, therefore the blue and purple lines are hidden by the red line in the AUC and sAUC plots. Also, the CC metric yields only slightly worse results on the SIM saliency map than on the CC saliency map, therefore the orange line is hidden by the green line in the CC plot. OpnS=OpenSALICON, DGII=DeepGaze II.", "content_type": "figure", "figure_type": "plot"}, "1704.08615v2-Figure7-1.png": {"caption": "The optimal SIM saliency map depends on the number of fixations. (a) For a sample density (see Figure 6), we calculated the optimal SIM saliency map for different numbers of fixations per sample (numbers on top) and additionally the mean empirical saliency map (CC). (b) average performance of those saliency maps (rows) when repeatedly sampling a certain number of fixations (columns) and computing SIM. The best performing saliency map for each sampled dataset (columns) is printed in boldface. It\u2019s always the saliency map calculated with the same number of fixations. Note that the CC saliency map \u2013 although looking identical \u2013 always performs slighly worse", "content_type": "figure", "figure_type": "table"}, "1704.08615v2-Table3-1.png": {"caption": "Table 3: The raw data plotted in Figure 3", "content_type": "table", "figure_type": "N/A"}, "1704.08615v2-Figure2-1.png": {"caption": "The predicted saliency map for various metrics according to different models, for the same stimulus. For six models (rows) we show their original saliency map (first column), the probability distribution after converting the model into a probabilistic model (second column) and the saliency maps predicted for seven different metrics (columns three through seven). The predictions of different models for the same metric (column) appear more similar than the predictions of the same model for different metrics (row). In particular, note the inconsistency of the original models (what are typically compared on the benchmark) relative to the per-metric saliency maps. It is therefore difficult to visually compare original model predictions, which have been formulated for different metrics.", "content_type": "figure", "figure_type": "photograph(s)"}, "1704.08615v2-Figure1-1.png": {"caption": "No single saliency map can perform best in all metrics even when the true fixation distribution is known. This problem can be solved by separating saliency models from saliency maps. a) Fixations are distributed according to a ground truth fixation density p(x, y | I) for some stimulus I (see supplementary material for details on the visualization). b) This ground truth density predicts different saliency maps depending on the intended metric. The saliency maps differ dramatically due to the different properties of the metrics but always reflect the same underlying model. Note that the maps for the NSS and IG metrics are the same, as are those for CC and KL-Div. c) Performances of the saliency maps from b) under seven saliency metrics on a large number of fixations sampled from the model distribution in a). Colors of the bars correspond to the frame colors in b). The predicted saliency map for the specific metric (framed bar) yields best performance in all cases.", "content_type": "figure", "figure_type": "Schematic"}, "1704.08615v2-Figure4-1.png": {"caption": "AUC metrics measure the performance of the saliency map in a 2AFC task where the saliency values of two locations are used to decide which of these two locations is a fixation and which is a nonfixation. a) An example saliency map is shown consisting of five saliency values (s1 < \u00b7 \u00b7 \u00b7 < s5) and with five fixations (f1, . . . , f5) and four nonfixations (n1, . . . , n4). b) The performance in the 2AFC task can be calculated by going through all fixation-nonfixation pairs (fi, nj): The saliency map decides correct if the saliency value of fi is greater than nj (green), incorrect if it is smaller (red) and has chance performance if the values are equal (orange). Below the thick line are all correct predictions (green) and half of the chance cases (orange). c) The ROC curve of the saliency map with respect to the given fixations and nonfixations. For each threshold \u03b8 all values of saliency value greater or equal to \u03b8 are classified as fixations. Comparing b) and c) shows that the area under the curve in c) is exactly the performance in the 2AFC task in b).", "content_type": "figure", "figure_type": "schematic"}, "1704.08615v2-Figure6-1.png": {"caption": "Predicting optimal saliency maps for the CC metric: Starting from a density (a) we sampled 100000 sets of either 1, 10 or 100 fixations and used them to create empirical saliency maps. Using these empirical saliency maps, we calculated the mean empirical saliency map (shown for 10 fixations per empirical saliency map in (b)). Additionally, we normalized the empirical saliency maps to have zero mean and unit variance to compute the mean normalized empirical saliency map (c) which is optimal with respect to the CC metric. Then we sampled another 100000 empirical saliency maps from the original density and evaluated CC scores of the mean empirical and mean normalized empirical saliency maps (d). The mean normalized saliency map yields slighly higher scores in all cases but the difference to the mean empirical saliency map is tiny, indicating that the expected empirical saliency map is a very good approximation of the optimal saliency map for the CC metric.", "content_type": "figure", "figure_type": "plot"}, "1704.08615v2-Table2-1.png": {"caption": "Table 2: The raw data plotted in Figure 1", "content_type": "table", "figure_type": "N/A"}, "1704.08615v2-Figure5-1.png": {"caption": "Visualizing fixation densities: a) an example stimulus with N = 97 ground truth fixations. b) DeepGaze II predicts a fixation density for this stimulus. The contour lines separate the image into four areas of decreasing probability density such that each area has the same total probability mass. c) The number of ground truth fixations in each of the four areas. The model expects the same number of fixations for each area (horizontal line: 24.25 fixations for N fixations total). The gray area shows the expected standard deviation from this number. DeepGaze II overestimates the how peaked the density is: there are too few fixations in darkest area. Vice versa, it misses some probability mass in the second to last area. However, the large error margin (gray area) indicates that substantial deviations from the expected number of fixations are to be expected.", "content_type": "figure", "figure_type": "photograph(s) and plot"}, "1704.08615v2-Table1-1.png": {"caption": "Table 1: AUC and low precision: While AUC metrics in theory depend only on the ranking of the saliency values and therefore are invariant to monotone transformations, this does not hold anymore when the saliency map is saved with limited precision (e.g. as 8bit PNG/JPEG as common). In this case, the saliency map should be rescaled to have a uniform histogram before saving.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "How does the performance of the SIM saliency map change as the number of fixations increases?", "answer": "The performance of the SIM saliency map increases as the number of fixations increases.", "explanation": "The table in the figure shows the average performance of the SIM saliency map for different numbers of fixations. The performance is measured by the SIM score, which is a measure of how well the saliency map predicts the fixations of human observers. The table shows that the SIM score increases as the number of fixations increases. This means that the SIM saliency map is better at predicting the fixations of human observers when there are more fixations.", "reference": "1704.08615v2-Figure7-1.png"}, {"question": "Which saliency map method achieved the highest score for the sAUC metric, and how does its performance compare to other methods based on this metric? ", "answer": "The saliency map method with the highest sAUC score is **SIM**. Its sAUC score appears to be significantly higher than all other methods listed in the table.", "explanation": "Table 1 presents the performance of different saliency map methods across various metrics, including sAUC. By examining the sAUC column, we can identify which method achieved the highest score and compare its performance to others. The table shows that SIM has the highest sAUC value, indicating superior performance compared to the other methods in terms of this specific metric.", "reference": "1704.08615v2-Table3-1.png"}, {"question": "What is the relationship between the ground truth fixation density and the saliency maps?", "answer": "The ground truth fixation density predicts different saliency maps depending on the intended metric.", "explanation": "The figure shows that the ground truth fixation density (a) is used to generate different saliency maps (b) for different metrics. The saliency maps differ dramatically due to the different properties of the metrics, but they all reflect the same underlying model.", "reference": "1704.08615v2-Figure1-1.png"}, {"question": "What is the relationship between the number of fixations and the CC score?", "answer": "The CC score increases as the number of fixations increases.", "explanation": "The figure shows that the CC score for the mean empirical and mean normalized empirical saliency maps increases as the number of fixations increases from 1 to 200. This is because the more fixations there are, the more information is available to calculate the CC score.", "reference": "1704.08615v2-Figure6-1.png"}, {"question": "What is the relationship between the fixation density map and the ground truth fixations?", "answer": "The fixation density map predicts the probability of a person fixating on a particular location in the image. The ground truth fixations are the actual locations where people fixated on the image.", "explanation": "The fixation density map is shown in panel b) and the ground truth fixations are shown in panel a). The contour lines in the fixation density map separate the image into four areas of decreasing probability density. The number of ground truth fixations in each of these areas is shown in panel c).", "reference": "1704.08615v2-Figure5-1.png"}]}, "1811.02553v4": {"paper_id": "1811.02553v4", "all_figures": {"1811.02553v4-Figure5-1.png": {"caption": "True reward landscape concentration for TRPO on Humanoid-v2. We visualize the landscape at a training iteration 150 while varying the number of trajectories used in reward estimation (each subplot), both in the direction of the step taken and a random direction. Moving one unit along the \u201cstep direction\u201d axis corresponds to moving one full step in parameter space. In the random direction one unit corresponds to moving along a random norm 2 Gaussian vector in the parameter space. In practice, the norm of the step is typically an order of magnitude lower than the random direction. While the landscape is very noisy in the low-sample regime, large numbers of samples reveal a well-behaved underlying landscape. See Figures 20, 19 of the Appendix for additional plots.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure18-1.png": {"caption": "Hopper-v2 \u2013 TRPO reward landscapes.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure19-1.png": {"caption": "Humanoid-v2 TRPO landscape concentration (see Figure 5 for a description).", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure8-1.png": {"caption": "Mean reward for the studied policy gradient algorithms on standard MuJoCo benchmark tasks. For each algorithm, we perform 24 random trials using the best performing hyperparameter configuration, with 10 of the random agents shown here.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure14-1.png": {"caption": "Humanoid-v2 \u2013 TRPO reward landscapes.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure1-1.png": {"caption": "Empirical variance of the estimated gradient (c.f. (1)) as a function of the number of stateaction pairs used in estimation in the MuJoCo Humanoid task. We measure the average pairwise cosine similarity between ten repeated gradient measurements taken from the same policy, with the 95% confidence intervals (shaded). For each algorithm, we perform multiple trials with the same hyperparameter configurations but different random seeds, shown as repeated lines in the figure. The vertical line (at x = 2K) indicates the sample regime used for gradient estimation in standard implementations of policy gradient methods. In general, it seems that obtaining tightly concentrated gradient estimates would require significantly more samples than are used in practice, particularly after the first few timesteps. For other tasks \u2013 such as Walker2d-v2 and Hopper-v2 \u2013 the plots (seen in Appendix Figure 9) have similar trends, except that gradient variance is slightly lower. Confidence intervals calculated with 500 sample bootstrapping.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure6-1.png": {"caption": "True reward and surrogate objective landscapes for TRPO on the Humanoid-v2 MuJoCo task. We visualize the landscapes in the direction of the update step and a random direction (as in Figure 5). The surrogate objective corresponds to the actual function optimized by the algorithm at each step. We estimate true reward with 106 state-action pairs per point. We compare the landscapes at different points in training and with varying numbers of state-action pairs used in the update step. Early in training the true and surrogate landscapes align fairly well in both sample regimes, but later become misaligned in the low-sample regime. More landscapes in Appendix Figures 13-18.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure15-1.png": {"caption": "Walker2d-v2 \u2013 PPO reward landscapes.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Table1-1.png": {"caption": "Hyperparameters for PPO and TRPO algorithms.", "content_type": "table", "figure_type": "table"}, "1811.02553v4-Figure2-1.png": {"caption": "Convergence of gradient estimates (c.f. (1)) to the \u201ctrue\u201d expected gradient in the MuJoCo Humanoid task. We measure the mean cosine similarity between the \u201ctrue\u201d gradient approximated using ten million state-action pairs, and ten gradient estimates which use increasing numbers of state-action pairs (with 95% confidence intervals). For each algorithm, we perform multiple trials with the same hyperparameter configurations but different random seeds. The vertical line (at x = 2K) indicates the sample regime used for gradient estimation in standard implementations of policy gradient methods. Observe that although it is possible to empirically estimate the true gradient, this requires several-fold more samples than are used commonly in practical applications of these algorithms. See additionally that the estimation task becomes more difficult further into training. For other tasks \u2013 such as Walker2d-v2 and Hopper-v2 \u2013 the plots (seen in Appendix Figure 10) have similar trends, except that gradient estimation is slightly better. Confidence intervals calculated with 500 sample bootstrapping.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure11-1.png": {"caption": "Quality of value prediction in terms of mean relative error (MRE) on train state-action pairs for agents trained to solve the MuJoCo tasks. We see in that the agents do indeed succeed at solving the supervised learning task they are trained for \u2013 the train MRE on the GAE-based value loss (Vold+AGAE)2 (c.f. (4)) is small (left column). We observe that the returns MRE is quite small as well (right column).", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure16-1.png": {"caption": "Walker2d-v2 \u2013 TRPO reward landscapes.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure7-1.png": {"caption": "True reward and surrogate objective landscapes for PPO on the Humanoid-v2 MuJoCo task. See Figure 6 for a description. We observe that early in training the true and surrogate landscapes align well. However, later increasing the surrogate objective leads to lower true reward.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure3-1.png": {"caption": "Quality of value prediction in terms of mean relative error (MRE) on heldout state-action pairs for agents trained to solve the MuJoCo Walker2d-v2 task. We observe in (left) that the agents do indeed succeed at solving the supervised learning task they are trained for\u2014the MRE on the GAE-based value loss (Vold + AGAE) 2 (c.f. (4)) is small. On the other hand, in (right) we see that the returns MRE is still quite high\u2014the learned value function is off by about 50% with respect to the underlying true value function. Similar plots for other MuJoCo tasks are in Appendix A.5.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure12-1.png": {"caption": "Quality of value prediction in terms of mean relative error (MRE) on heldout state-action pairs for agents trained to solve MuJoCo tasks. We see in that the agents do indeed succeed at solving the supervised learning task they are trained for \u2013 the validation MRE on the GAE-based value loss (Vold + AGAE) 2 (c.f. (4)) is small (left column). On the other hand, we see that the returns MRE is still quite high \u2013 the learned value function is off by about 50% with respect to the underlying true value function (right column).", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure10-1.png": {"caption": "Convergence of gradient estimates to the \u201ctrue\u201d expected gradient (c.f. (1)). We measure the cosine similarity between the true gradient (approximated using around 1M samples) and gradient estimates, as a function of number of state-action pairs used to obtain the later. For a particular policy and state-action pair count, we obtain multiple estimates of this cosine similarity and then report the average, along with the 95% confidence intervals (shaded). Each of the colored lines (for a specific algorithm) represents a particular trained agent (we perform multiple trials with the same hyperparameter configurations but different random seeds). The dotted vertical black line (at 2K) indicates the sample regime used for gradient estimation in standard practical implementations of policy gradient methods.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure20-1.png": {"caption": "Humanoid-v2 PPO landscape concentration (see Figure 5 for a description).", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure17-1.png": {"caption": "Hopper-v2 \u2013 PPO reward landscapes.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure13-1.png": {"caption": "Humanoid-v2 \u2013 PPO reward landscapes.", "content_type": "figure", "figure_type": "Plot"}, "1811.02553v4-Figure4-1.png": {"caption": "Efficacy of the value network as a variance reducing baseline for Walker2d-v2 (top) and Hopper-v2 (bottom) agents. We measure the empirical variance of the gradient (c.f. (1)) as a function of the number of state-action pairs used in estimation, for different choices of baseline functions: the value network (used by the agent in training), the \u201ctrue\u201d value function (fit to the returns using 5 \u00b7 106 state-action pairs sampled from the current policy) and the \u201czero\u201d value function (i.e. replacing advantages with returns). We observe that using the true value function leads to a significantly lower-variance estimate of the gradient compared to the value network. In turn, employing the value network yields a noticeable variance reduction compared to the zero baseline function, even though this difference may appear rather small in the small-sample regime (2K). Confidence intervals calculated with 10 sample bootstrapping.", "content_type": "figure", "figure_type": "plot"}, "1811.02553v4-Figure9-1.png": {"caption": "Empirical variance of the gradient (c.f. (1)) as a function of the number of state-action pairs used in estimation for policy gradient methods. We obtain multiple gradient estimates using a given number of state-action pairs from the policy at a particular iteration. We then measure the average pairwise cosine similarity between these repeated gradient measurements, along with the 95% confidence intervals (shaded). Each of the colored lines (for a specific algorithm) represents a particular trained agent (we perform multiple trials with the same hyperparameter configurations but different random seeds). The dotted vertical black line (at 2K) indicates the sample regime used for gradient estimation in standard practical implementations of policy gradient methods.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "How does the number of state-action pairs affect the reward landscape for the surrogate and true reward functions?", "answer": "As the number of state-action pairs increases, the reward landscape for both the surrogate and true reward functions becomes smoother and more accurate.", "explanation": "The figure shows that the reward landscape for both the surrogate and true reward functions is more jagged and less accurate when there are fewer state-action pairs. This is because the surrogate function is not able to learn the true reward function as well when there is less data. As the number of state-action pairs increases, the surrogate function is able to learn the true reward function more accurately, and the reward landscape becomes smoother and more accurate.", "reference": "1811.02553v4-Figure17-1.png"}, {"question": "How does the number of state-action pairs affect the optimization landscape for the PPO algorithm?", "answer": "As the number of state-action pairs increases, the optimization landscape becomes more complex and has more local optima. This makes it more difficult for the PPO algorithm to find the global optimum.", "explanation": "The figure shows the optimization landscape for the PPO algorithm with different numbers of state-action pairs. The surrogate and true reward landscapes are shown for both few and many state-action pairs. When there are few state-action pairs, the landscape is relatively smooth and has fewer local optima. However, when there are many state-action pairs, the landscape becomes more complex and has more local optima. This is because there are more possible state-action pairs that the algorithm can explore, which leads to a more complex optimization landscape.", "reference": "1811.02553v4-Figure13-1.png"}, {"question": "How do TRPO and PPO compare in terms of convergence to the true gradient?", "answer": "TRPO generally converges faster to the true gradient than PPO.", "explanation": "The figure shows that the cosine similarity between the true gradient and the gradient estimates for TRPO is generally higher than that for PPO, for a given number of state-action pairs. This indicates that TRPO is able to more accurately estimate the true gradient with fewer samples.", "reference": "1811.02553v4-Figure10-1.png"}, {"question": "How does the landscape concentration of the humanoid-v2 PPO policy change with respect to the number of state-action pairs?", "answer": "The landscape concentration increases with the number of state-action pairs.", "explanation": "The figure shows the landscape concentration of the humanoid-v2 PPO policy at different numbers of state-action pairs. As the number of state-action pairs increases, the landscape concentration becomes more focused, indicating that the policy is becoming more confident in its predictions.", "reference": "1811.02553v4-Figure20-1.png"}, {"question": "How does the quality of gradient estimation change as the number of state-action pairs used in estimation increases?", "answer": "The quality of gradient estimation increases as the number of state-action pairs used in estimation increases.", "explanation": "The figure shows that the average pairwise cosine similarity between repeated gradient measurements increases as the number of state-action pairs used in estimation increases. This means that the gradient estimates become more consistent and accurate as more data is used.", "reference": "1811.02553v4-Figure9-1.png"}]}, "1804.04786v3": {"paper_id": "1804.04786v3", "all_figures": {"1804.04786v3-Figure3-1.png": {"caption": "Comparison between the proposed method and the stateof-the-art algorithms. The first row shows the ground truth video, saying \u201chigh edu(cation)\u201d which is the input audio, and the first image column gives the input faces. [Chen et al., 2018] can only generate the lip region. Frames corresponding to the letters inside parentheses are not presented here.", "content_type": "figure", "figure_type": "photograph(s)"}, "1804.04786v3-Figure1-1.png": {"caption": "Illustration of different condition video generation schemes. (a) Frame-to-frame generation scheme (no correlation across different frames). (b) Sequential frame generation scheme (only short term frame correlation is considered). The dash block indicates when L = 2. (c) Recurrent frame generation scheme where the identity image I\u2217 is fed into all the future frame generation to preserve long-term dependency.", "content_type": "figure", "figure_type": "schematic"}, "1804.04786v3-Figure2-1.png": {"caption": "Figure 2: The proposed conditional recurrent adversarial video generation network structure.", "content_type": "figure", "figure_type": "** Schematic"}, "1804.04786v3-Figure6-1.png": {"caption": "Figure 6: The first row is the ground truth image, the second row is our generated results.", "content_type": "figure", "figure_type": "photograph(s)"}, "1804.04786v3-Figure4-1.png": {"caption": "Ablation study on the loss functions used in the proposed method. The rows show the continuous frames generated from the same audio input but different loss combinations as denoted on the left. The subscripts r, I , V , and l indicates Lrec, LI , LV , and Ll in Eq. 5, respectively.", "content_type": "figure", "figure_type": "photograph(s)"}, "1804.04786v3-Figure5-1.png": {"caption": "Effect of different generation schemes. The sample is randomly selected from the TCD-TIMIT dataset. From top to bottom: sequential generation, frame-to-frame generation, and our recurrent generation schemes. Optical flow is calculated on the frameto-frame and recurrent schemes as shown under the face images.", "content_type": "figure", "figure_type": "photograph(s)"}, "1804.04786v3-Table1-1.png": {"caption": "The quantitative evaluation on the LRW testing dataset. The second block lists the results of our recurrent network using different loss functions. LRA (Top1/Top5) denotes the lip-reading accuracy.", "content_type": "table", "figure_type": "table"}}, "qa": [{"question": "What is the purpose of the audio encoder in the proposed conditional recurrent adversarial video generation network structure?", "answer": "The audio encoder extracts audio features from the MFCC features of each audio segment.", "explanation": " In Fig.~\\ref{fig:flow}, the audio encoder is represented by the block labeled \"Audio Encoder.\" It takes as input the MFCC features of each audio segment, denoted by $A_t$, and outputs the corresponding audio feature, denoted by $z^A_t$.", "reference": "1804.04786v3-Figure2-1.png"}, {"question": "Which loss function combination is most important for generating realistic mouth movements?", "answer": "The combination of Lrec, LI, and LV is most important for generating realistic mouth movements.", "explanation": "The figure shows that when Lrec, LI, and LV are used together, the generated mouth movements are more realistic and match the audio input more closely. When Ll is added to the loss function combination, the generated mouth movements become less realistic and more exaggerated.", "reference": "1804.04786v3-Figure4-1.png"}, {"question": "What is the difference between the sequential and recurrent generation schemes?", "answer": "The sequential generation scheme generates each frame of the video independently, while the recurrent generation scheme uses the previous frame to generate the next frame. This can be seen in the optical flow images, which show the motion of pixels between frames. The recurrent scheme has a smoother flow of motion, while the sequential scheme has more abrupt changes.", "explanation": "The figure shows examples of videos generated using the different schemes. The optical flow images show how the pixels in the video are moving.", "reference": "1804.04786v3-Figure5-1.png"}]}, "1705.02798v6": {"paper_id": "1705.02798v6", "all_figures": {"1705.02798v6-Table4-1.png": {"caption": "Table 4: Ablation study on SQuAD dev set.", "content_type": "table", "figure_type": "N/A"}, "1705.02798v6-Table3-1.png": {"caption": "Performance comparison on two adversarial SQuAD datasets. Wang & Jiang[2017]1, Seo et al.[2017]2, Liu et al.[2017a]3, Shen et al.[2016]4 and Huang et al.[2017]5. \u2217 indicates ensemble models.", "content_type": "table", "figure_type": "table."}, "1705.02798v6-Table2-1.png": {"caption": "Table 2: The performance of Reinforced Mnemonic Reader and other competing approaches on the SQuAD dataset. The results of test set are extracted on Feb 2, 2018: Rajpurkar et al.[2016]1, Xiong et al.[2017a]2, Huang et al.[2017]3, Liu et al.[2017b]4 and Peters[2018]5. \u2020 indicates unpublished works. BSE refers to BiDAF + Self Attention + ELMo.", "content_type": "table", "figure_type": "N/A"}, "1705.02798v6-Figure1-1.png": {"caption": "Figure 1: An example from the SQuAD dataset. Evidences needed for the answer are marked as green.", "content_type": "figure", "figure_type": "other"}, "1705.02798v6-Table1-1.png": {"caption": "Comparison of alignment architectures of competing models: Wang & Jiang[2017]1, Wang et al.[2017]2, Seo et al.[2017]3, Weissenborn et al.[2017]4, Xiong et al.[2017a]5 and Huang et al.[2017]6.", "content_type": "table", "figure_type": "table"}, "1705.02798v6-Figure5-1.png": {"caption": "Figure 5: Predictions with DCRL (red) and with SCST (blue) on SQuAD dev set.", "content_type": "figure", "figure_type": "plot"}, "1705.02798v6-Table5-1.png": {"caption": "Table 5: Comparison of KL diverfence on different attention distributions on SQuAD dev set.", "content_type": "table", "figure_type": "N/A"}, "1705.02798v6-Figure2-1.png": {"caption": "Figure 2: Illustrations of reattention for the example in Figure 1.", "content_type": "figure", "figure_type": "schematic"}, "1705.02798v6-Figure3-1.png": {"caption": "Figure 3: The architecture overview of Reinforced Mnemonic Reader. The subfigures to the right show detailed demonstrations of the reattention mechanism: 1) refined Et to attend the query; 2) refined Bt to attend the context.", "content_type": "figure", "figure_type": "schematic"}, "1705.02798v6-Figure4-1.png": {"caption": "Figure 4: The detailed overview of a single aligning block. Different colors in E and B represent different degrees of similarity.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "Which component of the model seems to have the biggest impact on the F1 score on SQuAD dataset, and how much does removing it affect the score?", "answer": "The DCRL training method appears to have the biggest impact on the F1 score. Removing it leads to a drop of 0.9 points in F1, which is the largest decrease observed for any single component in the ablation study.", "explanation": "The table shows the results of an ablation study, where different components of the model are removed or replaced to see how they affect performance. The \"\u0394F1\" column specifically shows the change in F1 score compared to the baseline model (R.M-Reader). By comparing the values in this column, we can identify which component has the largest impact on the F1 score when removed. In this case, removing DCRL in ablation (2) leads to the biggest drop in F1 score, indicating its importance for achieving a high F1 score.", "reference": "1705.02798v6-Table4-1.png"}, {"question": "Which model performs the best on the AddOneSent dataset in terms of F1 score?", "answer": "R.M.-Reader.", "explanation": "The table shows the performance of different models on the AddOneSent dataset in terms of EM and F1 score. The R.M.-Reader model has the highest F1 score of 67.0.", "reference": "1705.02798v6-Table3-1.png"}, {"question": "How does the performance of the single R.M-Reader model compare to the best single models of other approaches on the SQuAD test set?", "answer": "The single R.M-Reader model achieves an EM score of 79.5% and an F1 score of 86.6% on the SQuAD test set. This performance is better than all other single models listed in the table, except for SLQA and Hybrid AoA Reader, which achieve slightly higher F1 scores of 87.0% and 87.3%, respectively.", "explanation": "Table 3 presents the performance of different models on the SQuAD dataset, including both single and ensemble models. By comparing the EM and F1 scores of R.M-Reader with those of other models in the \"Single Model\" section, we can assess its relative performance. While SLQA and Hybrid AoA Reader have slightly higher F1 scores, R.M-Reader still outperforms all other single models in terms of EM score and has a competitive F1 score.", "reference": "1705.02798v6-Table2-1.png"}, {"question": "What are the two types of attention mechanisms used in the Reinforced Mnemonic Reader architecture?", "answer": "The two types of attention mechanisms are reattention and self-attention.", "explanation": "The figure shows the architecture of the Reinforced Mnemonic Reader, which includes two types of attention mechanisms: reattention and self-attention. Reattention is used to refine the evidence embedding Et to attend to the query, and self-attention is used to refine the context embedding Bt to attend to the context.", "reference": "1705.02798v6-Figure3-1.png"}, {"question": "What is the purpose of the fusion modules in the interactive alignment and self-alignment modules?", "answer": "The fusion modules are used to combine the outputs of the interactive alignment and self-alignment modules.", "explanation": "The figure shows that the fusion modules take as input the outputs of the interactive alignment and self-alignment modules and produce a single output. This suggests that the fusion modules are used to combine the information from these two modules.", "reference": "1705.02798v6-Figure4-1.png"}, {"question": "How does reattention affect the redundancy and deficiency of attention distributions? Can you explain the observed differences in the impact of reattention on different blocks?", "answer": "This paper shows that reattention helps alleviate both redundancy and deficiency in attention distributions.\n\nRedundancy: Reattention increases the KL divergence between adjacent attention blocks, indicating that the attention distributions across blocks become more distinct and less redundant.\nDeficiency: Reattention reduces the KL divergence between the normalized attention distribution ($E^t$) and the ideal uniform distribution (${E^t}^*$), suggesting that the attention becomes more balanced and closer to the desired distribution.\nHowever, the improvement in redundancy is more pronounced between the first two blocks ($E^1$ to $E^2$) than the last two blocks ($B^2$ to $B^3$). This suggests that the first reattention is more effective in capturing word pair similarities using the original word representations. In contrast, the later reattention might be negatively impacted by the highly non-linear word representations generated in the previous layers.", "explanation": "The KL divergence values in Table 7 quantify the differences between attention distributions. Comparing the values with and without reattention allows us to assess the impact of reattention on redundancy and deficiency. The passage further clarifies the observed differences in the effectiveness of reattention across different blocks.", "reference": "1705.02798v6-Table5-1.png"}]}, "1804.05936v2": {"paper_id": "1804.05936v2", "all_figures": {"1804.05936v2-Table3-1.png": {"caption": "Table 3: Comparison of baselines and the DLCMs onMicrsoft 10K. \u2217, + and \u2021 denotes significant improvements over the global ranking algorithm and the best corresponding re-ranking baseline (DNN) and LIDNN.", "content_type": "table", "figure_type": "N/A"}, "1804.05936v2-Table2-1.png": {"caption": "Table 2: Comparison of baselines and the DLCMs onMicrsoft 30K. \u2217, + and \u2021 denotes significant improvements over the global ranking algorithm and the best corresponding re-ranking baseline (DNN) and LIDNN.", "content_type": "table", "figure_type": "N/A"}, "1804.05936v2-Figure4-1.png": {"caption": "The performance of the DLCMs on Microsoft 30k with different hyper-parameters.", "content_type": "figure", "figure_type": "plot"}, "1804.05936v2-Table4-1.png": {"caption": "Table 4: Comparison of baselines and the DLCMs on Yahoo! set 1. \u2217, + and \u2021 denotes significant improvements over the global ranking algorithm and the best corresponding re-ranking baseline (DNN) and LIDNN.", "content_type": "table", "figure_type": "N/A"}, "1804.05936v2-Table5-1.png": {"caption": "Table 5: The statistics of the test fold used for pairwise ranking analysis in Microsoft 30k. Query denotes the number of queries containing documentswith the corresponding label.", "content_type": "table", "figure_type": "N/A"}, "1804.05936v2-Figure2-1.png": {"caption": "Figure 2: The NegPair reduction (NP(d,LambdaMART )- NP(d,DLCM)) on documents with different relevance labels.", "content_type": "figure", "figure_type": "plot"}, "1804.05936v2-Figure1-1.png": {"caption": "The overall structure of the Deep Listwise Context Model (DLCM). Rnq is a ranked list provided by a global ranking function f for query q; x(q,di ) is the feature vector for document di ; sn and oi is the final network state and hidden outputs of the RNN with GRU in I (Rnq ,Xn q ); and Score(di ) is the final ranking score of di computed with \u03d5(on+1\u2212i , sn )", "content_type": "figure", "figure_type": "schematic"}, "1804.05936v2-Figure3-1.png": {"caption": "Figure 3: TheNegPair reduction and corresponding improvement proportion for queries with different number of perfect documents.", "content_type": "figure", "figure_type": "plot"}, "1804.05936v2-Table1-1.png": {"caption": "Table 1: The characteristics of learning-to-rank datasets used in our experiments: number of queries, documents, relevance levels, features and year of release.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "Which relevance label category of documents received the most significant rank promotion according to the NegPair reduction metric?", "answer": "The perfect results received the largest promotions in rank.", "explanation": "Figure 0 shows that the average NegPair reduction for documents with the **perfect** relevance label is the highest among all categories, with a value of 1.88. This indicates that the positions of these documents have been effectively increased by nearly 2 in their ranked lists.", "reference": "1804.05936v2-Figure2-1.png"}, {"question": "What is the role of the GRU in the Deep Listwise Context Model (DLCM)?", "answer": "The GRU is used to process the ranked list of documents provided by a global ranking function.", "explanation": "The GRU takes the feature vector of each document in the ranked list as input and outputs a final network state and hidden outputs. These outputs are then used to compute the final ranking score of each document.", "reference": "1804.05936v2-Figure1-1.png"}, {"question": "How does the NegPair reduction vary with the number of perfect results in a query?", "answer": "The NegPair reduction generally increases as the number of perfect results in a query increases.", "explanation": "The figure shows that the average NegPair reduction is higher for queries with more perfect results. For example, the NegPair reduction is 0.99 for queries with one perfect result, but it is 2.64 for queries with four perfect results. This suggests that DLCMs are more effective at reducing the number of negative pairs for queries with more perfect results.", "reference": "1804.05936v2-Figure3-1.png"}, {"question": "Which dataset would be most suitable for training a learning-to-rank model with limited computational resources, and why?", "answer": "Microsoft 10k would be the most suitable dataset for training with limited computational resources.", "explanation": "The table shows that Microsoft 10k has the smallest number of queries and documents compared to the other two datasets. This implies that training a model on this dataset would require less memory and processing power, making it a better choice when computational resources are limited.", "reference": "1804.05936v2-Table1-1.png"}, {"question": "Which of the following methods has the best performance?", "answer": "LambdaMART", "explanation": "LambdaMART consistently has the lowest ERR@10 values in all the figures, regardless of the hyper-parameter being tested.", "reference": "1804.05936v2-Figure4-1.png"}, {"question": "Which combination of initial list, model, and loss function achieved the best overall performance on the Yahoo! set 1, as measured by nDCG@10 and ERR@10?", "answer": "LambdaMART initial list, DLCM model, and AttRank loss function achieved the best overall performance on the Yahoo! set 1, with an nDCG@10 of 0.743 and an ERR@10 of 0.453.", "explanation": "The table presents the performance of various combinations of initial list, model, and loss function on the Yahoo! set 1, measured by several metrics including nDCG@10 and ERR@10. By looking at the last two columns of the table, we can identify the combination with the highest values for both metrics. In this case, the combination of LambdaMART initial list, DLCM model, and AttRank loss function has the highest values for both nDCG@10 (0.743) and ERR@10 (0.453), indicating the best overall performance.", "reference": "1804.05936v2-Table4-1.png"}]}, "1804.07849v4": {"paper_id": "1804.07849v4", "all_figures": {"1804.07849v4-Table1-1.png": {"caption": "Table 1: Many-to-one accuracy on the 45-tag Penn WSJ with the best hyperparameter configurations. The average accuracy over 10 random restarts is reported and the standard deviation is given in parentheses (except for deterministic methods).", "content_type": "table", "figure_type": "N/A"}, "1804.07849v4-Table2-1.png": {"caption": "Table 2: Ablation of the best model on Penn WSJ.", "content_type": "table", "figure_type": "N/A"}, "1804.07849v4-Table4-1.png": {"caption": "Table 4: Comparison with the reported results with CRF autoencoders in many-to-one accuracy (M2O) and the V-measure (VM).", "content_type": "table", "figure_type": "N/A"}, "1804.07849v4-Table3-1.png": {"caption": "Many-to-one accuracy on the 12-tag universal treebank dataset. We use the same setting in Table 1. All models use a fixed hyperparameter configuration optimized on the 45-tag Penn WSJ.", "content_type": "table", "figure_type": "table"}, "1804.07849v4-Figure1-1.png": {"caption": "Architecture illustrated on the example text \u201chad these keys in my\u201d with target Y = \u201ckeys\u201d.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "Which method achieved the highest accuracy on the 45-tag Penn WSJ dataset, and how does its performance compare to the other methods?", "answer": "The Variational $\\wh{J}^{\\mathrm{var}}$ method achieved the highest accuracy of 78.1% on the 45-tag Penn WSJ dataset. This is significantly higher than all other methods listed in the table, with the next best performing method (Berg-Kirkpatrick et al., 2010) achieving an accuracy of 74.9%.", "explanation": "Table 1 shows the accuracy of different methods on the 45-tag Penn WSJ dataset. The caption clarifies that the table presents the average accuracy over 10 random restarts with the best hyperparameter configurations for each method. The standard deviation is also provided, allowing for an assessment of the methods' performance stability. By comparing the accuracy values in the table, we can determine that Variational $\\wh{J}^{\\mathrm{var}}$  outperforms all other methods, achieving the highest average accuracy with a relatively low standard deviation.", "reference": "1804.07849v4-Table1-1.png"}, {"question": "According to the ablation experiments, which factor contributes the most to the best model's performance compared to the baseline model?", "answer": "Morphological modeling with LSTMs contributes the most to the best model's performance compared to the baseline model.", "explanation": "The table shows that \"No character encoding,\" which effectively removes the morphological modeling with LSTMs, results in the largest drop in accuracy (from 80.1% to 65.6%). This suggests that this feature is crucial for the model's performance. While other factors like context size and initialization also affect accuracy, their impact is smaller compared to the absence of morphological modeling.", "reference": "1804.07849v4-Table2-1.png"}, {"question": "Which method achieved the highest average V-measure (VM) across all languages, and how much higher was its average compared to the Baum-Welch method?", "answer": "The Variational $\\wh{J}^{\\mathrm{var}}$ method achieved the highest average VM score (50.4). Its average score is 39.6 points higher than the Baum-Welch method, which achieved an average VM score of 10.8.", "explanation": "The table shows the VM scores for different methods across various languages. By looking at the \"Mean\" column for the VM section, we can identify that Variational $\\wh{J}^{\\mathrm{var}}$ has the highest average score. The difference between the average scores of Variational $\\wh{J}^{\\mathrm{var}}$ and Baum-Welch can be calculated by simple subtraction (50.4 - 10.8 = 39.6).", "reference": "1804.07849v4-Table4-1.png"}, {"question": "Which method achieved the highest accuracy on the Italian language data set?", "answer": "Variational J^var (7)", "explanation": "The table shows the accuracy of different methods on different language data sets. The highest accuracy for the Italian data set is 77.4, which is achieved by the Variational J^var (7) method.", "reference": "1804.07849v4-Table3-1.png"}, {"question": "What is the role of the BiLSTM in the architecture?", "answer": "The BiLSTM takes as input the character-level representations of the words and outputs a word-level representation for each word.", "explanation": "The BiLSTM is shown at the bottom of the figure, taking as input the character-level representations of the words and outputting a word-level representation for each word.", "reference": "1804.07849v4-Figure1-1.png"}]}, "1811.07073v3": {"paper_id": "1811.07073v3", "all_figures": {"1811.07073v3-Table1-1.png": {"caption": "Table 1: Ablation study of models on the PASCAL VOC 2012 validation set using mIOU for different sizes of F . For the last three rows, the remaining images in the training set is used as W , i.e. W + F = 10582.", "content_type": "table", "figure_type": "N/A"}, "1811.07073v3-Figure3-1.png": {"caption": "Figure 3: Convolutional self-correction model learns refining the input label distributions. The subnetwork receives logits from the primary and ancillary models, then concatenates and feeds the output to a two-layer CNN.", "content_type": "figure", "figure_type": "schematic"}, "1811.07073v3-Table4-1.png": {"caption": "Table 4: Results on Cityscapes validation set. 30% of the training examples is used as F , and the remaining as W .", "content_type": "table", "figure_type": "N/A"}, "1811.07073v3-Table3-1.png": {"caption": "Table 3: Ablation study of our models on Cityscapes validation set using mIOU for different sizes of F . For the last three rows, the remaining images in the training set are used as W , i.e., W + F = 2975.", "content_type": "table", "figure_type": "N/A"}, "1811.07073v3-Table2-1.png": {"caption": "Table 2: Results on PASCAL VOC 2012 validation and test sets. The last three rows report the performance of previous semi-supervised models with the same annotation.", "content_type": "table", "figure_type": "N/A"}, "1811.07073v3-Figure1-1.png": {"caption": "Figure 1: An overview of our segmentation framework consisting of three models: i) Primary segmentation model generates a semantic segmentation of objects given an image. This is the main model that is subject to the training and is used at test time. ii) Ancillary segmentation model outputs a segmentation given an image and bounding box. This model generates an initial segmentation for the weak set, which will aid training the primary model. iii) Self-correction module refines segmentations generated by the ancillary model and the current primary model for the weak set. The primary model is trained using the cross-entropy loss that matches its output to either ground-truth segmentation labels for the fully supervised examples or soft refined labels generated by the self-correction module for the weak set.", "content_type": "figure", "figure_type": "schematic"}, "1811.07073v3-Figure4-1.png": {"caption": "Qualitative results on the PASCAL VOC 2012 validation set. The last four columns represent the models in column 1464 of Table 1. The Conv. Self-correction model typically segments objects better than other models.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.07073v3-Figure5-1.png": {"caption": "Qualitative results on the PASCAL VOC 2012 auxiliary (the weak set). The heatmap of a single class for the ancillary model is shown for several examples. The ancillary model can successfully correct the labels for missing or oversegmented objects in these images (marked by ellipses).", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.07073v3-Figure2-1.png": {"caption": "Figure 2: An overview of the ancillary segmentation model. We modify an existing encoder-decoder segmentation model by introducing a bounding box encoder that embeds the box information. The output of the bounding box encoder after passing through a sigmoid activation acts as an attention map. Feature maps at different scales from the encoder are fused (using element-wise-multiplication) with attention maps, then passed to the decoder.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "How does the performance of the model with convolutional self-correction compare to the model with no self-correction as the number of images in set $\\mathcal{F}$ increases?", "answer": "The model with convolutional self-correction consistently outperforms the model with no self-correction as the number of images in set $\\mathcal{F}$ increases.", "explanation": "Looking at the last three rows of Table 1, we can compare the mIOU scores for different self-correction methods. For each value of images in $\\mathcal{F}$ (200, 450, and 914), the convolutional self-correction model achieves a higher mIOU score than the model with no self-correction. This trend indicates that convolutional self-correction leads to better performance, especially as the size of set $\\mathcal{F}$ increases. Additionally, the passage mentions that the same conclusions observed on the PASCAL dataset hold for the Cityscapes dataset, implying that the efficacy of self-correction is consistent across datasets.", "reference": "1811.07073v3-Table3-1.png"}, {"question": "Which method performed the best on the PASCAL VOC 2012 test set and how does it compare to the baseline model without self-correction?", "answer": "The Conv. Self-Corr. method achieved the highest performance on the PASCAL VOC 2012 test set with a score of 82.72. This is approximately 1.11 points higher than the baseline model (\"No Self-Corr.\") which achieved a score of 81.61.", "explanation": "The table shows the performance of different methods on the PASCAL VOC 2012 validation and test sets. The \"Test\" column provides the scores for the test set. By comparing the values in this column, we can identify the best performing method. The difference between the \"Conv. Self-Corr.\" and \"No Self-Corr.\" scores demonstrates the improvement gained by using the convolutional self-correction approach.", "reference": "1811.07073v3-Table2-1.png"}, {"question": "What is the input to the convolutional self-correction model?", "answer": "The input to the convolutional self-correction model is the logits generated by the primary and ancillary models.", "explanation": "The figure shows that the primary and ancillary logits are fed into the convolutional self-correction model.", "reference": "1811.07073v3-Figure3-1.png"}, {"question": "How does the performance of the \"Conv. Self-Correction\" method compare to other methods when using 30% of the training examples as $\\F$ and the remaining as $\\W$ on the Cityscapes validation set?", "answer": "The \"Conv. Self-Correction\" method achieves the highest mIOU score of 79.46 compared to other methods listed in the table under the same data split condition.", "explanation": "Table 1 presents the mIOU scores for various methods under different data split scenarios. When focusing on the rows where $F=914$ and $W=2061$ (representing the 30% split), we can directly compare the mIOU scores of all listed methods. The \"Conv. Self-Correction\" method clearly shows the highest score, indicating its superior performance in this specific setting.", "reference": "1811.07073v3-Table4-1.png"}, {"question": "How does the bounding box encoder network influence the segmentation process?", "answer": "The bounding box encoder network embeds bounding box information at different scales and outputs attention maps that are used to fuse with feature maps from the encoder before being passed to the decoder.", "explanation": "The figure shows the bounding box encoder network as a separate branch that receives the bounding box information as input. The output of this network is then used to modify the feature maps from the encoder before they are passed to the decoder.", "reference": "1811.07073v3-Figure2-1.png"}, {"question": "What is the role of the self-correction module in the segmentation framework?", "answer": "The self-correction module refines the segmentations generated by the ancillary and current primary model for the weak set.", "explanation": "The figure shows that the self-correction module takes as input the segmentations from the ancillary and primary models for the weak set and outputs refined soft labels. These refined labels are then used to train the primary model.", "reference": "1811.07073v3-Figure1-1.png"}, {"question": "What is the purpose of the ancillary heatmap shown in this paper?", "answer": "The ancillary heatmap is used to correct the labels for missing or oversegmented objects in the images.", "explanation": "The heatmap shows the areas of the image that the ancillary model predicts to belong to a particular class. The areas marked by ellipses are examples of where the ancillary model is able to correct the labels for missing or oversegmented objects.", "reference": "1811.07073v3-Figure5-1.png"}]}, "1705.02946v3": {"paper_id": "1705.02946v3", "all_figures": {"1705.02946v3-Figure5-1.png": {"caption": "Figure 5: Partial rigid measure system for \u03b1 \u2208 (`1, `1 + 2k/3]. The break points are m = x+ 2k/3, n = x + 2k/3 + 0.01k, p = y + 1.03k/3, q = y + 1.03k/3 + 0.01k. The densities are uniform on [m,n], [p, q].", "content_type": "figure", "figure_type": "table"}, "1705.02946v3-Figure6-1.png": {"caption": "Figure 6: Partial rigid measure system for \u03b1 \u2208 (`1 + 2k/3, `1 + k). The break points are m = x+ 2k/3\u2212 0.01k, n = x+ 2k/3, p = y+ 0.97k/3, q = y+k/3; uniform densities on [m,n] and [p, q].", "content_type": "figure", "figure_type": "table"}, "1705.02946v3-Figure4-1.png": {"caption": "Case 2 of the simulation.", "content_type": "figure", "figure_type": "Schematic"}, "1705.02946v3-Table2-1.png": {"caption": "Initial configuration for envy-free lower bound.", "content_type": "table", "figure_type": "table"}, "1705.02946v3-Figure2-1.png": {"caption": "Figure 2: Construction for equitable lower bound. The distance from a connected equitable and proportional allocation is b\u2212 a, where 0 < a < b < 0.5 and 0 < x < y < 1.", "content_type": "figure", "figure_type": "Table"}, "1705.02946v3-Table1-1.png": {"caption": "Query complexity in cake cutting in the standard query model. Our results are marked with (\u2217). The lower bounds for finding \u03b5-perfect and \u03b5-equitable allocations for n \u2265 3 players hold for any number of cuts [PW17]. The bounds for exact envy-free and proportional allocations hold for any number of cuts, except the upper bound for proportional works for connected pieces.", "content_type": "table", "figure_type": "table"}, "1705.02946v3-Figure3-1.png": {"caption": "Case 1 of the simulation.", "content_type": "figure", "figure_type": "schematic"}, "1705.02946v3-Figure8-1.png": {"caption": "Figure 8: Construction for perfect. Player 1 has uniform density everywhere; y = x + 0.5, 0 < a, d \u2264 0.1, x, b, c, e > 0, x+ a+ b = 0.5 and c+ 2d+ e = 0.5.", "content_type": "figure", "figure_type": "** Table"}, "1705.02946v3-Figure1-1.png": {"caption": "Figure 1: Construction for perfect. Player 1 has uniform density everywhere; y = x + 0.5, 0 < a, d \u2264 0.1, x, b, c, e > 0, x+ a+ b = 0.5 and c+ 2d+ e = 0.5.", "content_type": "figure", "figure_type": "** Table"}, "1705.02946v3-Figure7-1.png": {"caption": "Approximate computation of \u03b5-perfect partition. Maintain two points z and w, such that the rightmost cut must be situated in the interval [z, w]", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "What is the initial value of V2 in the interval [0.35, 0.67]?", "answer": "0.35", "explanation": "The table shows the initial values of V1, V2, and V3 in different intervals. The value of V2 in the interval [0.35, 0.67] is shown in the second row and fourth column of the table.", "reference": "1705.02946v3-Table2-1.png"}, {"question": "What is the distance from equitability for the allocation that can be obtained by cutting at $x$ with the player order $(1,2)$?", "answer": "The distance from equitability is $b-a$.", "explanation": "The figure shows that for the allocation that can be obtained by cutting at $x$ with the player order $(1,2)$, player 1 gets $V_1(0,x) = 0.5+a$ and player 2 gets $V_2(x,1) = 0.5+b$. The distance from equitability is the absolute value of the difference between these two values, which is $|V_1(0,x) - V_2(x,1)| = |(0.5+a) - (0.5+b)| = b-a$.", "reference": "1705.02946v3-Figure2-1.png"}, {"question": "What is the upper bound on the query complexity for finding an \u03b5-perfect allocation with minimum cuts for 3 or more players?", "answer": "O(n^3 / \u03b5)", "explanation": "The upper bound for \u03b5-perfect allocations with minimum cuts is shown in the third row of the table. For n \u2265 3 players, the upper bound is O(n^3 / \u03b5).", "reference": "1705.02946v3-Table1-1.png"}]}, "1705.07164v8": {"paper_id": "1705.07164v8", "all_figures": {"1705.07164v8-Figure1-1.png": {"caption": "Training curves by running all approaches. Generator and discriminator losses are plotted in orange and blue lines. mnist fashion-mnist", "content_type": "figure", "figure_type": "plot"}, "1705.07164v8-Figure3-1.png": {"caption": "Training curves by running all approaches. Generator and discriminator losses are plotted in orange and blue lines. cifar10 imagenet", "content_type": "figure", "figure_type": "plot"}, "1705.07164v8-Table2-1.png": {"caption": "Table 2: Inception scores (IS) obtained by running RWGAN, WGAN and WGAN(g). For cifar10, \u201cbegin\" and \u201cend\" refer to IS averaged over first 5 and last 10 epochs. For imagenet, \u201cbegin\" and \u201cend\" refer to IS averaged over first 3 and last 5 epochs.", "content_type": "table", "figure_type": "N/A"}, "1705.07164v8-Table1-1.png": {"caption": "Examples of the function \u03c6 and the resulting Bregman cost functions. Note that A 0 is positive semidefinite.", "content_type": "table", "figure_type": "table"}}, "qa": [{"question": "What can you infer from the training curves for the ACGAN?", "answer": "The training curves for the ACGAN show that the generator and discriminator losses both decrease over time. This indicates that the ACGAN is able to learn to generate realistic images.", "explanation": "The figure shows the training curves for the ACGAN. The orange line represents the generator loss, and the blue line represents the discriminator loss. The fact that both lines decrease over time indicates that the ACGAN is learning to generate realistic images.", "reference": "1705.07164v8-Figure1-1.png"}, {"question": "Which model performs better based on the training curves?", "answer": "It is difficult to say definitively which model performs better based on the training curves alone. However, it appears that the WGAN(g) model may be performing better than the other models, as its generator and discriminator losses are both lower than the other models.", "explanation": "The training curves show the generator and discriminator losses for each model over time. The lower the loss, the better the model is performing.", "reference": "1705.07164v8-Figure3-1.png"}, {"question": "Which method achieved the highest Inception Score (IS) at the end of training for both CIFAR10 and ImageNet datasets? Did this method also achieve the highest initial IS score?", "answer": "For CIFAR10, WGAN achieved the highest IS at the end of training (2.42). However, RWGAN had a higher initial IS score (1.86) compared to WGAN's 1.63. \n\nFor ImageNet, WGAN again achieved the highest final IS (2.80), while RWGAN had a slightly higher initial IS (2.04 vs. 2.00). ", "explanation": "The table presents the IS scores for different methods at both the beginning and end of the training process. By comparing the values in the \"end\" columns for both datasets, we can identify which method ultimately achieved the highest score. Additionally, comparing the values in the \"begin\" columns reveals which method started with the highest score.", "reference": "1705.07164v8-Table2-1.png"}, {"question": "What is the difference between the Euclidean and Mahalanobis Bregman cost functions?", "answer": "The Euclidean Bregman cost function is simply the squared difference between two points, while the Mahalanobis Bregman cost function takes into account the covariance of the data.", "explanation": "The table shows that the Euclidean Bregman cost function is given by ||x - y||^2, while the Mahalanobis Bregman cost function is given by (x - y)^T A (x - y), where A is a positive semi-definite matrix that represents the covariance of the data. This means that the Mahalanobis Bregman cost function gives more weight to differences in directions where the data is more spread out.", "reference": "1705.07164v8-Table1-1.png"}]}, "1804.05995v2": {"paper_id": "1804.05995v2", "all_figures": {"1804.05995v2-Figure3-1.png": {"caption": "Category network for the stanford, california Wikipedia article (A). In this example, the two leftmost categories (assigned to A via the instanceof edges) are both sub-", "content_type": "figure", "figure_type": "schematic"}, "1804.05995v2-Table1-1.png": {"caption": "Top 5 section recommendations for the Wikipedia article lausanne, according to various methods.", "content_type": "table", "figure_type": "table"}, "1804.05995v2-Figure5-1.png": {"caption": "Precision and recall as a function of the number of recommended sections k , for all methods we evaluate.", "content_type": "figure", "figure_type": "plot"}, "1804.05995v2-Figure4-1.png": {"caption": "Percentage of categories (y-axis) that can generate at least x recommendations using the section-count\u2013based", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "What are the top 5 section recommendations for the Wikipedia article on Lausanne according to the category-section counts method?", "answer": "The top 5 section recommendations for the Wikipedia article on Lausanne according to the category-section counts method are HISTORY, DEMOGRAPHICS, ECONOMY, EDUCATION, and POLITICS.", "explanation": "The table in the figure shows the top 5 section recommendations for the Wikipedia article on Lausanne according to four different methods. The category-section counts method is one of these methods. The top 5 recommendations for this method are listed in the third column of the table.", "reference": "1804.05995v2-Table1-1.png"}, {"question": "What is the trend in precision and recall as the number of recommended sections k increases?", "answer": "Precision generally decreases and recall generally increases as k increases.", "explanation": "This can be seen in all four subplots of the figure. For example, in (a), the blue line representing precision starts at a high value for small k and then decreases as k increases, while the red line representing recall starts at a low value for small k and then increases as k increases.", "reference": "1804.05995v2-Figure5-1.png"}, {"question": "What is the percentage of categories that can generate at least 10 recommendations using the section-count-based method?", "answer": "Around 68%.", "explanation": "The figure shows that the percentage of categories that can generate at least 10 recommendations is 60%. This can be seen by looking at the bar for length 10 on the x-axis and following it up to the y-axis.", "reference": "1804.05995v2-Figure4-1.png"}]}, "1811.06635v1": {"paper_id": "1811.06635v1", "all_figures": {"1811.06635v1-Table1-1.png": {"caption": "Sample Complexity Results for Structured Sparsity Models (d is the dimension of the true signal, s is the signal sparsity, i.e., the number of non-zero entries, g is the number of connected components, \u03c1(G) is the maximum weight degree of graph G, B is the weight budget in the weighted graph model, K is the block sparsity, J is the number of entries in a block and N is the total number of blocks in the block structured sparsity model \u2013 detailed explanation of notations are provided in Sections 3 and 5)", "content_type": "table", "figure_type": "table"}, "1811.06635v1-Figure1-1.png": {"caption": "Block sparsity structure as a weighted graph model: nodes are variables, black nodes are selected variables", "content_type": "figure", "figure_type": "schematic"}, "1811.06635v1-Figure2-1.png": {"caption": "An example of constructing an underlying graph for \u03c1(G) = 2 and B s\u2212g = 2", "content_type": "figure", "figure_type": "** Schematic"}, "1811.06635v1-Figure3-1.png": {"caption": "An example of an underlying graph G for (G, s, g,B) \u2212 WGM with parameters d = 15, s = 10, g = 5, B = 5, \u03c1(G) = 2", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "What is the sample complexity lower bound for recovering a tree-structured sparse signal using standard compressed sensing?", "answer": "\u03a9(s)", "explanation": "The table in the figure shows the sample complexity lower and upper bounds for different sparsity structures and compressed sensing methods. For standard compressed sensing and a tree-structured sparsity model, the lower bound is \u03a9(s), where s is the signal sparsity.", "reference": "1811.06635v1-Table1-1.png"}]}, "1804.07707v2": {"paper_id": "1804.07707v2", "all_figures": {"1804.07707v2-Figure1-1.png": {"caption": "An example AMR graph, with variable names and verb senses, followed by the input to our system after preprocessing, and finally two sample realisations different in syntax.", "content_type": "figure", "figure_type": "schematic"}, "1804.07707v2-Table3-1.png": {"caption": "Table 3: BLEU results for generation.", "content_type": "table", "figure_type": "N/A"}, "1804.07707v2-Table2-1.png": {"caption": "Table 2: Average number of acceptable realisations out of 3. The difference is significant with p < 0.001.", "content_type": "table", "figure_type": "N/A"}, "1804.07707v2-Table1-1.png": {"caption": "Table 1: Parsing scores on LDC2017T10 dev set.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "How does the performance of the proposed model compare to other models when trained on the LDC2017T10 dataset, and what does this suggest about the effectiveness of incorporating syntax into the model?", "answer": "When trained on the LDC2017T10 dataset, the proposed model achieves the highest BLEU scores on both Dev and Test sets compared to other models listed in the table. This suggests that incorporating syntax into the model significantly improves its performance in generating text from AMR representations.", "explanation": "Table 1 presents BLEU scores for different models trained on various datasets. Comparing the scores of \"Our model\" to other models trained on LDC2017T10 specifically allows us to isolate the impact of the proposed approach on the same data. The higher BLEU scores achieved by \"Our model\" indicate that incorporating syntax leads to better generation quality compared to models without this feature.", "reference": "1804.07707v2-Table3-1.png"}, {"question": "How does explicitly modeling meaning-preserving invariances impact the generation of paraphrases?", "answer": "Explicitly modeling meaning-preserving invariances leads to the generation of better paraphrases.", "explanation": "Table 1 shows that the syntax-aware model, which explicitly models these invariances, produces a significantly higher average number of acceptable realisations (1.52) compared to the baseline model (1.19). This difference is statistically significant with p < 0.001. The passage further explains that this improvement is due to the explicit modeling of meaning-preserving invariances, allowing the model to generate more paraphrases that retain the same meaning as the reference realization.", "reference": "1804.07707v2-Table2-1.png"}, {"question": "Which model performs the best at predicting the delexicalised constituency tree of an example, and how much better does it perform compared to the baseline model in terms of unlabelled F1 score?", "answer": "The Text-to-parse model performs the best at predicting the delexicalised constituency tree, achieving an unlabelled F1 score of 87.5. This is significantly higher than the baseline Unconditional model, which achieves an unlabelled F1 score of 38.5. The Text-to-parse model therefore performs approximately 49 points better than the baseline.", "explanation": "Table 1 presents the parsing scores of different models on both labelled and unlabelled F1 metrics. By comparing the F1 scores across the models, we can identify which model performs best. The passage further clarifies that the Unconditional model serves as a baseline for comparison, as it does not leverage any information from the text or AMR graph. Therefore, the difference in unlabelled F1 scores between the Text-to-parse and Unconditional models demonstrates the improvement gained by utilizing textual information for predicting the syntactic structure.", "reference": "1804.07707v2-Table1-1.png"}]}, "1804.07931v2": {"paper_id": "1804.07931v2", "all_figures": {"1804.07931v2-Table1-1.png": {"caption": "Table 1: Statistics of experimental datasets.", "content_type": "table", "figure_type": "N/A"}, "1804.07931v2-Table2-1.png": {"caption": "Table 2: Comparison of different models on Public Dataset.", "content_type": "table", "figure_type": "N/A"}, "1804.07931v2-Figure3-1.png": {"caption": "Figure 3: Comparison of different models w.r.t. different sampling rates on Product Dataset.", "content_type": "figure", "figure_type": "plot"}, "1804.07931v2-Figure2-1.png": {"caption": "Figure 2: Architecture overview of ESMM for CVR modeling. In ESMM, two auxiliary tasks of CTR and CTCVR are introduced which: i) help to model CVR over entire input space, ii) provide feature representation transfer learning. ESMM mainly consists of two sub-networks: CVR network illustrated in the left part of this figure and CTR network in the right part. Embedding parameters of CTR and CVR network are shared. CTCVR takes the product of outputs from CTR and CVR network as the output.", "content_type": "figure", "figure_type": "** Schematic"}, "1804.07931v2-Figure1-1.png": {"caption": "Illustration of sample selection bias problem in conventional CVRmodeling. Training space is composed of samples with clicked impressions. It is only part of the inference space which is composed of all impressions.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "What are the two auxiliary tasks that are used in the ESMM architecture for CVR modeling?", "answer": "The two auxiliary tasks are CTR and CTCVR.", "explanation": " The figure shows that the ESMM architecture consists of two sub-networks: a CVR network and a CTR network. The CTR network is used to predict the click-through rate, while the CVR network is used to predict the conversion rate. The CTCVR task takes the product of the outputs from the CTR and CVR networks as its output. ", "reference": "1804.07931v2-Figure2-1.png"}, {"question": "What is the relationship between clicks and impressions?", "answer": "Clicks are a subset of impressions.", "explanation": "The figure shows that the set of clicks is completely contained within the set of impressions. This means that every click is also an impression, but not every impression is a click.", "reference": "1804.07931v2-Figure1-1.png"}, {"question": "How much more prevalent are click events compared to conversion events in the Product Dataset?", "answer": "Click events are roughly 184 times more prevalent than conversion events in the Product Dataset.", "explanation": "Table 1 shows that the Product Dataset has 324 million clicks and 1.774 million conversions. Dividing the number of clicks by the number of conversions (324M / 1.774M) gives us approximately 184. This demonstrates the data sparsity issue mentioned in the passage, where conversion events are significantly rarer than click events.", "reference": "1804.07931v2-Table1-1.png"}, {"question": "Which model performs best overall on both the CVR and CTCVR tasks?", "answer": "The ESMM model performs the best overall on both the CVR and CTCVR tasks.", "explanation": "Table 1 shows the AUC (Area Under the Curve) values for different models on both the CVR and CTCVR tasks. The higher the AUC value, the better the model performs. We can see that ESMM has the highest AUC values for both tasks (68.56 \u00b1 0.37 for CVR and 65.32 \u00b1 0.49 for CTCVR), indicating superior performance compared to other models.", "reference": "1804.07931v2-Table2-1.png"}, {"question": "How does the performance of ESMM compare to other models on the CVR task and CTCVR task with different training set sizes?", "answer": "ESMM-NS and ESMM outperform all other models consistently across different training set sizes on both the CVR and CTCVR tasks.", "explanation": "The figure shows the AUC of different models on the CVR and CTCVR tasks with different training set sizes. The lines for ESMM-NS and ESMM are consistently above the lines for the other models, indicating that they have higher AUC values.", "reference": "1804.07931v2-Figure3-1.png"}]}, "1705.08016v3": {"paper_id": "1705.08016v3", "all_figures": {"1705.08016v3-Figure2-1.png": {"caption": "(left) Variation of test accuracy on CUB-200-2011 with logarithmic variation in hyperparameter \u03bb. (right) Convergence plot of GoogLeNet on CUB-200-2011.", "content_type": "figure", "figure_type": "plot"}, "1705.08016v3-Table2-1.png": {"caption": "Pairwise Confusion (PC) obtains state-of-the-art performance on six widelyused fine-grained visual classification datasets (A-F). Improvement over the baseline model is reported as (\u2206). All results averaged over 5 trials.", "content_type": "table", "figure_type": "table"}, "1705.08016v3-Figure3-1.png": {"caption": "Fig. 3. Pairwise Confusion (PC) obtains improved localization performance, as demonstrated here with Grad-CAM heatmaps of the CUB-200-2011 dataset images (left) with a VGGNet-16 model trained without PC (middle) and with PC (right). The objects in (a) and (b) are correctly classified by both networks, and (c) and (d) are correctly classified by PC, but not the baseline network (VGG-16). For all cases, we consistently observe a tighter and more accurate localization with PC, whereas the baseline VGG-16 network often latches on to artifacts, even while making correct predictions.", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.08016v3-Table1-1.png": {"caption": "A comparison of fine-grained visual classification (FGVC) datasets with largescale visual classification (LSVC) datasets. FGVC datasets are significantly smaller and noisier than LSVC datasets.", "content_type": "table", "figure_type": "table"}, "1705.08016v3-Table4-1.png": {"caption": "Table 4. Pairwise Confusion (PC) improves localization performance in fine-grained visual classification tasks. On the CUB-200-2011 dataset, PC obtains an average improvement of 3.4% in Mean Intersection-over-Union (IoU) for Grad-CAM bounding boxes for each of the five baseline models.", "content_type": "table", "figure_type": "N/A"}, "1705.08016v3-Table3-1.png": {"caption": "Table 3. Experiments with ImageNet and CIFAR show that datasets with large intraclass variation and high inter-class similarity benefit from optimization with Pairwise Confusion. Only the mean accuracy over 3 Imagenet-Random experiments is shown.", "content_type": "table", "figure_type": "N/A"}, "1705.08016v3-Figure1-1.png": {"caption": "Fig. 1. CNN training pipeline for Pairwise Confusion (PC). We employ a Siamese-like architecture, with individual cross entropy calculations for each branch, followed by a joint energy-distance minimization loss. We split each incoming batch of samples into two mini-batches, and feed the network pairwise samples.", "content_type": "figure", "figure_type": "** Schematic"}}, "qa": [{"question": "How does the test accuracy of the different models vary with the hyperparameter \u03bb?", "answer": "The test accuracy of all models decreases as \u03bb increases.", "explanation": "The left plot shows the test accuracy of the different models as a function of \u03bb. The x-axis is logarithmic, so the values of \u03bb increase from left to right. The y-axis shows the test accuracy, which decreases for all models as \u03bb increases.", "reference": "1705.08016v3-Figure2-1.png"}, {"question": "Which method achieves the highest Top-1 accuracy on the CUB-200-2011 dataset?", "answer": "PC-DenseNet-161", "explanation": "The table shows the Top-1 accuracy for each method on the CUB-200-2011 dataset. PC-DenseNet-161 has the highest Top-1 accuracy of 86.87.", "reference": "1705.08016v3-Table2-1.png"}, {"question": "How does Pairwise Confusion (PC) affect the localization ability of a CNN?", "answer": "PC improves the localization ability of a CNN.", "explanation": "Figure 4 shows Grad-CAM heatmaps of images from the CUB-200-2011 dataset, with and without PC. The heatmaps show that PC-trained models provide tighter, more accurate localization around the target object, whereas baseline models sometimes have localization driven by image artifacts. For example, in Figure 4(a), the baseline VGG-16 network pays significant attention to a cartoon bird in the background, even though it makes the correct prediction. With PC, the attention is limited almost exclusively to the correct object.", "reference": "1705.08016v3-Figure3-1.png"}, {"question": "Which dataset has the highest number of samples per class?", "answer": "SVHN", "explanation": "The table shows the number of samples per class for each dataset. SVHN has the highest number of samples per class with 7325.7.", "reference": "1705.08016v3-Table1-1.png"}, {"question": "Which dataset benefited more from the Pairwise Confusion (PC) optimization method: ImageNet-Dogs or ImageNet-Random?", "answer": "ImageNet-Dogs benefited more from the PC optimization method compared to ImageNet-Random.", "explanation": "The table shows the classification accuracy with and without PC for both datasets. While both datasets show improvement with PC, the gain in accuracy for ImageNet-Dogs (1.45%) is significantly higher than that for ImageNet-Random (0.54% \u00b1 0.28%). This aligns with the passage's explanation that PC provides a larger benefit for datasets with higher inter-class similarity and intra-class variation, which is the case for ImageNet-Dogs compared to ImageNet-Random.", "reference": "1705.08016v3-Table3-1.png"}, {"question": "What is the role of the shared weights in the Siamese-like architecture shown in the first figure?", "answer": "The shared weights allow the two branches of the network to learn similar representations of the input images. This helps to improve the performance of the Euclidean Confusion loss, which measures the distance between the conditional probability distributions of the two branches.", "explanation": " The figure shows that the two branches of the network share the same weights, which means that they are learning the same features from the input images. This is important for the Euclidean Confusion loss because it needs to compare the representations of the two images in order to determine how similar they are. If the two branches of the network were not learning similar representations, then the Euclidean Confusion loss would be less effective.", "reference": "1705.08016v3-Figure1-1.png"}]}, "1811.08257v1": {"paper_id": "1811.08257v1", "all_figures": {"1811.08257v1-Figure3-1.png": {"caption": "The convolution operations for multiple channels in plaintext.", "content_type": "figure", "figure_type": "Schematic"}, "1811.08257v1-Table4-1.png": {"caption": "Benchmarks for the Softmax.", "content_type": "table", "figure_type": "table"}, "1811.08257v1-Table5-1.png": {"caption": "Performance Comparison on MNIST and CIFAR10.", "content_type": "table", "figure_type": "table"}, "1811.08257v1-Table6-1.png": {"caption": "Prediction Accuracy on MNIST and CIFAR-10.", "content_type": "table", "figure_type": "table"}, "1811.08257v1-Figure4-1.png": {"caption": "Boolean circuits for data preprocessing.", "content_type": "figure", "figure_type": "\"other\""}, "1811.08257v1-Figure1-1.png": {"caption": "An example of convolutional neural networks.", "content_type": "figure", "figure_type": "schematic"}, "1811.08257v1-Figure2-1.png": {"caption": "Convolution operation.", "content_type": "figure", "figure_type": "Schematic"}, "1811.08257v1-Table3-1.png": {"caption": "Benchmarks for ReLU and Max Pooling.", "content_type": "table", "figure_type": "table"}, "1811.08257v1-Table2-1.png": {"caption": "Benchmarks and Comparisons for Conv and FC.", "content_type": "table", "figure_type": "table"}, "1811.08257v1-Figure5-1.png": {"caption": "Original ReLU and Max Pooling v.s. Our Max Pooling and ReLU.", "content_type": "figure", "figure_type": "\"other\""}}, "qa": [{"question": "How is convolution represented in the frequency domain?", "answer": "In the frequency domain, convolution is represented by element-wise multiplication.", "explanation": "The figure shows how convolution is performed in the frequency domain. First, the FFT (Fast Fourier Transform) is applied to the filter kernel f and the input signal x. Then, the two resulting frequency domain representations F(f) and F(x) are multiplied element-wise. Finally, the IFFT (Inverse Fast Fourier Transform) is applied to the result to obtain the convolution output in the spatial domain.", "reference": "1811.08257v1-Figure3-1.png"}, {"question": "How does the number of classes affect the setup and online time for the Softmax?", "answer": "The setup and online time for the Softmax increases as the number of classes increases.", "explanation": "The table shows that the setup and online time for the Softmax increases as the number of classes increases. For example, when the number of classes is 10, the setup time is 8.56 ms and the online time is 3.89 ms. When the number of classes is 1000, the setup time is 574.8 ms and the online time is 254.6 ms. This is because the Softmax needs to compute the probability of each class, and the more classes there are, the more computations are needed.", "reference": "1811.08257v1-Table4-1.png"}, {"question": "Which framework has the lowest total communication cost for MNIST?", "answer": "FALCON", "explanation": "The table shows that FALCON has the lowest total communication cost for MNIST, with a total of 92.5 MB.", "reference": "1811.08257v1-Table5-1.png"}, {"question": "What is the function of the DataPreprocessing function?", "answer": "The DataPreprocessing function performs Yao Sharing, which is a cryptographic technique for securely sharing data between multiple parties.", "explanation": "The code in the image shows that the DataPreprocessing function takes three inputs: x_C, x_S, and P. It then performs a series of operations using the ADDGate, GTGate, SUBGate, and MUXGate functions. These operations are used to implement Yao Sharing.", "reference": "1811.08257v1-Figure4-1.png"}, {"question": "Which framework is faster for setting up and running the FC layer?", "answer": "FALCON is faster for both setting up and running the FC layer.", "explanation": "The table shows that FALCON has a setup time of 1.2 ms and an online time of 0.1 ms for the FC layer, while GAZELLE has a setup time of 16.2 ms and an online time of 8.0 ms.", "reference": "1811.08257v1-Table2-1.png"}, {"question": "What is the purpose of the `SubsetGate` function in the MaxPooling function?", "answer": "The `SubsetGate` function is used to split the input `x` into `k` pieces.", "explanation": "The code snippet in the figure shows that the `SubsetGate` function is called with the input `x` as an argument. The comment above the function call states that this is done to split `x` into `k` pieces.", "reference": "1811.08257v1-Figure5-1.png"}, {"question": "What is the purpose of the activation layer in a convolutional neural network?", "answer": "The activation layer applies a non-linear function to the output of the convolution layer. This allows the network to learn more complex features from the data.", "explanation": "The activation layer is shown in the figure as a box with the label \"ReLU\". The ReLU function is a common activation function that sets all negative values to zero and keeps all positive values the same. This non-linearity allows the network to learn more complex features than if it only used linear functions.", "reference": "1811.08257v1-Figure1-1.png"}, {"question": "What is the role of the filter in the convolution operation?", "answer": "The filter is used to extract features from the input image. It is a small matrix that is applied to each pixel in the image, and the result is a new pixel value.", "explanation": "The figure shows the filter as a small blue box with the label \"fh * fw\". The filter is applied to the input image (the large orange box) and the result is a new image (the smaller orange box). The red lines show the path of the filter as it is applied to the image.", "reference": "1811.08257v1-Figure2-1.png"}, {"question": "Which operation has the lowest online time?", "answer": "ReLU", "explanation": "The online time for ReLU is 4.20 ms, which is the lowest value in the \"online\" column of the table.", "reference": "1811.08257v1-Table3-1.png"}]}, "1805.00912v4": {"paper_id": "1805.00912v4", "all_figures": {"1805.00912v4-Figure1-1.png": {"caption": "(a) Memory consumption and (b) time cost vs. sequence length on synthetic data; (c) memory load (x-axis), inference time on dev set (y-axis) and test accuracy on the SNLI dataset.", "content_type": "figure", "figure_type": "plot"}, "1805.00912v4-Table3-1.png": {"caption": "Table 3: An ablation study of MTSA on SNLI.", "content_type": "table", "figure_type": "N/A"}, "1805.00912v4-Table1-1.png": {"caption": "Table 1: Experimental results for different methods with comparative parameter number on SNLI. |\u03b8|: the number of parameters (excluding word embedding part); Time/Epoch: averaged training time per epoch with batch size 128; Inf. Time: averaged dev inference time with batch size 128; Memory: memory load on synthetic data of sequence length 64 and batch size 64 with back-propagation considered; Train Acc. and Test Acc.: the accuracies on training/test sets. All state-of-the-art methods in leaderboard are listed in Table 1&2 up to Sep. 2018.", "content_type": "table", "figure_type": "N/A"}, "1805.00912v4-Table2-1.png": {"caption": "Experimental results on sentence-encoding based SNLI and MultiNLI benchmark tasks. \u201cTransfer\u201d denotes pretrained language model on large corpus for transfer learning, which detailed by Radford et al. (2018). References: a(Nie and Bansal, 2017), b(Chen et al., 2018), c(Talman et al., 2018).", "content_type": "table", "figure_type": "table"}, "1805.00912v4-Table4-1.png": {"caption": "Table 4: Experimental Results of SRL for single models on CoNLL-05 with gold predicates. \u2217Multi-head baseline is equivalent to the model in Tan et al. (2017). For fair comparisons, first, we use the hyper-parameters provided by Tan et al. (2017) instead of tuning them; second, all listed models are independent of external linguistics information, e.g., PoS, dependency parsing.", "content_type": "table", "figure_type": "N/A"}, "1805.00912v4-Table5-1.png": {"caption": "Experimental results on five sentence classification benchmarks. References: a(Mikolov et al., 2013), b(Kiros et al., 2015), c(Kalchbrenner et al., 2014), d(Lei and Zhang, 2017).", "content_type": "table", "figure_type": "table"}, "1805.00912v4-Figure2-1.png": {"caption": "Tensorized self-attention (TSA) Mechanism.", "content_type": "figure", "figure_type": "Schematic"}, "1805.00912v4-Table6-1.png": {"caption": "Table 6: Results for the Transformer with either multihead self-attention or proposed MTSA. The reported BLEU values for Setup 1 and 2 are the mean of 5 and 3 runs respectively.", "content_type": "table", "figure_type": "N/A"}, "1805.00912v4-Figure3-1.png": {"caption": "Heatmaps for normalized token2token and source2token alignment scores with forward and backward masks. Each row shows three types of scores associated with the tokens from a same sentence: token2token alignment scores in TSA with forward mask (left), token2token alignment scores in TSA with backward masks (middle), source2token alignment scores at token level for the two heads with forward and backward masks (right). The tokens in x-axis and y-axis are the dependent and governor tokens, respectively.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which model has the lowest memory consumption and time cost on synthetic data?", "answer": "MTSA", "explanation": "Figure (a) and (b) show that the MTSA model has the lowest memory consumption and time cost for all sequence lengths.", "reference": "1805.00912v4-Figure1-1.png"}, {"question": "Which model has the highest test accuracy on the SNLI dataset, and how does its training time per epoch compare to the MTSA model?", "answer": "The model with the highest test accuracy is MTSA, with an accuracy of 86.3%. Its training time per epoch is 180s, which is faster than the training time of several other models with lower accuracy, such as Bi-LSTM (854s), Bi-GRU (850s), and DiSA (390s).", "explanation": "The table shows the test accuracy and training time per epoch for various models. By comparing these values across different models, we can identify the model with the best performance and understand its relative training efficiency. In this case, MTSA achieves the highest test accuracy while also having a relatively fast training time per epoch.", "reference": "1805.00912v4-Table1-1.png"}, {"question": "Which model performed best on the SNLI test set?", "answer": "The Transfer + MTSA model performed best on the SNLI test set with an accuracy of 86.9%.", "explanation": "The table shows the accuracy of different models on the SNLI and MultiNLI benchmark tasks. The Transfer + MTSA model has the highest accuracy on the SNLI test set.", "reference": "1805.00912v4-Table2-1.png"}, {"question": "Based on the table, how does MTSA compare to the Bi-LSTM and Multi-CNN baselines in terms of performance and training time?", "answer": "MTSA outperforms both Bi-LSTM and Multi-CNN baselines across all evaluation metrics (P, R, F1, and Comp.) on all three test sets (Development, WSJ Test, and Brown Test). While MTSA achieves the highest scores, its training time is comparable to Multi-head and Multi-CNN, and significantly faster than Bi-LSTM.", "explanation": "The table displays the performance of various SRL models on different test sets, along with their training times. By comparing the values in the MTSA row to those in the Bi-LSTM and Multi-CNN rows, we can see that MTSA consistently achieves higher scores across all metrics while maintaining a similar training time to Multi-CNN and a much faster training time than Bi-LSTM. This demonstrates the superior performance and efficiency of MTSA compared to these two baselines.", "reference": "1805.00912v4-Table4-1.png"}, {"question": "What is the purpose of the positional mask in the TSA mechanism?", "answer": "The positional mask is used to provide information about the relative position of tokens in the input sequence. This information is used to compute the attention weights, which determine how much each token attends to each other token.", "explanation": "The figure shows that the positional mask is used as input to the Softmax function, which computes the attention weights. The positional mask is a matrix of values that indicate the relative position of each token in the input sequence. This information is used to compute the attention weights, which determine how much each token attends to each other token.", "reference": "1805.00912v4-Figure2-1.png"}]}, "1705.07384v2": {"paper_id": "1705.07384v2", "all_figures": {"1705.07384v2-Figure2-1.png": {"caption": "Policy learning results in Ex. 2; numbers denote regret", "content_type": "figure", "figure_type": "plot"}, "1705.07384v2-Table2-1.png": {"caption": "Policy learning results in Ex. 3", "content_type": "table", "figure_type": "table"}}, "qa": [{"question": "Which policy learning method achieved the lowest regret in Ex. 2?", "answer": "The DR-SVM method achieved the lowest regret in Ex. 2, with a regret of 0.18.", "explanation": "The figure shows the regret for each policy learning method in Ex. 2. The DR-SVM method has the lowest regret, as indicated by the number 0.18 below its corresponding plot.", "reference": "1705.07384v2-Figure2-1.png"}]}, "1705.09296v2": {"paper_id": "1705.09296v2", "all_figures": {"1705.09296v2-Table1-1.png": {"caption": "Table 1: Performance of our various models in an unsupervised setting (i.e., without labels or covariates) on the IMDB dataset using a 5,000-word vocabulary and 50 topics. The supplementary materials contain additional results for 20 newsgroups and Yahoo answers.", "content_type": "table", "figure_type": "N/A"}, "1705.09296v2-Table6-1.png": {"caption": "Topics from the unsupervised SCHOLAR on the 20 newsgroups dataset, and the corresponding internal coherence values.", "content_type": "table", "figure_type": "table"}, "1705.09296v2-Table2-1.png": {"caption": "Table 2: Accuracy of various models on three datasets with categorical labels.", "content_type": "table", "figure_type": "N/A"}, "1705.09296v2-Figure2-1.png": {"caption": "Figure 2: Topics inferred by a joint model of words and tone, and the corresponding probability of proimmigration tone for each topic. A topic is represented by the top words sorted by word probability throughout the paper.", "content_type": "figure", "figure_type": "** plot"}, "1705.09296v2-Figure3-1.png": {"caption": "Figure 3: Learned embeddings of year-ofpublication (treated as a covariate) from combined model of news articles about immigration.", "content_type": "figure", "figure_type": "plot"}, "1705.09296v2-Figure1-1.png": {"caption": "Figure 1a presents the generative story of our model. Figure 1b illustrates the inference network using the reparametrization trick to perform variational inference on our model. Shaded nodes are observed; double circles indicate deterministic transformations of parent nodes.", "content_type": "figure", "figure_type": "schematic"}, "1705.09296v2-Table4-1.png": {"caption": "Performance of various models on the 20 newsgroups dataset with 20 topics and a 2,000- word vocabulary.", "content_type": "table", "figure_type": "table"}, "1705.09296v2-Table5-1.png": {"caption": "Table 5: Performance of various models on the Yahoo answers dataset with 250 topics and a 5,000- word vocabulary. SAGE did not finish in 72 hours so we omit it from this table.", "content_type": "table", "figure_type": "N/A"}, "1705.09296v2-Table3-1.png": {"caption": "Table 3: Top words for topics (left) and the corresponding anti-immigration (middle) and pro-immigration (right) variations when treating tone as a covariate, with interactions.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "Which year is most associated with the terms \"sept\", \"hijackers\", and \"attacks\"?", "answer": "2001", "explanation": "The figure shows that the year 2001 is located highest on the vertical axis, which is associated with the terms \"sept\", \"hijackers\", and \"attacks\". This suggests that these terms are most prevalent in articles published in 2001.", "reference": "1705.09296v2-Figure3-1.png"}, {"question": "Which node in the generative model represents the latent variable?", "answer": "The node labeled \u03b7 represents the latent variable.", "explanation": "Latent variables are not directly observed, but are inferred from the observed data. In the generative model,  \u03b7  is not shaded, indicating that it is not observed.", "reference": "1705.09296v2-Figure1-1.png"}, {"question": "Which model achieves the best NPMI scores (both internal and external) in the unsupervised setting, and what trade-off does this model exhibit compared to other models?", "answer": "The Scholar + w.v. model achieves the best NPMI scores (both internal and external) in the unsupervised setting. However, this model also has the highest number of people parameters, indicating a trade-off between topic coherence and model complexity.", "explanation": "Table 1 shows the performance of various topic models on the IMDB dataset in an unsupervised setting. The NPMI scores (both internal and external) measure the coherence of the topics generated by each model, with higher scores indicating more coherent topics. The \"Ppl.\" column indicates the number of people parameters in each model, which reflects its complexity. By comparing the NPMI scores and the number of people parameters across the models, we can identify the trade-offs between topic coherence and model complexity. In this case, Scholar + w.v. achieves the best coherence but also requires the most parameters.", "reference": "1705.09296v2-Table1-1.png"}, {"question": "Which topic has the highest internal coherence value?", "answer": "The topic with the highest internal coherence value is \"turks armenian armenia turkish roads escape soviet muslim mountain soul\".", "explanation": "The table shows the internal coherence values for each topic. The topic with the highest value is listed at the top of the table.", "reference": "1705.09296v2-Table6-1.png"}, {"question": "Which model performed best on the IMDB dataset for classifying documents with categorical labels, and how much better did it perform compared to the SLDA model?", "answer": "Both the SCHOLAR (covariates) and Logistic Regression models achieved the highest accuracy of 0.87 on the IMDB dataset. This represents a 0.23 improvement over the SLDA model, which achieved an accuracy of 0.64.", "explanation": "Table 1 displays the accuracy of different models on three datasets, including IMDB. By comparing the accuracy values in the IMDB column, we can identify the best performing model(s). The difference in accuracy between the top model(s) and SLDA can be calculated by subtracting the SLDA accuracy from the highest accuracy value.", "reference": "1705.09296v2-Table2-1.png"}, {"question": "Which topic is most likely to be associated with a pro-immigration stance?", "answer": "\"english language city spanish community\"", "explanation": " The figure shows the probability of pro-immigration tone for each topic, and \"english language city spanish community\" has the highest probability (close to 1). This suggests that articles that discuss topics related to English language, city, Spanish community are more likely to have a pro-immigration stance.", "reference": "1705.09296v2-Figure2-1.png"}, {"question": "How does the model capture different perspectives on immigration when considering tone as a covariate?", "answer": "The model captures different perspectives on immigration by highlighting contrasting words associated with the same topic, depending on whether the tone is anti-immigration or pro-immigration.", "explanation": "Table 1 displays several base topics related to immigration. For each topic, the table shows the most significant words associated with the anti-immigration and pro-immigration interactions. These words often represent opposing viewpoints on the same issue. For example, the topic \"ice customs agency enforcement homeland\" has contrasting words like \"criminal\" and \"detainees\" for anti-immigration and pro-immigration perspectives, respectively. This pattern suggests that the model can differentiate between different stances on immigration by considering the interaction between tone and topic.", "reference": "1705.09296v2-Table3-1.png"}]}, "1805.01216v3": {"paper_id": "1805.01216v3", "all_figures": {"1805.01216v3-Figure1-1.png": {"caption": "Figure 1: Performance of various task-oriented dialog systems on the CamRest dataset as the percentage of unseen information in the KB changes.", "content_type": "figure", "figure_type": "plot"}, "1805.01216v3-Table4-1.png": {"caption": "Table 4: Example from bAbI Task 5 KA test set with 100% OOV entities. Identifying the address of an unseen restaurant is challenging for all models.", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Table3-1.png": {"caption": "Table 3: AMT Evaluations on CamRest and SMD", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Table1-1.png": {"caption": "Table 1: Per-response and per-dialog accuracies (in brackets) on bAbI dialog tasks of BOSSNET and baselines .", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Table2-1.png": {"caption": "Table 2: Performance of BOSSNET and baselines on the CamRest and SMD datasets", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Figure8-1.png": {"caption": "Figure 8: Pre-processing of bAbI dialog data used in Mem2Seq paper", "content_type": "figure", "figure_type": "** Table"}, "1805.01216v3-Figure2-1.png": {"caption": "Figure 2: The dialog history and KB tuples stored in the memory have memory cell representations and token representations. The encoder understands the last user utterance using only the memory cell representations. The decoder generates the next response using both representations.", "content_type": "figure", "figure_type": "schematic"}, "1805.01216v3-Table5-1.png": {"caption": "Table 5: AMT Evaluations on CamRest and SMD (50% unseen) KA datasets", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Table13-1.png": {"caption": "Table 13: Example from SMD with 50% OOV. The OOV entity present in the dialog is {pittsburgh}", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Table14-1.png": {"caption": "Table 14: Ablation study: impact of hops in BOSSNET encoder", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Table11-1.png": {"caption": "Table 11: Example from Camrest with 50% OOV. The OOV entities present in the dialog are {ethiopian, 22 atlantis road}", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Table10-1.png": {"caption": "Table 10: Example from bAbI dialog Task 1 with 100% OOV.", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Table12-1.png": {"caption": "Table 12: Example from SMD", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Figure4-1.png": {"caption": "bAbI Task 5: Per-response accuracy comparison on KA sets", "content_type": "figure", "figure_type": "plot."}, "1805.01216v3-Figure5-1.png": {"caption": "CamRest: Entity F1 comparison on KA sets Figure 6: SMD: Entity F1 comparison on KA sets", "content_type": "figure", "figure_type": "plot"}, "1805.01216v3-Table6-1.png": {"caption": "Table 6: Ablation study: impact of each model element on BOSSNET", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Figure3-1.png": {"caption": "bAbI Task 1: Per-response accuracy comparison on KA sets", "content_type": "figure", "figure_type": "plot"}, "1805.01216v3-Figure10-1.png": {"caption": "A sample HIT on Amazon Mechanical Turk to (a) validate useful responses based on the given dialog context, and (b) validate grammatical correctness of different responses on a scale of 0-3", "content_type": "figure", "figure_type": "\"photograph(s)\""}, "1805.01216v3-Table9-1.png": {"caption": "Table 9: The hyperparameters used to train BOSSNET on the different datasets .", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Figure7-1.png": {"caption": "Figure 7: Visualization of attention weights on selected portions of memory in (a) BOSSNET with two-level attention vs (b) BOSSNET with one-level attention", "content_type": "figure", "figure_type": "** schematic"}, "1805.01216v3-Table7-1.png": {"caption": "Table 7: An example of responses generated by BOSSNET and baselines on the CamRest test set. Thia example has no unseen entities.", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Table8-1.png": {"caption": "Table 8: An example of responses generated by BOSSNET and baselines on bAbI dialog Task-5. This example is from the KA test set with 100% unseen entities.", "content_type": "table", "figure_type": "N/A"}, "1805.01216v3-Figure9-1.png": {"caption": "Figure 9: Pre-processing of SMD Navigate data used in Mem2Seq paper", "content_type": "figure", "figure_type": "** Table"}}, "qa": [{"question": "Which task-oriented dialog system performs the best when the percentage of unseen information in the KB is high?", "answer": "BoSsNet", "explanation": "The figure shows that BoSsNet has the highest BLEU score across all percentages of unseen information in the KB. This suggests that BoSsNet is more robust to changes in the KB than the other systems.", "reference": "1805.01216v3-Figure1-1.png"}, {"question": "Why did Seq2Seq and Mem2Seq models perform poorly when the percentage of unseen entities in the knowledge base (KB) increased?", "answer": "Seq2Seq and Mem2Seq models performed poorly because they struggled to capture the semantic representations of unseen entities. This means they couldn't understand the meaning and relationships of new restaurants introduced in the KB. As a result, they were unable to accurately identify the correct restaurant and provide its address when faced with unseen entities.", "explanation": "The table shows an example where the user requests the address of an \"overpriced\" Thai restaurant in Bangkok. While the correct restaurant is \"r\\_bangkok\\_overpriced\\_thai\\_8\", both Seq2Seq and Mem2Seq models incorrectly provided the address of \"r\\_bangkok\\_overpriced\\_thai\\_4\". This error likely occurred because these models couldn't distinguish between the unseen restaurants in the KB due to their inability to grasp their semantic representations. This example illustrates the general trend observed in Figure 4a and 4b, where the performance of these models declined significantly with increasing unseen entities.", "reference": "1805.01216v3-Table4-1.png"}, {"question": "Which model achieved the highest combined score for informativeness and grammatical correctness on the CamRest dataset?", "answer": "The BOSSNET model achieved the highest combined score for informativeness and grammatical correctness on the CamRest dataset.", "explanation": "The table shows separate scores for informativeness (\"Info\") and grammatical correctness (\"Grammar\") for each model on both the CamRest and SMD datasets. To find the combined score, we simply add the two individual scores. For CamRest, \\sys\\ has an \"Info\" score of 80 and a \"Grammar\" score of 2.44, resulting in a combined score of 82.44, which is higher than any other model on that dataset.", "reference": "1805.01216v3-Table3-1.png"}, {"question": "Can you explain why the BOSSNET with multi-hop encoder performs better on bAbI tasks 3 and 5 compared to the 1-hop encoder, and how this relates to the tasks themselves?", "answer": "The multi-hop encoder performs better on bAbI tasks 3 and 5 because these tasks specifically require inferencing over multiple KB tuples. In other words, the model needs to \"hop\" between different pieces of information in the knowledge base to make the correct inferences and recommendations.\n\nTask 3 involves sorting restaurants by rating, and task 5 requires recommending a restaurant based on user preferences. Both tasks necessitate the model to consider various restaurant attributes and their relationships, which the multi-hop encoder facilitates by capturing longer-range dependencies within the knowledge base.", "explanation": "The table shows that for tasks 3 and 5, the multi-hop encoder achieves higher accuracy compared to the 1-hop encoder. This improvement aligns with the nature of these tasks, which require multi-step reasoning and inference over multiple KB entries. The passage further clarifies this connection by highlighting the need for sorting and recommendation based on various restaurant attributes, achievable through the multi-hop encoder's ability to capture complex relationships within the knowledge base.", "reference": "1805.01216v3-Table14-1.png"}, {"question": "How does the encoder understand the last user utterance?", "answer": "The encoder understands the last user utterance by using the memory cell representations of the dialog history and KB tuples.", "explanation": "The figure shows that the encoder receives input from the memory cell representations of the dialog history and KB tuples. This suggests that the encoder uses these representations to understand the context of the conversation and generate a response.", "reference": "1805.01216v3-Figure2-1.png"}, {"question": "Which model performs best on tasks T3 and T3-OOV in terms of per-dialog accuracy, and how does its performance differ between the two test sets?", "answer": "The proposed system model (BOSSNET) performs best on both tasks T3 and T3-OOV in terms of per-dialog accuracy. However, its performance is significantly higher on the T3-OOV test set (95.7%) compared to the non-OOV T3 test set (95.2%).", "explanation": "The table shows the per-dialog accuracy for each model within parentheses. By comparing the values in the \"\\sys\" column for tasks T3 and T3-OOV, we can see that the model performs better on the OOV version of the task. This is in contrast to the retrieval-based models (QRN, MN, GMN), which generally perform worse on OOV test sets.", "reference": "1805.01216v3-Table1-1.png"}, {"question": "Why might the authors claim that although BOSSNET achieves a lower BLEU score than Mem2Seq on the SMD dataset, it still performs better in conveying necessary entity information?", "answer": "While BOSSNET has a lower BLEU score than Mem2Seq on SMD, it achieves the highest Entity F1 score on that dataset. This suggests that BOSSNET is better at capturing and including the relevant entities in its responses, even though it may not have as much lexical overlap with the gold responses as Mem2Seq.", "explanation": "The table shows both BLEU scores and Entity F1 scores for each model on both datasets. While BLEU score measures the lexical similarity between generated and reference responses, Entity F1 measures how well the model identifies and incorporates relevant entities. By comparing these two metrics, we can see that **\\sys\\** prioritizes including accurate entities even if it sacrifices some lexical overlap with the reference response. The passage further supports this by stating that **\\sys\\** responses \"convey the necessary entity information from the KB\" despite having lower BLEU scores.", "reference": "1805.01216v3-Table2-1.png"}, {"question": "Which model performs the best in terms of Entity F1 score when the percentage of unseen entities in the response is low?", "answer": "BoSsNet", "explanation": "The plot shows that the BoSsNet line is the highest for both CamRest and SMD datasets when the percentage of unseen entities is low.", "reference": "1805.01216v3-Figure5-1.png"}, {"question": " \n\nWhat is the difference between the original and pre-processed SMD Navigate data? ", "answer": " \n\nThe pre-processed SMD Navigate data combines all the properties (such as distance, address) of a point of interest (POI) into a single subject with the object being \"poi\". The original data had separate entries for each property. ", "explanation": " \n\nThe figure shows two tables. The top table is the original SMD Navigate data, and the bottom table is the pre-processed data. In the original data, each property of a POI has its own entry in the table. For example, the POI \"the_westin\" has three entries: one for its distance, one for its traffic information, and one for its address. In the pre-processed data, all of these properties are combined into a single entry with the subject \"2 miles moderate_traffic rest_stop\" and the object \"poi\".", "reference": "1805.01216v3-Figure9-1.png"}, {"question": "Which model performs best when the percentage of unseen entities in the response is low?", "answer": "BoSsNet", "explanation": "The figure shows that the BoSsNet line is at the top when the percentage of unseen entities in the response is low.", "reference": "1805.01216v3-Figure3-1.png"}, {"question": "Which task required the highest learning rate and how does this compare to the learning rate used for CamRest?", "answer": "Task T1 and T2 required the highest learning rate of 0.001. This is twice the learning rate used for CamRest, which was trained with a learning rate of 0.0005.", "explanation": "The table shows the hyperparameters used for training \\sys\\ on different datasets. The \"Learning Rate\" column directly provides the information needed to answer the question. By comparing the values in this column for different tasks, we can determine which task required the highest learning rate and how it compares to the learning rate used for CamRest.", "reference": "1805.01216v3-Table9-1.png"}, {"question": "What is the difference between the attention weights in the two-level attention model and the one-level attention model?", "answer": " The two-level attention model has higher attention weights on the relevant information in the memory, while the one-level attention model has more uniform attention weights.", "explanation": " The figure shows that the two-level attention model has higher attention weights on the entries for \"rest_3_str\" and \"rating 3\", which are relevant to the current decoder prediction. In contrast, the one-level attention model has more uniform attention weights across all the entries in the memory. This suggests that the two-level attention model is able to focus on the most relevant information in the memory, while the one-level attention model is not as selective.", "reference": "1805.01216v3-Figure7-1.png"}]}, "1804.05938v2": {"paper_id": "1804.05938v2", "all_figures": {"1804.05938v2-Figure1-1.png": {"caption": "The performance of DNN trained with different bias corrections with respect to the value of \u03b7.", "content_type": "figure", "figure_type": "plot"}, "1804.05938v2-Table3-1.png": {"caption": "Table 3: Comparison of different unbiased learning-to-rankmodels on Yahoo! LETOR set 1. Significant improvements or degradations with respect to the DNN with DLA are indicated with +/\u2212.", "content_type": "table", "figure_type": "N/A"}, "1804.05938v2-Figure2-1.png": {"caption": "The MSE between the true click propensity and those estimated by DLA and RandList with respect to \u03b7.", "content_type": "figure", "figure_type": "plot"}, "1804.05938v2-Table2-1.png": {"caption": "Table 2: A summary of the ranking features extracted for our real-world experiments.", "content_type": "table", "figure_type": "N/A"}, "1804.05938v2-Table1-1.png": {"caption": "Table 1: A summary of notations used in this paper.", "content_type": "table", "figure_type": "N/A"}, "1804.05938v2-Table4-1.png": {"caption": "Table 4: Comparison of DNN trained with DLA and relevance signals extracted by click models. Significant improvements or degradations with respect to DLA are indicated with +/\u2212.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "Which correction method resulted in the best performance in terms of nDCG@10 and ERR@10, and how does it compare to not using any correction method?", "answer": "The DNN trained with DLA achieved the best performance in terms of both nDCG@10 (0.421) and ERR@10 (0.582). Compared to not using any correction method (NoCorrect), DLA shows a significant improvement in both metrics, with nDCG@10 being higher by 0.063 and ERR@10 being higher by 0.082.", "explanation": "Table 1 presents the performance of different correction methods for DNN models trained on real click data. The nDCG@10 and ERR@10 columns specifically show the performance at a cutoff of 10, meaning they measure how well the models rank the top 10 most relevant items. By comparing the values in these columns across different methods, we can identify which method performs best. In this case, DLA shows the highest values for both metrics, indicating superior performance compared to other methods, including no correction at all.", "reference": "1804.05938v2-Table4-1.png"}, {"question": "Which method performs better in terms of mean square error?", "answer": "DLA performs better than RandList in terms of mean square error.", "explanation": "The plot shows the mean square error (MSE) between the true click propensity and those estimated by DLA and RandList with respect to \u03b7. The MSE for DLA is consistently lower than that of RandList for all values of \u03b7.", "reference": "1804.05938v2-Figure2-1.png"}, {"question": "Explain the difference between the features \"TF-IDF\" and \"BM25\".", "answer": "Both TF-IDF and BM25 are features used to estimate the relevance of a document to a query. However, they differ in their underlying calculations.\n\nTF-IDF: This feature represents the average product of term frequency (TF) and inverse document frequency (IDF) for each query term within different document sections (URL, title, content, and whole document). TF measures how often a term appears in a specific document section, while IDF measures how important that term is across the entire document collection.\n\nBM25: This feature utilizes the BM25 ranking function, which is a probabilistic model that considers term frequency, document length, and average document length to estimate relevance. While it also considers term frequency like TF-IDF, it incorporates additional factors to improve the weighting scheme.", "explanation": "Table 1 provides a summary of the ranking features extracted for the experiments. It explicitly mentions that TF-IDF is based on the average TF*IDF value, while BM25 utilizes the BM25 ranking function. This distinction highlights the different approaches used by each feature to assess document relevance.", "reference": "1804.05938v2-Table2-1.png"}]}, "1705.09882v2": {"paper_id": "1705.09882v2", "all_figures": {"1705.09882v2-Figure3-1.png": {"caption": "Fig. 3. Our model architecture consists of a frame-level feature embedding fCNN , which provides input to both a recurrent layer fLSTM and the Reinforced Temporal Attention (RTA) unit fw (highlighted in red). The classifier is attached to the hidden state ht and its video prediction is the weighted sum of single-frame predictions, where the weights wt for each frame t are predicted by the RTA unit.", "content_type": "figure", "figure_type": "schematic"}, "1705.09882v2-Figure5-1.png": {"caption": "Comparison of our RGB-to-Depth transfer with Yosinski et al. [90] in terms of top-1 accuracy on DPI-T. In this ablation study the x axis represents the number of layers whose weights are frozen (left) or fine-tuned (right) starting from the bottom.", "content_type": "figure", "figure_type": "plot"}, "1705.09882v2-Figure1-1.png": {"caption": "Filter responses from \u201cconv1\u201d (upper right), \u201cconv2\u201d (bottom left) and \u201cconv3\u201d (bottom right) layers for a given frame from the TUM GAID data using (a) a framework for person re-identification from RGB [82] and (b) the feature embedding fCNN of our framework, which is drawn in Fig. 3 and exclusively utilizes depth data.", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.09882v2-Figure7-1.png": {"caption": "Cumulative Matching Curves (CMC) on TUM-GAID for the scenario that the individuals wear clothes which are not provided during training.", "content_type": "figure", "figure_type": "plot"}, "1705.09882v2-Table2-1.png": {"caption": "Top-1 re-identification accuracy (top-1, %) and normalized Area Under the Curve (nAUC, %) on TUM-GAID in newclothes scenario with single-shot (ss) and multi-shot (ms) evaluation", "content_type": "table", "figure_type": "table"}, "1705.09882v2-Figure6-1.png": {"caption": "Example sequence with the predicted Bernoulli parameter printed.", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.09882v2-Table1-1.png": {"caption": "Table 1. Single-shot and multi-shot person re-identification performance on the test set of DPI-T, BIWI and IIT PAVIS. Dashes indicate that no published result is available", "content_type": "table", "figure_type": "N/A"}, "1705.09882v2-Figure4-1.png": {"caption": "Fig. 4. Our split-rate RGB-to-Depth transfer compared with Yosinski et al. [90]. At the top, the two models are trained from scratch with RGB and Depth data. Next we show the \u201cR3D\u201d instances (i.e. the bottom 3 layers\u2019 weights from RGB remain frozen or slowly changing) for both methods, following the notation of [90]. The color of each layer refers to the initialization and the number below is the relative learning rate (the best performing one in bold). The key differences are summarized in the text.", "content_type": "figure", "figure_type": "schematic"}, "1705.09882v2-Figure2-1.png": {"caption": "The cropped color image (left), the grayscale depth representation Dg p (center) and the result after background subtraction (right) using the body index information Bp from skeleton tracking.", "content_type": "figure", "figure_type": "** photograph(s)"}}, "qa": [{"question": "Which method achieves the highest Top-1 Accuracy for multi-shot person re-identification on the BIWI dataset, and how does it compare to the best single-shot method on the same dataset?", "answer": "The proposed method with RTA attention achieves the highest Top-1 Accuracy for multi-shot person re-identification on the BIWI dataset with a score of 50.0%. This is significantly higher than the best single-shot method on the same dataset, which is our method (CNN) with a score of 25.4%.", "explanation": "Table 1 shows the Top-1 Accuracy for different person re-identification methods on various datasets, categorized by single-shot and multi-shot approaches. By looking at the BIWI column and comparing the highest values in both the single-shot and multi-shot sections, we can determine which method performs best in each category and compare their performance.", "reference": "1705.09882v2-Table1-1.png"}, {"question": "How does the proposed split-rate RGB-to-Depth transfer scheme differ from the R3D [90] method of Yosinski et al.?", "answer": "The proposed split-rate RGB-to-Depth transfer scheme differs from the R3D [90] method in two ways. First, the proposed method uses a different learning rate for the bottom three layers of the network. Second, the proposed method uses a different initialization for the weights of the bottom three layers of the network.", "explanation": "The figure shows the two methods side-by-side. The R3D [90] method uses the same learning rate for all layers of the network, while the proposed method uses a lower learning rate for the bottom three layers. Additionally, the R3D [90] method initializes the weights of the bottom three layers with random values, while the proposed method initializes the weights of the bottom three layers with the weights from a pre-trained RGB network.", "reference": "1705.09882v2-Figure4-1.png"}, {"question": "What is the difference between the grayscale depth representation and the result after background subtraction?", "answer": " The grayscale depth representation shows the depth of each pixel in the image, with darker pixels representing closer objects and lighter pixels representing further objects. The result after background subtraction shows only the foreground object, with the background removed.", "explanation": " The figure shows the original image, the grayscale depth representation, and the result after background subtraction. The grayscale depth representation shows that the person in the foreground is closer to the camera than the person in the background. The result after background subtraction shows that the background has been removed, leaving only the person in the foreground.", "reference": "1705.09882v2-Figure2-1.png"}, {"question": "Which modality achieved the highest top-1 accuracy in the multi-shot evaluation on TUM-GAID?", "answer": "Body Depth & Head RGB (ms: LSTM & RTA)", "explanation": "The table shows the top-1 accuracy for each modality in both single-shot and multi-shot evaluations. The highest top-1 accuracy in the multi-shot evaluation is 88.1%, which is achieved by the Body Depth & Head RGB (ms: LSTM & RTA) modality.", "reference": "1705.09882v2-Table2-1.png"}, {"question": "What is the relationship between the Bernoulli parameter and the image?", "answer": "The Bernoulli parameter is a measure of the probability of a pixel being foreground or background. The higher the Bernoulli parameter, the more likely the pixel is to be foreground. This is reflected in the images, where the pixels with higher Bernoulli parameters are more likely to be part of the person's silhouette.", "explanation": "The Bernoulli parameter is a key component of the GrabCut algorithm, which is used to segment images into foreground and background regions. The algorithm works by iteratively assigning pixels to either the foreground or background, based on their similarity to neighboring pixels and the Bernoulli parameter.", "reference": "1705.09882v2-Figure6-1.png"}, {"question": "Which part of the model is responsible for deciding which frames are most important for the re-identification task?", "answer": "The Reinforced Temporal Attention (RTA) unit.", "explanation": "The RTA unit is highlighted in red in the figure, and the caption states that it \"predicts the weights $w_t$ for each frame $t$\". These weights are used to calculate a weighted sum of single-frame predictions, which is the final output of the model. This means that the RTA unit is responsible for deciding which frames are most important for the re-identification task.", "reference": "1705.09882v2-Figure3-1.png"}, {"question": "How does the performance of our RGB-to-Depth transfer compare to Yosinski et al. [90] in terms of top-1 accuracy on DPI-T when all layers are fine-tuned?", "answer": "The proposed RGB-to-Depth transfer performs slightly better than Yosinski et al. [90] in terms of top-1 accuracy on DPI-T when all layers are fine-tuned.", "explanation": "The right panel of the figure shows the top-1 re-identification accuracy for different methods when different numbers of layers are fine-tuned. When all layers are fine-tuned (x=7), our RGB-to-Depth transfer achieves a top-1 accuracy of about 75%, while Yosinski et al. [90] achieves a top-1 accuracy of about 73%.", "reference": "1705.09882v2-Figure5-1.png"}, {"question": "What is the difference between the filter responses from the \u201cconv1\u201d, \u201cconv2\u201d and \u201cconv3\u201d layers for a given frame from the TUM GAID data using a framework for person re-identification from RGB and the feature embedding fCNN of a framework that utilizes depth data?", "answer": "The filter responses from the \u201cconv1\u201d, \u201cconv2\u201d and \u201cconv3\u201d layers for a given frame from the TUM GAID data using a framework for person re-identification from RGB are more detailed and contain more information than the filter responses from the fCNN of a framework that utilizes depth data. This is because RGB images contain more information than depth images.", "explanation": "The figure shows the filter responses from the \u201cconv1\u201d, \u201cconv2\u201d and \u201cconv3\u201d layers for a given frame from the TUM GAID data using a framework for person re-identification from RGB and the feature embedding fCNN of a framework that utilizes depth data. The filter responses from the RGB framework are more detailed and contain more information than the filter responses from the depth framework.", "reference": "1705.09882v2-Figure1-1.png"}]}, "1811.08481v2": {"paper_id": "1811.08481v2", "all_figures": {"1811.08481v2-Figure1-1.png": {"caption": "UnCoRd generalizes without QA training to novel properties and relations (top), and to real-world domain (bottom).", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.08481v2-Figure5-1.png": {"caption": "Generated graphs for a free form question (from the VQA [8] dataset). Blue text: accurate concepts, red: inaccurate.", "content_type": "figure", "figure_type": "schematic"}, "1811.08481v2-Table4-1.png": {"caption": "Accuracy of graph representation for VQA [8] sample, given for the different UnCoRd mappers. As expected, training on more diverse data allows better generalization across domains.", "content_type": "table", "figure_type": "table"}, "1811.08481v2-Table5-1.png": {"caption": "Accuracy of CLEVR dataset question answering by UnCoRd using the different question-to-graph mappers", "content_type": "table", "figure_type": "table"}, "1811.08481v2-Figure6-1.png": {"caption": "Examples for answering different question types on CLEVR images: (a) taken from CLEVR, (b) includes \u2019different color\u2019 relation, (c) uses a quantifier, and (d) a simple property existence (+ \u2019all\u2019 quantifier) question.", "content_type": "figure", "figure_type": "** photograph(s)"}, "1811.08481v2-Figure2-1.png": {"caption": "A schematic illustration of our method. The first stage (1) maps the question into a graph representation using a sequence-tosequence LSTM based model. At the second stage (2), the recursive answering procedure follows the graph, searching for a valid assignment in the image. At each step, the handled node is set and objects (extracted using mask R-CNN) are examined according to the node\u2019s requirements (utilizing corresponding visual estimators). If succeeded, a new node is set (according to a DFS traversal) and the function is called again to handle the unassigned subgraph. The Example illustrates the flow: \u2019check node (a)\u2019 \u2192 \u2019relation success\u2019 \u2192 \u2019check node (b)\u2019 \u2192 answer.", "content_type": "figure", "figure_type": "** Schematic"}, "1811.08481v2-Table7-1.png": {"caption": "Answering accuracy for 100 questions outside the VQA v2 domain (including quantifiers, comparisons, multiple relation chains and multiple relations and properties) on COCO images.", "content_type": "table", "figure_type": "table"}, "1811.08481v2-Figure8-1.png": {"caption": "Examples of UnCoRd successes in answering questions outside the VQA v2 domain on COCO images.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.08481v2-Table8-1.png": {"caption": "Answering accuracy for 100 questions sampled from VQA v2 dataset (on terms with visual estimators in UnCoRd).", "content_type": "table", "figure_type": "table"}, "1811.08481v2-Figure9-1.png": {"caption": "Examples of UnCoRd failures in answering questions outside the VQA v2 domain on COCO images.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.08481v2-Figure10-1.png": {"caption": "Examples of UnCoRd answers to VQA v2 questions (including \u2019full\u2019 answers when they add information).", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.08481v2-Figure3-1.png": {"caption": "Left: A CLEVR question and a corresponding graph. Right: A modified question and a corresponding graph, mapped using Extended-Enhanced model. The accuracy of the modified representation is confirmed, as it matches the original accurate graph (with modified graph concepts).", "content_type": "figure", "figure_type": "schematic"}, "1811.08481v2-Figure4-1.png": {"caption": "Instance segmentation example for CLEVR data. Left: GT (approximated from scene data), Right: results.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.08481v2-Table3-1.png": {"caption": "Accuracy of question-to-graph mapping for all data types", "content_type": "table", "figure_type": "table"}, "1811.08481v2-Table1-1.png": {"caption": "CLEVR estimators results on CLEVR validation set", "content_type": "table", "figure_type": "table"}, "1811.08481v2-Table2-1.png": {"caption": "CLEVR QA accuracy for state-of-the-art methods", "content_type": "table", "figure_type": "Table."}}, "qa": [{"question": "Which method has the highest overall accuracy for answering questions about images on the 100 questions sampled from VQA v2 dataset?", "answer": "UnCoRd-VG-E", "explanation": "The table shows the accuracy of two methods for answering questions about images. The overall accuracy of UnCoRd-VG-E is 92.0, which is higher than the overall accuracy of Pythia (77.0).", "reference": "1811.08481v2-Table8-1.png"}, {"question": "Explain how the answering procedure works.", "answer": "The answering procedure follows the question graph, searching for a valid assignment in the image. At each step, the handled node is set and objects (extracted using Mask R-CNN) are examined according to the node\u2019s requirements (utilizing corresponding visual estimators). If successful, a new node is set (according to a DFS traversal) and the function is called again to handle the unassigned subgraph.", "explanation": " The figure shows the answering procedure as a flowchart. The process starts with the question graph, which is created by the Question to Graph Mapper. The answering procedure then follows the graph, checking each node against the objects in the image. If a node is successful, the procedure moves on to the next node. If a node is not successful, the procedure backtracks and tries a different object. The process continues until all nodes in the graph have been checked. The final answer is then returned.", "reference": "1811.08481v2-Figure2-1.png"}, {"question": "Which method has the highest overall accuracy?", "answer": "UnCoRd-VG-E", "explanation": "The table shows the overall accuracy for each method. UnCoRd-VG-E has the highest overall accuracy of 76.0.", "reference": "1811.08481v2-Table7-1.png"}, {"question": "What is the effect of training on more diverse data on the accuracy of graph representation for VQA?", "answer": "Training on more diverse data improves the accuracy of graph representation for VQA.", "explanation": "The table shows that the accuracy of the graph representation increases as the amount of training data increases. The accuracy is highest for the VG mapper, which was trained on the most diverse data.", "reference": "1811.08481v2-Table4-1.png"}, {"question": "Which estimator achieves the highest accuracy on the CLEVR validation set?", "answer": "Size estimator.", "explanation": "The table shows that the Size estimator achieves 100% accuracy, which is the highest among all the estimators.", "reference": "1811.08481v2-Table1-1.png"}, {"question": "Which method achieves the highest overall accuracy on the validation set?", "answer": "UnCoRd-None-B.", "explanation": "The table shows the overall accuracy of different methods on the validation set. UnCoRd-None-B has the highest accuracy of 99.8%.", "reference": "1811.08481v2-Table2-1.png"}]}, "1705.09966v2": {"paper_id": "1705.09966v2", "all_figures": {"1705.09966v2-Figure3-1.png": {"caption": "Fig. 3. Our Conditional CycleGAN for identity-guided face generation. Different from attribute-guided face generation, we incorporate a face verification network as both the source of conditional vector z and the proposed identity loss in an auxiliary discriminator DXaux . The network DXaux is pretrained. Note the discriminators DX and DY are not shown for simplicity.", "content_type": "figure", "figure_type": "** Schematic"}, "1705.09966v2-Figure8-1.png": {"caption": "Fig. 8. Comparison results with [9]. Four source images are shown in top row. Images with blue and red bounding boxes indicates transferred results by [9] and results by our method, respectively.", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.09966v2-Table1-1.png": {"caption": "Table 1. SSIM on CelebA test sets.", "content_type": "table", "figure_type": "N/A"}, "1705.09966v2-Figure1-1.png": {"caption": "Fig. 1. Identity-guided face generation. Top: identity-preserving face super-resolution where (a) is the identity image; (b) input photo; (c) image crop from (b) in low resolution; (d) our generated high-res result; (e) ground truth image. Bottom: face transfer, where (f) is the identity image; (g) input low-res image of another person provides overall shape constraint; (h) our generated high-res result where the man\u2019s identity is transferred. To produce the low-res input (g) we down-sample from (i), which is a woman\u2019s face.", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.09966v2-Figure6-1.png": {"caption": "Fig. 6. Attribute-guided face generation. We flip one attribute label for each generated high-res face images, given the low-res face inputs. The 10 labels are: Bald, Bangs, Blond Hair, Gray Hair, Bushy Eyebrows, Eyeglasses, Male, Pale Skin, Smiling, Wearing Hat.", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.09966v2-Figure7-1.png": {"caption": "Fig. 7. Comparison with [13] by swapping facial attributes. Four paired examples are shown. Generally, our method can generate much better images compared to [13].", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.09966v2-Figure15-1.png": {"caption": "Fig. 15. Interpolating results of the identity feature vectors. Given the low-res input in (a), we randomly sample two target identity face images (b) and (k). (c) is the generated face from (a) conditioned on the identity in (b) and (d) to (j) are interpolations.", "content_type": "figure", "figure_type": "** photograph(s)"}, "1705.09966v2-Figure14-1.png": {"caption": "Fig. 14. Interpolation results of the attribute vectors. (a) Low-res face input; (b) generated high-res face images; (c) to (k) interpolated results. Attributes of source and destination are shown in text.", "content_type": "figure", "figure_type": "** photograph(s)"}, "1705.09966v2-Figure13-1.png": {"caption": "Fig. 13. Frontal face generation. Given a low-res template (a), our method can generate corresponding frontal faces from different side faces, e.g., (b) to (c), (d) to (e).", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.09966v2-Figure12-1.png": {"caption": "Fig. 12. Results without (c) and with (d) face verification loss. (a) is target identity image to be transferred and (b) is input image. The loss encourages subtle yet important improvement in photorealism, e.g. the eyebrows and eyes in (c) resemble the target identity in (a) by adding the face verification loss.", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.09966v2-Figure11-1.png": {"caption": "Fig. 11. Face swapping results within the high-res domain. (a)(c) are inputs of two different persons; (b)(d) their face swapping results. The black arrows indicate the guidance of identity, i.e. (d) is transformed from (c) under the identity constraint of (a). Similarly, (b) is transformed from (a) under the identity of (c). Note how our method transforms the identity by altering the appearance of eyes, eyebrows, hairs etc, while keeping other factors intact, e.g., head pose, shape of face and facial expression.", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.09966v2-Figure9-1.png": {"caption": "Fig. 9. Identity-guided face generation results on low-res input and high-res identity of the same person, i.e., identity-preserving face superresolution. (a) low-res inputs; (b) input identity of the same person; (c) our high-res face outputs (red boxes) from (a); (d) the high-res ground truth of (a).", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.09966v2-Figure10-1.png": {"caption": "Fig. 10. Identity-guided face generation results on different persons. The last row shows some challenging examples, e.g., , the occluded forehead in low-res input is recovered (example in the green box). (a) low-res inputs provide overall shape constraint; (b) identity to be transferred; (c) our high-res face outputs (red boxes) from (a) where the man/woman\u2019s identity in (b) is transferred; (d) the high-res ground truth of (a).", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.09966v2-Figure4-1.png": {"caption": "Fig. 4. From the low-res digit images (a), we can generate high-res digit images (b) to (k) subject to the conditional constrain from the digit class label in the first row.", "content_type": "figure", "figure_type": "photograph(s)"}, "1705.09966v2-Figure5-1.png": {"caption": "Fig. 5. Interpolation results of digits. Given the low-res inputs in (a), we randomly sample two digits (b) and (j). (c) is the generated results from (a) conditioned on the attribute of (b). Corresponding results of interpolating between attributes of (b) and (j) are shown in (d) to (i). We interpolate between the binary vectors of the digits.", "content_type": "figure", "figure_type": "** photograph(s)"}, "1705.09966v2-Figure2-1.png": {"caption": "Fig. 2. Our Conditional CycleGAN for attribute-guided face generation. In contrast to the original CycleGAN, we embed an additional attribute vector z (e.g., blonde hair) which is associated with the input attribute image X to train a generator GY\u2192X as well as the original GX\u2192Y to generate high-res face image X\u0302 given the low-res input Y and the attribute vector z. Note the discriminators DX and DY are not shown for simplicity.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "What is the role of the auxiliary discriminator $D_{X_{\\textit{aux}}}$ in the Conditional CycleGAN for identity-guided face generation?", "answer": " The auxiliary discriminator $D_{X_{\\textit{aux}}}$ helps to enforce the identity constraint in the generated image. It takes the generated image or the ground truth image as input and outputs a feature embedding. This embedding is then used to compute the identity loss, which encourages the generated image to have the same identity as the input image.", "explanation": " The figure shows that the auxiliary discriminator $D_{X_{\\textit{aux}}}$ is connected to the generator $G_{Y \\to X}$. The discriminator takes the generated image $\\hat{X}$ or the ground truth image $X$ as input and outputs a 256-D feature embedding. This embedding is then compared to the conditional vector $z$, which encodes the identity of the input image. The identity loss is computed based on the difference between these two embeddings. This loss encourages the generator to produce images that have the same identity as the input image.", "reference": "1705.09966v2-Figure3-1.png"}, {"question": "How does the proposed method compare to the method in~\\cite{kim2017learning}?", "answer": "The proposed method produces more realistic and natural-looking images than the method in~\\cite{kim2017learning}.", "explanation": "The figure shows that the images generated by the proposed method (red bounding boxes) are more realistic and natural-looking than the images generated by the method in~\\cite{kim2017learning} (blue bounding boxes). For example, in the first column, the proposed method is able to change the hair color of the woman to blonde while preserving her natural skin tone and facial features. In contrast, the method in~\\cite{kim2017learning} produces an image with an unnatural skin tone and distorted facial features.", "reference": "1705.09966v2-Figure8-1.png"}, {"question": "Which of the methods among Conditional GAN, Unsupervised GAN and Consitional CycleGAN would you expect to produce images that are most visually similar to the real images in the CelebA dataset?", "answer": "The Conditional CycleGAN method is expected to produce images most visually similar to the real images.", "explanation": "Table 1 presents the SSIM scores for different image generation methods on the CelebA test set. SSIM measures the structural similarity between two images, with higher values indicating greater similarity. In this case, the Conditional CycleGAN method achieved the highest SSIM score of 0.92, suggesting that its generated images are most similar to the real images in terms of visual perception.", "reference": "1705.09966v2-Table1-1.png"}, {"question": "How does the proposed attribute-guided face generation method compare to conventional face super-resolution methods in terms of identity preservation?", "answer": "The proposed attribute-guided face generation method preserves the identity of the person in the high-resolution result, while conventional face super-resolution methods do not necessarily guarantee this.", "explanation": "The top row of Figure 1 shows an example of identity-preserving face super-resolution using the proposed method. The identity image of Ivanka Trump (a) is used to guide the generation of a high-resolution image (d) from a low-resolution input image (c). The generated image (d) clearly preserves the identity of Ivanka Trump, while the conventional face super-resolution method may not produce a result that is as faithful to the original identity.", "reference": "1705.09966v2-Figure1-1.png"}, {"question": "What role does the low-resolution input play in the identity-guided face generation process?", "answer": "The low-resolution input provides an overall shape constraint for the generated high-resolution image. The head pose and facial expression of the generated high-res images adopt those in the low-res inputs.", "explanation": "The figure shows that the generated high-resolution images (c) have the same head pose and facial expression as the low-resolution inputs (a), even when the target identity images (b) have different poses and expressions. For example, in the example inside the blue box in the last row of Figure 2, the target identity image (b) shows a man smiling, while the low-resolution input (a) shows another man with a closed mouth. The generated high-resolution image (c) preserves the identity of the man in (b) while the pose of the head and the mouth follow the input.", "reference": "1705.09966v2-Figure9-1.png"}, {"question": "What happens when there is a conflict between the low-res image and the feature vector?", "answer": "The generated high-res digit follows the given class label.", "explanation": "The passage states that \"the generated high-res digit follows the given class label when there is conflict between the low-res image and feature vector.\" This is evident in Figure 1, where the generated high-res images (b) to (k) all match the class label in the first row, even though the low-res images (a) may not be clear.", "reference": "1705.09966v2-Figure4-1.png"}, {"question": "What is the difference between the input and output of the frontal face generation process?", "answer": "The input is a low-resolution frontal face image and a high-resolution side-face image. The output is a high-resolution frontal face image.", "explanation": "The figure shows that the input to the frontal face generation process is a low-resolution frontal face image and a high-resolution side-face image. The output is a high-resolution frontal face image that is consistent with the input side-face image.", "reference": "1705.09966v2-Figure13-1.png"}, {"question": "How does the proposed method preserve facial details and expression during face swapping?", "answer": "The proposed method utilizes Light-CNN as both the source of the identity features and face verification loss. This allows the method to transfer the appearance of eyes, eyebrows, hairs, etc., while keeping other factors intact, e.g., head pose, shape of face, and facial expression.", "explanation": "The figure shows that the proposed method can swap the identity of two people while preserving their facial details and expressions. For example, in the first row, the face of the woman in (a) is swapped with the face of the man in (c), but the woman's expression and facial features are still preserved in (b). Similarly, in the second row, the face of the man in (a) is swapped with the face of the woman in (c), but the man's expression and facial features are still preserved in (b).", "reference": "1705.09966v2-Figure11-1.png"}, {"question": "How does the proposed method compare to icGAN in terms of generating images with different hair colors?", "answer": "The proposed method is able to generate images with different hair colors more accurately than icGAN.", "explanation": "The figure shows that the proposed method is able to generate images with different hair colors that are more faithful to the input image than icGAN. For example, in the example with blonde hair, the proposed method is able to generate an image with blonde hair that is very similar to the input image, while icGAN generates an image with a different hair color.", "reference": "1705.09966v2-Figure7-1.png"}, {"question": "What is the role of the attribute vector $z$ in the Conditional CycleGAN network?", "answer": "The attribute vector $z$ provides additional information about the desired attributes of the generated high-resolution face image $\\hat{X}$. This information is used by the generator networks $G_{X \\to Y}$ and $G_{Y \\to X}$ to generate images that are more consistent with the desired attributes.", "explanation": "The figure shows how the attribute vector $z$ is used as input to both generator networks. The generator network $G_{X \\to Y}$ uses the attribute vector $z$ to generate a low-resolution face image $Y$ that has the desired attributes. The generator network $G_{Y \\to X}$ then uses the attribute vector $z$ and the low-resolution face image $Y$ to generate a high-resolution face image $\\hat{X}$ that has the desired attributes.", "reference": "1705.09966v2-Figure2-1.png"}]}, "1805.02349v2": {"paper_id": "1805.02349v2", "all_figures": {"1805.02349v2-Figure1-1.png": {"caption": "A comparison of algorithms for recovery of the permutation in the correlated Erdo\u0308s-Re\u0301nyi model, when (G0,G1, \u03c0) \u223c Dstruct(n, p;\u03b3).", "content_type": "figure", "figure_type": "table"}, "1805.02349v2-Figure2-1.png": {"caption": "In this example, XH(G) = 2.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "Which algorithm has the fastest runtime?", "answer": "The algorithm proposed in this paper has the fastest runtime.", "explanation": "The table shows that the algorithm in this paper has a runtime of  while the other algorithms have runtimes of  or .", "reference": "1805.02349v2-Figure1-1.png"}]}, "1811.09393v4": {"paper_id": "1811.09393v4", "all_figures": {"1811.09393v4-Figure14-1.png": {"caption": "Visual summary of VSR models. a) LPIPS (x-axis) measures spatial detail and temporal coherence is measured by tLP (y-axis) and tOF (bubble size with smaller as better). b) The red-dashed-box region of a), containing our ablated models. c) The network sizes.", "content_type": "figure", "figure_type": "plot"}, "1811.09393v4-Figure13-1.png": {"caption": "VSR comparisons for different captured images in order to compare to previous work [Liao et al. 2015; Tao et al. 2017].", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.09393v4-Table2-1.png": {"caption": "Averaged VSR metric evaluations for the Vid4 data set with the following metrics, PSNR: pixel-wise accuracy. LPIPS (AlexNet): perceptual distance to the ground truth. T-diff: pixel-wise differences of warped frames. tOF: pixel-wise distance of estimated motions. tLP: perceptual distance between consecutive frames. User study: Bradley-Terry scores [Bradley and Terry 1952]. Performance is averaged over 500 images up-scaled from 320x134 to 1280x536. More details can be found in Appendix A and Sec. 3 of the supplemental web-page.", "content_type": "table", "figure_type": "table"}, "1811.09393v4-Figure15-1.png": {"caption": "Bar graphs of temporal metrics for Vid4.", "content_type": "figure", "figure_type": "plot"}, "1811.09393v4-Figure16-1.png": {"caption": "Spatial metrics for Vid4. Fig. 17. Metrics for ToS.", "content_type": "figure", "figure_type": "plot"}, "1811.09393v4-Figure8-1.png": {"caption": "When learning a mapping between Trump and Obama, the CycleGAN model gives good spatial features but collapses to essentially static outputs of Obama. It manages to transfer facial expressions back to Trump using tiny differences encoded in its Obama outputs, without understanding the cycle-consistency between the two domains. Being able to establish the correct temporal cycle-consistency between domains, ours, RecycleGAN and STC-V2V can generate correct blinking motions, shown in Sec. 4.7 of the supplemental web-page. Our model outperforms the latter two in terms of coherent detail that is generated. Obama and Trump video courtesy of the White House (public domain).", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.09393v4-Figure12-1.png": {"caption": "Fig. 12. Detail views of the VSR results of ToS scenes (first three columns) and Vid4 scenes (two right-most columns) generated with different methods: from top to bottom. ENet [Sajjadi et al. 2017], FRVSR [Sajjadi et al. 2018], DUF [Jo et al. 2018], RBPN [Haris et al. 2019], EDVR [Wang et al. 2019a], TecoGAN, and the ground truth. Tears of Steel (ToS) movie (CC) Blender Foundation | mango.blender.org.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.09393v4-Table4-1.png": {"caption": "Metrics evaluated for the VSR Vid4 scenes.", "content_type": "table", "figure_type": "table"}, "1811.09393v4-Table5-1.png": {"caption": "Metrics evaluated for VSR of ToS scenes.", "content_type": "table", "figure_type": "table"}, "1811.09393v4-Figure2-1.png": {"caption": "a) A spatial GAN for image generation. b) A frame recurrent Generator. c) A spatio-temporal Discriminator. In these figures, letter a, b , and \u0434, stand for the input domain, the output domain and the generated results respectively. G and D stand for the generator and the discriminator.", "content_type": "figure", "figure_type": "schematic"}, "1811.09393v4-Figure23-1.png": {"caption": "1st & 2nd row: Frame 15 & 40 of the Foliage scene. While DsDt leads to strong recurrent artifacts early on, PP-Augment shows similar artifacts later in time (2nd row, middle). TecoGAN\u2296 model successfully removes these artifacts.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.09393v4-Figure9-1.png": {"caption": "Adversarial training arrives at different equilibriums when discriminators use different inputs. The baseline model (supervised on original triplets) and the vid2vid variant (supervised on original triplets and estimated motions) fail to learn the complex temporal dynamics of a highresolution smoke. The warped triplets improve the result of the concat model and the full TecoGAN model performs better spatio-temporally. Video comparisons are shown in Sec 5. of the supplemental web-page.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.09393v4-Figure10-1.png": {"caption": "Video translations between renderings of smoke simulations and real-world captures for smokes.", "content_type": "figure", "figure_type": "** photograph(s)"}, "1811.09393v4-Figure4-1.png": {"caption": "a) The frame-recurrent VSR Generator. b) Conditional VSR Ds,t .", "content_type": "figure", "figure_type": "** Schematic"}, "1811.09393v4-Figure3-1.png": {"caption": "a) Result without PP loss. The VSR network is trained with a recurrent frame-length of 10. When inference on long sequences, frame 15 and latter frames of the foliage scene show the drifting artifacts. b) Result trained with PP loss. These artifacts are removed successfully for the latter. c) When inferring a symmetric PP sequence with a forward pass (Ping) and its backward counterpart (Pong), our PP loss constrains the output sequence to be symmetric. It reduces the L2 distance between \u0434t and \u0434\u2032t , the corresponding frames in the forward and backward passes, shown via red circles with a minus sign. The PP loss reduces drifting artifacts and improves temporal coherence.", "content_type": "figure", "figure_type": ""}, "1811.09393v4-Table6-1.png": {"caption": "Training parameters", "content_type": "table", "figure_type": "table"}, "1811.09393v4-Figure22-1.png": {"caption": "Near image boundaries, flow estimation is less accurate and warping often fails to align content. The first two columns show original and warped frames, the third one shows differences after warping (ideally all black). The top row shows that structures moving into the view can cause problems, visible at the bottom of the images. The second row has objects moving out of the view.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.09393v4-Table3-1.png": {"caption": "For the Obama&Trump dataset, the averaged tLP and tOF evaluations closely correspond to our user studies. The table below summarizes user preferences as Bradley-Terry scores. Details are given in Appendix B and Sec. 3 of the supplemental web-page.", "content_type": "table", "figure_type": "table"}, "1811.09393v4-Figure11-1.png": {"caption": "Additional VSR comparisons, with videos in Sec 2 of the supplemental web-page. The TecoGAN model generates sharp details in both scenes.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.09393v4-Figure5-1.png": {"caption": "a) The UVT cycle link formed by two recurrent generators. b) Unconditional UVT Ds,t .", "content_type": "figure", "figure_type": "schematic"}, "1811.09393v4-Figure19-1.png": {"caption": "A sample setup of user study.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.09393v4-Figure18-1.png": {"caption": "Tables and visualization of perceptual metrics computed with PieAPP [Prashnani et al. 2018] (instead of LPIPS used in Fig. 14 previously) on ENet, FRVSR, DUF and TecoGAN for the VSR of Vid4. Bubble size indicates the tOF score.", "content_type": "figure", "figure_type": "plot."}, "1811.09393v4-Figure20-1.png": {"caption": "Tables and bar graphs of Bradley-Terry scores and standard errors for Vid4 VSR.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which method has the highest T-Diff on average for the Vid4 dataset?", "answer": "TecoGAN.", "explanation": "The bar for TecoGAN is the highest in the \"average\" category of the T-Diff graph.", "reference": "1811.09393v4-Figure15-1.png"}, {"question": "Which GAN model is able to generate the most realistic blinking motions?", "answer": "TecoGAN", "explanation": "The caption states that our model, RecycleGAN, and STC-V2V are all able to generate correct blinking motions, but that our model outperforms the latter two in terms of coherent detail that is generated. This can be seen in the figure, where the blinking motions generated by our model are more realistic and less jerky than those generated by the other models.", "reference": "1811.09393v4-Figure8-1.png"}, {"question": "Which of the VSR models in the figure achieves the best balance of spatial detail and temporal coherence?", "answer": "TecoGAN", "explanation": "The figure shows that TecoGAN achieves the lowest LPIPS score (which measures spatial detail) and the lowest tLP score (which measures temporal coherence).", "reference": "1811.09393v4-Figure14-1.png"}, {"question": "Which method achieves the highest PSNR on the Vid4 data set?", "answer": "DUF", "explanation": "The table shows that DUF has the highest PSNR value of 27.38.", "reference": "1811.09393v4-Table2-1.png"}, {"question": " What is the role of the warped triplets in the conditional VSR Ds,t?", "answer": " The warped triplets provide additional information about the motion and appearance of the scene, which helps the VSR Ds,t to generate more accurate and realistic results.", "explanation": " The warped triplets are created by warping the original triplets using the estimated motion information. This warping process aligns the corresponding pixels in the different frames, which allows the VSR Ds,t to better understand the motion and appearance of the scene. ", "reference": "1811.09393v4-Figure4-1.png"}, {"question": "How does the PP loss improve the temporal coherence of the video sequence?", "answer": "The PP loss constrains the output sequence to be symmetric by reducing the L2 distance between corresponding frames in the forward and backward passes. This helps to reduce drifting artifacts and improve temporal coherence.", "explanation": " The figure shows how the PP loss works. The forward pass (Ping) and the backward pass (Pong) are shown in the figure. The PP loss reduces the L2 distance between corresponding frames in the forward and backward passes, which is shown by the red circles with a minus sign. This helps to reduce drifting artifacts and improve temporal coherence.\n\n**Figure type:** Schematic", "reference": "1811.09393v4-Figure3-1.png"}, {"question": "What is the role of the Motion Compensation block in the Frame-Recurrent Generator?", "answer": "The Motion Compensation block estimates the motion between the previous frame and the current frame, and uses this information to warp the previous frame to the current frame. This helps the generator to produce more realistic images by taking into account the temporal information in the video sequence.", "explanation": "The Motion Compensation block is shown in Figure b, and it is connected to the input gt\u22121 and the output gt. The block W represents the warping operation.", "reference": "1811.09393v4-Figure2-1.png"}, {"question": "Which method produces the least amount of artifacts?", "answer": "TecoGAN\u2296.", "explanation": "The figure shows that both DsDt and PP-Augment produce artifacts, while TecoGAN\u2296 does not.", "reference": "1811.09393v4-Figure23-1.png"}, {"question": "Which method produces the most realistic results for the Vid4 scenes?", "answer": "TecoGAN.", "explanation": "The figure shows the VSR results of different methods for the Vid4 scenes. The results of TecoGAN are visually the closest to the ground truth.", "reference": "1811.09393v4-Figure12-1.png"}, {"question": "What is the learning rate for the generator in the DsOnly model?", "answer": "5.00E-05", "explanation": "The learning rate for the generator is listed in the table under the VSR Param section for the DsOnly model.", "reference": "1811.09393v4-Table6-1.png"}, {"question": "Why does flow estimation become less accurate near image boundaries?", "answer": "Flow estimation becomes less accurate near image boundaries because there is less information available to estimate the flow. This is because the pixels at the boundaries are only surrounded by pixels on one side, whereas pixels in the interior of the image are surrounded by pixels on all sides.", "explanation": "The figure shows that the differences after warping are not all black near the image boundaries, indicating that the flow estimation is less accurate in these regions.", "reference": "1811.09393v4-Figure22-1.png"}, {"question": "Which method has the best perceptual performance according to the tOF score?", "answer": "TecoGAN.", "explanation": "The bubble size indicates the tOF score. TecoGAN has the largest bubble, which means it has the highest tOF score.", "reference": "1811.09393v4-Figure18-1.png"}, {"question": "Which of the methods generated the sharpest details?", "answer": "TecoGAN", "explanation": "The caption states that the TecoGAN model generates sharp details in both scenes.", "reference": "1811.09393v4-Figure11-1.png"}, {"question": "What is the purpose of the UVT cycle link?", "answer": "The UVT cycle link is used to transfer knowledge between two recurrent generators.", "explanation": "The figure shows that the UVT cycle link connects two recurrent generators, one for domain A and one for domain B. The generators are connected in a cycle, so that each generator can learn from the other. This allows the generators to share knowledge and improve their performance.", "reference": "1811.09393v4-Figure5-1.png"}, {"question": "What is the purpose of the user study?", "answer": "The user study is designed to test which of two images is closer to a reference video.", "explanation": "The image shows three images, one labeled \"Reference\" and two labeled \"A\" and \"B.\" The question asks which of the two images is closer to the reference video, suggesting that the user study is designed to test the participants' ability to identify the image that is most similar to the reference video.", "reference": "1811.09393v4-Figure19-1.png"}]}, "1805.04609v3": {"paper_id": "1805.04609v3", "all_figures": {"1805.04609v3-Figure1-1.png": {"caption": "Modification operators for a sentence in the hate-speech detection task", "content_type": "figure", "figure_type": "schematic"}, "1805.04609v3-Figure3-1.png": {"caption": "Figure 3: The effect of the synthesis algorithm on the number of changed labels", "content_type": "figure", "figure_type": "plot"}, "1805.04609v3-Figure2-1.png": {"caption": "Figure 2: Comparison of accuracy achieved by the different methods", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which algorithm has the highest percentage of switched instances?", "answer": "US-HC-MQ", "explanation": "Figure \\ref{fig:effect_of_alg_on_label_switch} shows that US-HC-MQ has the highest percentage of switched instances for all five datasets.", "reference": "1805.04609v3-Figure3-1.png"}, {"question": "How does the accuracy of the US-BS-MQ method compare to that of the S-MQ method when adding SST examples?", "answer": "The US-BS-MQ method achieves higher accuracy than the S-MQ method when adding SST examples.", "explanation": "The figure shows that the red line (US-BS-MQ) is consistently above the blue line (S-MQ) for the SST dataset.", "reference": "1805.04609v3-Figure2-1.png"}]}, "1705.10667v4": {"paper_id": "1705.10667v4", "all_figures": {"1705.10667v4-Table5-1.png": {"caption": "Table 5: Accuracy (%) of CDAN variants on Office-31 for unsupervised domain adaptation (ResNet)", "content_type": "table", "figure_type": "N/A"}, "1705.10667v4-Figure2-1.png": {"caption": "Analysis of conditioning strategies, distribution discrepancy, and convergence.", "content_type": "figure", "figure_type": "plot"}, "1705.10667v4-Figure3-1.png": {"caption": "T-SNE of (a) ResNet, (b) DANN, (c) CDAN-f, (d) CDAN-fg (red: A; blue: W).", "content_type": "figure", "figure_type": "plot"}, "1705.10667v4-Table4-1.png": {"caption": "Table 4: Accuracy (%) on Digits and VisDA-2017 for unsupervised domain adaptation (ResNet-50)", "content_type": "table", "figure_type": "N/A"}, "1705.10667v4-Table3-1.png": {"caption": "Table 3: Accuracy (%) on Office-Home for unsupervised domain adaptation (AlexNet and ResNet)", "content_type": "table", "figure_type": "N/A"}, "1705.10667v4-Table2-1.png": {"caption": "Table 2: Accuracy (%) on ImageCLEF-DA for unsupervised domain adaptation (AlexNet and ResNet)", "content_type": "table", "figure_type": "N/A"}, "1705.10667v4-Table1-1.png": {"caption": "Table 1: Accuracy (%) on Office-31 for unsupervised domain adaptation (AlexNet and ResNet)", "content_type": "table", "figure_type": "N/A"}, "1705.10667v4-Figure1-1.png": {"caption": "Architectures of Conditional Domain Adversarial Networks (CDAN) for domain adaptation, where domain-specific feature representation f and classifier prediction g embody the cross-domain gap to be reduced jointly by the conditional domain discriminatorD. (a) Multilinear (M) Conditioning, applicable to lower-dimensional scenario, where D is conditioned on classifier prediction g via multilinear map f \u2297 g; (b) Randomized Multilinear (RM) Conditioning, fit to higher-dimensional scenario, where D is conditioned on classifier prediction g via randomized multilinear map 1\u221a d (Rf f) (Rgg). Entropy Conditioning (dashed line) leads to CDAN+E that prioritizesD on easy-to-transfer examples.", "content_type": "figure", "figure_type": "Schematic"}}, "qa": [{"question": "What is the main difference between the Multilinear Conditioning architecture and the Randomized Multilinear Conditioning architecture?", "answer": "The main difference is that the Multilinear Conditioning architecture uses a multilinear map to condition the domain discriminator on the classifier prediction, while the Randomized Multilinear Conditioning architecture uses a randomized multilinear map.", "explanation": "The figure shows that the Multilinear Conditioning architecture uses a multilinear map to combine the feature representation and the classifier prediction, while the Randomized Multilinear Conditioning architecture uses a randomized multilinear map to do the same thing. The randomized multilinear map is more efficient than the multilinear map, especially for high-dimensional data.", "reference": "1705.10667v4-Figure1-1.png"}, {"question": "Which of the four methods (ResNet, DANN, CDAN-f, CDAN-fg) is most effective at separating the two classes of data points?", "answer": "CDAN-fg", "explanation": "In the figure, we can see that CDAN-fg produces the clearest separation between the red and blue data points. The other methods show some overlap between the two classes, indicating that they are not as effective at separating them.", "reference": "1705.10667v4-Figure3-1.png"}, {"question": "Why might CDAN+E be considered a more versatile method for unsupervised domain adaptation compared to UNIT, CyCADA, and GTA?", "answer": "CDAN+E performs well across all five datasets listed in the table, including both digit and synthetic-to-real datasets, while UNIT, CyCADA, and GTA show strong results only on the digits and synthetic-to-real datasets.", "explanation": "The passage highlights that UNIT, CyCADA, and GTA are specifically designed for digit and synthetic-to-real adaptation tasks, which explains their high performance in those domains. However, their performance might not generalize well to other types of domain adaptation tasks. On the other hand, CDAN+E, despite being a simpler discriminative model, achieves good performance across all datasets, suggesting it is more adaptable and less reliant on task-specific design choices.", "reference": "1705.10667v4-Table4-1.png"}, {"question": "Which sampling strategy for random matrices in CDAN+E leads to the highest average accuracy across all domain adaptation tasks on Office-31? How does this compare to the performance of CDAN+E variants that use random sampling?", "answer": "The table shows that CDAN+E (w/o random sampling) achieves the highest average accuracy of 87.7% across all domain adaptation tasks. This is slightly higher than the performance of CDAN+E with uniform sampling (87.0%) and Gaussian sampling (86.4%).", "explanation": "The table presents the accuracy of different CDAN variants on various domain adaptation tasks. The \"Avg\" column provides the average accuracy across all tasks. By comparing the values in this column, we can see that not using random sampling leads to the best overall performance. This suggests that relying on pre-defined matrices might be more effective than introducing randomness in this specific context.", "reference": "1705.10667v4-Table5-1.png"}, {"question": "Which model performs the best in terms of test error?", "answer": "CDAN (M)", "explanation": "Figure (d) shows the test error for different models. CDAN (M) has the lowest test error.", "reference": "1705.10667v4-Figure2-1.png"}]}, "1805.04687v2": {"paper_id": "1805.04687v2", "all_figures": {"1805.04687v2-Table4-1.png": {"caption": "Table 4: Domain discrepancy experiments with object detection. We take the images from one domain and report testing results in AP on the same domain or the opposite domain. We can observe significant domain discrepancies, especially between daytime and nighttime.", "content_type": "table", "figure_type": "N/A"}, "1805.04687v2-Figure9-1.png": {"caption": "Visual comparisons of the same model (DRN [35]) trained on different datasets. We find that there is a dramatic domain shift between Cityscapes and our new dataset. For example, due to infrastructure difference, the model trained on Cityscapes is confused by some simple categories such as sky and traffic signs.", "content_type": "figure", "figure_type": "photograph(s)"}, "1805.04687v2-Figure11-1.png": {"caption": "Drivable area prediction by segmentation. The segmentation predicts the drivable area with lanes well, as shown in the top row. Also, we find that the segmentation model learns to interpolate in areas that has no lane markings.", "content_type": "figure", "figure_type": "photograph(s)"}, "1805.04687v2-Figure10-1.png": {"caption": "Distribution of images in weather, scene, and day hours categories.", "content_type": "figure", "figure_type": "plot"}, "1805.04687v2-Figure1-1.png": {"caption": "Overview of our dataset. Our dataset includes a diverse set of driving videos under various weather conditions, time, and scene types. The dataset also comes with a rich set of annotations: scene tagging, object bounding box, lane marking, drivable area, full-frame semantic and instance segmentation, multiple object tracking, and multiple object tracking with segmentation.", "content_type": "figure", "figure_type": "photograph(s)"}, "1805.04687v2-Table7-1.png": {"caption": "Table 7: Evaluation results for multiple object tracking cascaded with object detection. AP is the detection metric. Even though the tracking set has much more boxes, the model can still benefit from the diverse instance examples in the detection set.", "content_type": "table", "figure_type": "N/A"}, "1805.04687v2-Table5-1.png": {"caption": "Table 5: Evaluation results of homogeneous multitask learning on lane marking and drivable area segmentation. We train lane marking, drivable area segmentation and the joint training of both on training splits with 10K, 20K, and the full 70K images.", "content_type": "table", "figure_type": "N/A"}, "1805.04687v2-Table6-1.png": {"caption": "Table 6: Evaluation results for instance segmentation when joint training with the object detection set. Additional localization supervision can improve instance segmentation significantly.", "content_type": "table", "figure_type": "N/A"}, "1805.04687v2-Table11-1.png": {"caption": "Table 11: Annotations of the BDD100K MOT dataset by category.", "content_type": "table", "figure_type": "N/A"}, "1805.04687v2-Table10-1.png": {"caption": "Table 10: Comparisons on number of pedestrians with other datasets. The statistics are based on the training set in each dataset.", "content_type": "table", "figure_type": "N/A"}, "1805.04687v2-Table13-1.png": {"caption": "Full evaluation results of the domain discrepancy experiments with object detection.", "content_type": "table", "figure_type": "table"}, "1805.04687v2-Table14-1.png": {"caption": "Table 14: Full evaluation results of the individual lane marking task and the joint training of lane marking and the drivable area detection. We report the ODS-F scores with different thresholds \u03c4 = 1, 2, 10 pixels of direction, continuity as well as each category.", "content_type": "table", "figure_type": "N/A"}, "1805.04687v2-Figure4-1.png": {"caption": "Figure 4: Image tagging classification results using DLA-34.", "content_type": "figure", "figure_type": "plot"}, "1805.04687v2-Figure2-1.png": {"caption": "Figure 2: Geographical distribution of our data sources. Each dot represents the starting location of every video clip. Our videos are from many cities and regions in the populous areas in the US.", "content_type": "figure", "figure_type": "plot"}, "1805.04687v2-Figure3-1.png": {"caption": "Instance statistics of our object categories. (a) Number of instances of each category, which follows a long-tail distribution. (b) Roughly half of the instances are occluded. (c) About 7% of the instances are truncated.", "content_type": "figure", "figure_type": "plot"}, "1805.04687v2-Figure15-1.png": {"caption": "Example annotations for BDD100K MOTS. Frames are down-sampled for visualization.", "content_type": "figure", "figure_type": "photograph(s)"}, "1805.04687v2-Figure14-1.png": {"caption": "Figure 14: Distribution of classes in semantic instance segmentation. It presents a long-tail effect with more than 10 cars and poles per image, but only tens of trains in the whole dataset.", "content_type": "figure", "figure_type": "plot"}, "1805.04687v2-Table8-1.png": {"caption": "Table 8: Evaluation results for semantic segmentation. We explore segmentation joint-training with different tasks. Detection can improve the overall accuracy of segmentation, although their output structures are different. However, although Lane and Drivable area improve the segmentation of road and sidewalk, the overall accuracy drops.", "content_type": "table", "figure_type": "N/A"}, "1805.04687v2-Table9-1.png": {"caption": "Table 9: MOTS evaluation results. Both instance segmentation AP and MOTS evaluation metrics are reported. Instance segmentation tracking is very hard to label, but we are able to use object detection, tracking, and instance segmentation to improve segmentation tracking accuracy significantly.", "content_type": "table", "figure_type": "N/A"}, "1805.04687v2-Figure5-1.png": {"caption": "Examples of lane marking annotations. Red lanes are vertical and blue lanes are parallel. Left: we label all the visible lane boundaries. Middle: not all marking edges are lanes for vehicles to follow, such as pedestrian crossing. Right: parallel lanes can also be along the current driving direction.", "content_type": "figure", "figure_type": "** photograph(s)"}, "1805.04687v2-Figure6-1.png": {"caption": "Examples of drivable areas. Red regions are directly drivable and the blue ones are alternative. Although drivable areas can be confined within lane markings, they are also related to locations of other vehicles shown in the right two columns.", "content_type": "figure", "figure_type": "photograph(s)"}, "1805.04687v2-Table1-1.png": {"caption": "Lane marking statistics. Our lane marking annotations are significantly richer and are more diverse.", "content_type": "table", "figure_type": "table"}, "1805.04687v2-Figure12-1.png": {"caption": "Distribution of different types of lane markings and drivable areas.", "content_type": "figure", "figure_type": "plot"}, "1805.04687v2-Figure13-1.png": {"caption": "Trajectories of example driving videos.", "content_type": "figure", "figure_type": "Plot."}, "1805.04687v2-Table12-1.png": {"caption": "Table 12: Annotations of BDD100K MOTS by category.", "content_type": "table", "figure_type": "N/A"}, "1805.04687v2-Figure8-1.png": {"caption": "Number of occlusions by track (left) and number of occluded frames for each occlusion (right). Our dataset covers complicated occlusion and reappearing patterns.", "content_type": "figure", "figure_type": "plot"}, "1805.04687v2-Table3-1.png": {"caption": "Table 3: Comparisons with other MOTS and VOS datasets.", "content_type": "table", "figure_type": "N/A"}, "1805.04687v2-Figure7-1.png": {"caption": "Cumulative distributions of the box size (left), the ratio between the max and min box size for each track (middle) and track length (right). Our dataset is more diverse in object scale.", "content_type": "figure", "figure_type": "plot"}, "1805.04687v2-Table2-1.png": {"caption": "Table 2: MOT datasets statistics of training and validation sets. Our dataset has more sequences, frames, identities as well as more box annotations.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "How does increasing the training set size affect the performance of the lane marking and drivable area segmentation tasks?", "answer": "Increasing the training set size generally leads to improved performance for both lane marking and drivable area segmentation tasks.", "explanation": "The table shows the evaluation results for models trained on different sized datasets (10K, 20K, and 70K images). For both lane marking (ODS-F metric) and drivable area segmentation (IoU metric), the performance generally improves as the training set size increases. This is evident when comparing the \"mean\" values across the different training set sizes for each task. \n\nFor example, the mean ODS-F for lane marking increases from 45.41% with 10K images to 54.36% with 20K images and further to 54.48% with 70K images. Similarly, the mean IoU for drivable area segmentation increases from 64.23% with 10K images to 71.13% with 20K images and 71.37% with 70K images. \n\nThis trend suggests that having more training data allows the model to learn more effectively and generalize better, resulting in improved performance on both tasks.", "reference": "1805.04687v2-Table5-1.png"}, {"question": "How does joint training with the object detection set affect instance segmentation performance, and what is the likely reason for this effect?", "answer": "Joint training with the object detection set improves instance segmentation performance significantly. This is evidenced by the increase in AP, AP50, and AP75 metrics in Table 1 when comparing \"Inst-Seg\" and \"Inst-Seg + Det\" rows.\n\nThe passage explains that this improvement is likely due to the richer diversity of images and object examples in the detection set. This allows the instance segmentation model to learn better object appearance features and localization.", "explanation": "Table 1 directly shows the performance improvement through the increased metric values. The passage further clarifies the reason behind this improvement by highlighting the difference in dataset sizes and the benefits of additional object examples for feature learning.", "reference": "1805.04687v2-Table6-1.png"}, {"question": "Based on Table 1, which category of objects has the largest total number of annotations in the BDD100K MOT dataset, considering both bounding boxes and instance tracks? ", "answer": "Cars have the largest total number of annotations.", "explanation": "Table 1 shows the number of annotations for different categories in the BDD100K MOT dataset, including both bounding boxes (\"Boxes\") and instance tracks (\"Tracks\"). By adding the values for \"car\" in both rows, we find that cars have a total of approximately 2.7 million annotations (97K tracks + 2.6M boxes), which is greater than any other category.", "reference": "1805.04687v2-Table11-1.png"}, {"question": "How does the segmentation model perform in areas with no lane markings?", "answer": "The segmentation model learns to interpolate in areas that have no lane markings.", "explanation": "This can be seen in the bottom row of the figure, where the model correctly predicts the drivable area even though there are no lane markings present.", "reference": "1805.04687v2-Figure11-1.png"}, {"question": "What is the most common type of scene in the dataset?", "answer": "City Street", "explanation": "The figure shows that City Street has the highest number of instances, with approximately 61,960 instances.", "reference": "1805.04687v2-Figure10-1.png"}, {"question": "What are the different types of annotations that are included in the dataset?", "answer": "The dataset includes a rich set of annotations: scene tagging, object bounding box, lane marking, drivable area, full-frame semantic and instance segmentation, multiple object tracking, and multiple object tracking with segmentation.", "explanation": "The figure shows different types of annotations that are included in the dataset. For example, the bounding boxes around the cars indicate the object bounding box annotations, the different colored lines on the road indicate the lane marking annotations, and the different colored areas indicate the drivable area annotations.", "reference": "1805.04687v2-Figure1-1.png"}, {"question": "Explain why the model trained on both MOT and detection sets has a higher number of identity switches (IDS) compared to the model trained only on the MOT set, even though it achieves better performance in terms of AP, MOTA, and MOTP?", "answer": "While the model trained on both MOT and detection sets shows improved performance in detection and tracking metrics (AP, MOTA, MOTP), it also exhibits a higher number of identity switches (IDS). This can be attributed to the increased diversity of instances introduced by the detection set. Although the MOT set provides a larger number of bounding boxes for training, the detection set adds varied examples that may lead to more frequent identity switches during tracking, even as it improves the model's overall performance.", "explanation": "The table shows that the model trained on both MOT and detection sets (\"MOT + Det\") has a higher IDS value (9098) compared to the model trained only on the MOT set (8386). This might seem contradictory at first, given the improvement in other metrics. However, the passage provides the key insight: the detection set introduces more diverse examples. This diversity can lead to situations where the model struggles to maintain consistent identities across frames, resulting in more identity switches.", "reference": "1805.04687v2-Table7-1.png"}, {"question": "Which domain discrepancy has a larger impact on object detection performance: city vs. non-city or daytime vs. nighttime?", "answer": "Daytime vs. nighttime has a larger impact on object detection performance.", "explanation": "The table shows the Average Precision (AP) for object detection across different training and testing domains. While there is a noticeable difference in AP between city and non-city images, the drop in performance is much more significant when models trained on daytime images are tested on nighttime images, and vice versa. This observation is further supported by the passage, which explicitly mentions that \"the gap between daytime and nighttime is much bigger\" compared to the city vs. non-city discrepancy.", "reference": "1805.04687v2-Table4-1.png"}, {"question": "Why does the proposed dataset have a lower number of persons per image compared to the Cityscapes dataset, even though it has a much higher total number of pedestrians?", "answer": "The proposed dataset contains non-city scenes like highways, which typically have fewer pedestrians per image compared to cityscapes.", "explanation": "Table 1 shows that the \"Ours\" dataset has a significantly higher total number of pedestrians (86,047) compared to Cityscapes (19,654). However, the passage explains that the \"Ours\" dataset also includes non-city scenes like highways. These scenes usually have fewer pedestrians compared to cityscapes, which explains why the number of persons per image is lower for \"Ours\" (1.2) than Cityscapes (7.0).", "reference": "1805.04687v2-Table10-1.png"}, {"question": "How does the performance of lane marking detection change with different thresholds (\u03c4) for direction, continuity, and category?", "answer": "As the threshold (\u03c4) increases, the ODS-F scores for direction, continuity, and category generally increase as well. This indicates that the model performs better in detecting lane markings with higher thresholds, meaning it can tolerate larger deviations from the ground truth annotations.", "explanation": "The table presents ODS-F scores for different thresholds (\u03c4 = 1, 2, 10 pixels) across various training sets and lane marking attributes. By comparing the scores across different thresholds within each attribute and training set, we can observe the general trend of increasing performance with increasing thresholds. For example, for Lane 10K training set, the average ODS-F score for direction increases from 28.38 at \u03c4 = 1 to 36.19 at \u03c4 = 2 and 49.29 at \u03c4 = 10. This pattern holds true for most attributes and training sets, indicating that the model performs better with higher thresholds.", "reference": "1805.04687v2-Table14-1.png"}, {"question": "Which weather condition has the highest classification accuracy?", "answer": "Clear weather.", "explanation": "The figure shows the classification accuracy for different weather conditions. The bar for clear weather is the highest, indicating that it has the highest accuracy.", "reference": "1805.04687v2-Figure4-1.png"}, {"question": "Which type of object is the most common in the dataset?", "answer": "Cars are the most common object in the dataset.", "explanation": "The figure shows that there are almost 60 thousand car instances, which is more than any other type of object.", "reference": "1805.04687v2-Figure14-1.png"}, {"question": "Based on the table, which approach achieved the highest mean IoU for semantic segmentation, and how did it perform compared to the baseline Sem-Seg model?", "answer": "The **Sem-Seg + Det** approach achieved the highest mean IoU of 58.3, which is an improvement of 1.4 points compared to the baseline Sem-Seg model with a mean IoU of 56.9.", "explanation": "The table shows the mean IoU scores for different semantic segmentation approaches. We can see that the \"Sem-Seg + Det\" model has the highest score in the \"mean IoU\" column, indicating it achieved the best overall performance. Additionally, by comparing this score to the \"Sem-Seg\" model, we can quantify the improvement achieved by adding object detection to the training process.", "reference": "1805.04687v2-Table8-1.png"}, {"question": "Which training approach achieved the best balance between minimizing false negatives (FN) and false positives (FP) in object detection, while also maintaining a high MOTSA score?", "answer": "The training approach \"Det + T + I + S\" achieved the best balance between minimizing false negatives (FN) and false positives (FP) in object detection, while also maintaining a high MOTSA score.", "explanation": "The table shows that \"Det + T + I + S\" achieved the lowest FN count (5132) while having a relatively low FP count (6228) compared to other approaches. Although \"MOT (T) + MOTS\" has a slightly lower FP count, its FN count is significantly higher. Additionally, \"Det + T + I + S\" achieved the highest MOTSA score (41.4), indicating good overall performance in multi-object tracking and segmentation. Therefore, considering both FN, FP, and MOTSA, \"Det + T + I + S\" demonstrates the best balance.", "reference": "1805.04687v2-Table9-1.png"}, {"question": "Which category of objects has the highest total number of annotations, and is there evidence that this category might be more challenging to annotate accurately?", "answer": "The category with the highest total number of annotations is \"Masks,\" with 129K annotations. There is evidence that this category might be more challenging to annotate accurately because it also has the highest number of annotations in the \"Occluded\" subcategory, indicating that a large portion of these objects are partially hidden in the images.", "explanation": "Table 1 provides the breakdown of annotations for different categories of objects in the BDD100K MOTS dataset. The table shows the total number of annotations as well as subcategories like \"Occluded,\" which refers to objects that are partially hidden. By comparing the total number of annotations and the number of occluded annotations for each category, we can gain insight into the potential difficulty of accurately annotating each category. The \"Masks\" category stands out with both the highest total number and the highest number of occluded annotations, suggesting that annotating masks accurately might be more challenging due to frequent occlusions.", "reference": "1805.04687v2-Table12-1.png"}, {"question": "What percentage of occlusions last for more than 10 frames?", "answer": "Approximately 80%", "explanation": "The figure on the right shows the cumulative distribution function (CDF) of occlusion durations. The CDF shows the percentage of occlusions that last for a certain number of frames or less. The x-axis shows the number of occluded frames, and the y-axis shows the percentage of occlusions. The CDF reaches 80% at approximately 10 frames, which means that 80% of occlusions last for more than 10 frames.", "reference": "1805.04687v2-Figure8-1.png"}, {"question": "Why are MOTS datasets like KITTI MOTS and MOTS Challenge smaller in size compared to VOS datasets like YouTube VOS, even though BDD100K MOTS has a comparable number of annotations?", "answer": "MOTS datasets require denser annotations per frame because they involve both segmentation and tracking of multiple objects in crowded scenes. This results in smaller dataset sizes compared to VOS datasets, which typically focus on segmenting a single or fewer objects. ", "explanation": "The table shows that KITTI MOTS and MOTS Challenge have significantly fewer frames and sequences compared to YouTube VOS. However, their \"Ann./Fr.\" (annotations per frame) values are much higher, indicating denser annotations. BDD100K MOTS, while being larger than other MOTS datasets, maintains a high \"Ann./Fr.\" value, explaining why its size is comparable to YouTube VOS despite having fewer frames and sequences.", "reference": "1805.04687v2-Table3-1.png"}, {"question": "What are the three main geographical regions where the data for this study was collected?", "answer": "New York, San Francisco Bay Area, and Berkeley.", "explanation": "The figure shows the geographical distribution of the data sources, with each dot representing the starting location of a video clip. The dots are concentrated in three main regions: New York, San Francisco Bay Area, and Berkeley.", "reference": "1805.04687v2-Figure2-1.png"}, {"question": "Which category of object is the least common in the dataset?", "answer": "Train", "explanation": "The figure shows the number of instances for each category of object. The category with the lowest bar is \"Train,\" indicating that it is the least common.", "reference": "1805.04687v2-Figure3-1.png"}, {"question": "How does the BDD100K dataset compare to the KITTI and MOT17 datasets in terms of size and complexity?", "answer": "The BDD100K dataset is significantly larger and more complex than both the KITTI and MOT17 datasets. It contains roughly 40 times more frames, 16 times more sequences, and 13 times more identities than KITTI. Compared to MOT17, BDD100K has about 10 times more frames, 80 times more sequences, and 8 times more identities. This increase in size and complexity makes BDD100K a more challenging and comprehensive benchmark for multiple object tracking algorithms. ", "explanation": "Table~\\ref{tab:box_tracking_label_comp} provides a direct comparison of these datasets, showing the number of frames, sequences, identities, and bounding boxes for each. By analyzing these numbers, we can see that BDD100K significantly surpasses the other two datasets in terms of scale and diversity of tracked objects.", "reference": "1805.04687v2-Table2-1.png"}, {"question": "Which dataset has the most lane marking annotations?", "answer": "BDD100K", "explanation": "The table shows that BDD100K has 100,000 lane marking annotations, which is more than any other dataset in the table.", "reference": "1805.04687v2-Table1-1.png"}]}, "1706.00633v4": {"paper_id": "1706.00633v4", "all_figures": {"1706.00633v4-Table1-1.png": {"caption": "Classification error rates (%) on test sets.", "content_type": "table", "figure_type": "table"}, "1706.00633v4-Table2-1.png": {"caption": "Table 2: AUC-scores (10\u22122) of adversarial examples. The model of target networks is Resnet-32. Values are calculated on the examples which are correctly classified as normal examples and then misclassified as adversarial counterparts. Bandwidths used when calculating K-density are \u03c32 CE = 1/0.26 and \u03c32 RCE = 0.1/0.26. Here (-) indicates the strong baseline, and (*) indicates our defense method.", "content_type": "table", "figure_type": "N/A"}, "1706.00633v4-Figure2-1.png": {"caption": "Robustness with the thresholding test strategy disabled. The model of target networks is Resnet-32.", "content_type": "figure", "figure_type": "plot"}, "1706.00633v4-Figure5-1.png": {"caption": "Number of images w.r.t. K-density. The target networks are trained by the CE.", "content_type": "figure", "figure_type": "plot"}, "1706.00633v4-Table4-1.png": {"caption": "AUC-scores (10\u22122) on CIFAR-10. Resnet-32 is the substitute model and Resnet-56 is the target model.", "content_type": "table", "figure_type": "table"}, "1706.00633v4-Table3-1.png": {"caption": "The ratios of f2(x\u2217) > 0 and minimal distortions of the adversarial examples crafted by C&W-wb. Model is Resnet-32.", "content_type": "table", "figure_type": "table"}, "1706.00633v4-Figure3-1.png": {"caption": "The normal test images are termed as Normal, and adversarial examples generated on Resnet-32 (CE) and Resnet-32 (RCE) are separately termed as CE / RCE. Adversarial examples are generated by C&W-wb with minimal distortions.", "content_type": "figure", "figure_type": "** photograph(s)"}, "1706.00633v4-Figure1-1.png": {"caption": "Figure 1: a, The three black solid lines are the decision boundary of the classifier, and each black line (both solid and dashed parts) is the decision boundary between two classes. The blue dot-dashed lines are the isolines of non-ME = t. b, t-SNE visualization of the final hidden vectors on CIFAR-10. The model is Resnet-32. The training procedure is CE. c, The training procedure is RCE. d, Practical attacks on the trained networks. Blue regions are of the original classes for normal examples, and red regions are of the target classes for adversarial ones.", "content_type": "figure", "figure_type": "** Schematic"}, "1706.00633v4-Figure6-1.png": {"caption": "Number of images w.r.t. K-density. The target networks are trained by the RCE.", "content_type": "figure", "figure_type": "plot"}, "1706.00633v4-Figure4-1.png": {"caption": "Classification error rates on CIFAR-10. Two panels separately show the results when the networks are trained via the CE and RCE. The models is Resnet-32.", "content_type": "figure", "figure_type": "plot"}, "1706.00633v4-Table6-1.png": {"caption": "Table 6: The ratios (%) of f2(x\u2217) > 0 of the adversarial examples crafted by the high-confidence version of C&W-wb on MNIST and CIFAR-10. The model is Resnet-32 and the metric is K-density.", "content_type": "table", "figure_type": "N/A"}, "1706.00633v4-Figure7-1.png": {"caption": "The network is Resnet-32, the dataset is CIFAR-10.", "content_type": "figure", "figure_type": "plot"}, "1706.00633v4-Table5-1.png": {"caption": "Table 5: The average time costs (s) on crafting each adversarial example via different attacks. The values are also the average values between MNIST and CIFAR-10. The models is Resnet-32.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "Which method performed better on the MNIST dataset, ResNet-32 (CE) or ResNet-56 (RCE)?", "answer": "ResNet-56 (RCE) performed better on the MNIST dataset with a classification error rate of 0.32% compared to ResNet-32 (CE) which had a classification error rate of 0.38%.", "explanation": "The table shows the classification error rates for different methods on the MNIST and CIFAR-10 datasets. We can compare the error rates for the two methods on the MNIST dataset to see which one performed better.", "reference": "1706.00633v4-Table1-1.png"}, {"question": "Which combination of training procedure and thresholding metric consistently performs the best across both MNIST and CIFAR-10 datasets for all attack types?", "answer": "RCE training combined with the K-density metric consistently performs the best across both MNIST and CIFAR-10 datasets for all attack types.", "explanation": "Table 2 presents the AUC-scores of different combinations of training procedures (CE and RCE) and thresholding metrics (Confidence, non-ME, and K-density) for various attack types. By comparing the scores across rows and columns, we can identify the best performing combination. In this case, the entries marked with (*) represent the RCE training and K-density metric combination, and they consistently show the highest or near-highest AUC-scores for all attack types on both datasets.", "reference": "1706.00633v4-Table2-1.png"}, {"question": "Which attack method is the most effective at reducing the accuracy of the Resnet-32 model on the MNIST dataset?", "answer": "The most effective attack method at reducing the accuracy of the Resnet-32 model on the MNIST dataset is BIM/CE.", "explanation": "The figure shows the classification accuracy of the Resnet-32 model on the MNIST dataset under different attack methods. BIM/CE achieves the lowest accuracy of all the methods, indicating that it is the most effective at reducing the accuracy of the model.", "reference": "1706.00633v4-Figure2-1.png"}, {"question": "Which of the following algorithms performs the best when trained via the CE?", "answer": "C&W-hc", "explanation": "The figure shows the error rates for different algorithms when trained via the CE and RCE. The C&W-hc algorithm has the lowest error rate when trained via the CE.", "reference": "1706.00633v4-Figure4-1.png"}, {"question": "How does the accuracy of the model change as the value of c increases?", "answer": "The accuracy of the model decreases as the value of c increases.", "explanation": "The figure shows that the accuracy of the model is highest when c is small and decreases as c increases.", "reference": "1706.00633v4-Figure7-1.png"}, {"question": "Which objective function resulted in a higher ratio of f2(x\u2217) > 0 for the MNIST dataset?", "answer": "RCE", "explanation": "The table shows that the ratio of f2(x\u2217) > 0 for RCE is 0.77, while the ratio for CE is 0.01.", "reference": "1706.00633v4-Table3-1.png"}, {"question": "Which type of adversarial example generation method results in images that are visually more similar to the original images?", "answer": "The CE method results in images that are visually more similar to the original images than the RCE method.", "explanation": " The figure shows that the CE images have less distortion than the RCE images. This is evident in the MNIST and CIFAR-10 datasets, where the CE images are visually very similar to the original images, while the RCE images have more noticeable distortions.", "reference": "1706.00633v4-Figure3-1.png"}, {"question": "How does the proposed metric of non-ME help detect adversarial examples?", "answer": " The non-ME metric measures the entropy of the normalized non-maximal elements in the final hidden vector of the classifier. Adversarial examples often have low non-ME values, indicating that they are close to the decision boundary and have high confidence in the incorrect class.", "explanation": " Figure 1a shows that the isolines of non-ME=t (blue dot-dashed lines) are close to the decision boundary (black solid lines). Adversarial examples that successfully fool the detector (red dots in Figure 1d) tend to fall near the decision boundary, where the non-ME value is low. In contrast, normal examples (blue dots in Figure 1d) and adversarial examples that fail to fool the detector (open circles in Figure 1d) have higher non-ME values.", "reference": "1706.00633v4-Figure1-1.png"}, {"question": "Based on the table, which attack method is the most efficient in terms of time taken to craft an adversarial example, and how much faster is it compared to the slowest method for the same objective function?", "answer": "The FGSM attack is the most efficient, requiring approximately 1.9 milliseconds to craft an adversarial example with the CE objective function. This is roughly **55,000 times faster** than the slowest method, C&W-wb, which takes about 700 seconds for the same objective function.", "explanation": "The table presents the average time costs for different attack methods on both MNIST and CIFAR-10 datasets with the ResNet-32 model. By comparing the values in the \"Time\" column, we can identify the fastest and slowest methods. The table also specifies the objective function used (CE or RCE), allowing us to compare methods under the same conditions.", "reference": "1706.00633v4-Table5-1.png"}]}, "1811.10673v1": {"paper_id": "1811.10673v1", "all_figures": {"1811.10673v1-Figure6-1.png": {"caption": "Figure 6: Performance of proposed framework against different downsampling levels: (a) original 256 \u00d7 256 frame, XG. Reconstructions at scales (b) 32 \u00d7 32, (c) 64 \u00d7 64, (d) and 256 \u00d7 256. As the resolution increases, the reconstructed frames become more recognizable.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.10673v1-Table1-1.png": {"caption": "Video quality assessment of reconstructed frames in Figure 6. As the resolutions increased, the quality scores of the reconstructed frame increase monotonical.", "content_type": "table", "figure_type": "table"}, "1811.10673v1-Figure7-1.png": {"caption": "Figure 7: Performance of proposed framework against different quantization levels k of the soft edge detector (Qk). As the quantization level is increased (more clusters), the reconstructed representations become more precisely and similar to an original frames", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.10673v1-Table2-1.png": {"caption": "Video quality assessment of reconstructed frames in Figure 7. As k is increased, the quality of the reconstructed frames becomes improve.", "content_type": "table", "figure_type": "table"}, "1811.10673v1-Figure8-1.png": {"caption": "Figure 8: Rate-distortion curves (MS-SSIM) against bitrate for four semantic categories of 100 videos from the KTH dataset [8]. The red curves and dots correspond to our model while the blue curves and dots correspond to H.264. In the very low bitrate region (below 10Kbps), our scheme yielded higher MS-SSIM scores. Similar results were observed on PSNR, SSIM and VMAF (see supplementary material).", "content_type": "figure", "figure_type": "** plot"}, "1811.10673v1-Figure2-1.png": {"caption": "Figure 2: Proposed framework for adversarial video compression. Note that X consists of only one video to be compressed. The video X is partitioned into two sets containing different types of frames: XI and XG. XI is lightly compressed into xI using the standard H.264 encoder, while XG is highly compressed into xG, that contains only soft edge information at low resolution. The XI are used to train a generative model that we call the second-stage decoder D2. This generative model is trained at the receiver using x\u2032I and X \u2032I using a discriminator DD. After training, D2 takes soft edges xG as input and produces reconstructed frames (see also Figure 6). Only xI and xG are required to reconstruct the decompressed video.", "content_type": "figure", "figure_type": "schematic"}, "1811.10673v1-Figure3-1.png": {"caption": "Figure 3: Overview of the second encoding stage (E2).", "content_type": "figure", "figure_type": "schematic"}, "1811.10673v1-Figure9-1.png": {"caption": "Figure 9: Two videos from (a) the KTH and (b) the YouTube dataset. Selected frames from original video and reconstructed videos using H.264 (low bitrate), H.264 (high bitrate), and the proposed model are aligned vertically along time. Our scheme demonstrated significantly better performance than the current standard codecs at low bitrates. The scores produced by several leading perceptual video quality metrics were depicted on the right side. Please refer to the supplementary for reconstructed videos and results on additional 129 videos.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.10673v1-Figure10-1.png": {"caption": "Figure 10: Example of lower VQA scores on videos compressed by our model than those compressed using H.264, despite the apparent better subjective quality produced by our model. VQA scores taken above 7 frames are depicted at the right side (please see this video).", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.10673v1-Figure4-1.png": {"caption": "Figure 4: Outputs of soft edge detector. (a) The left-most frame is a 64 \u00d7 64 downsampled frame S(1) from a reconstructed frame XI (1)\u2032 of one video [1]. The right four frames are outputs of the soft edge detector for different levels of quantization k (Qk). (b) Grayscale histograms of Qk. (c) Three dimensional scatter plots (normalized R/G/B axes) of S, where colors visually distinguish the clusters indexed by Qk.", "content_type": "figure", "figure_type": "photograph(s)"}, "1811.10673v1-Figure5-1.png": {"caption": "Figure 5: Efficiency in bits per pixel (BPP) achieved by different lossless compression schemes on a bi-level image.", "content_type": "figure", "figure_type": "photograph(s) and table"}}, "qa": [{"question": "What is the effect of downsampling on the quality of reconstructed frames?", "answer": "Downsampling reduces the quality of reconstructed frames.", "explanation": "Figure 1 shows the original frame and the reconstructed frames at different downsampling levels. As the downsampling level increases, the reconstructed frames become less recognizable. This is because downsampling reduces the amount of information in the image, which makes it more difficult to reconstruct the original image.", "reference": "1811.10673v1-Figure6-1.png"}, {"question": "How does the proposed method compare to H.264 in terms of MS-SSIM score at low bitrates?", "answer": "The proposed method achieves significantly higher MS-SSIM scores than H.264 at bitrates below 10 Kbps.", "explanation": " The figure shows the rate-distortion curves for both the proposed method (red) and H.264 (blue). At low bitrates, the red curves are higher than the blue curves, indicating that the proposed method achieves better MS-SSIM scores.", "reference": "1811.10673v1-Figure8-1.png"}, {"question": "What is the purpose of the second-stage decoder $D_2$?", "answer": "The second-stage decoder $D_2$ takes soft edges $x_G$ as input and produces reconstructed frames.", "explanation": "The figure shows that the second-stage decoder $D_2$ is trained on the reconstructed frames $X'_I$ and the soft edges $x_G$. After training, $D_2$ is able to generate reconstructed frames from the soft edges $x_G$.", "reference": "1811.10673v1-Figure2-1.png"}, {"question": "What are the steps involved in the second encoding stage ($E_2$)?", "answer": "The second encoding stage involves three steps: down-sampling, soft edge detection, and spatio-temporal edge map compression.", "explanation": "The figure shows a schematic of the second encoding stage, with the three steps clearly labeled.", "reference": "1811.10673v1-Figure3-1.png"}, {"question": "Which lossless compression scheme achieved the highest compression gain in the example shown in Figure 1?", "answer": "The proposed scheme achieved the highest compression gain.", "explanation": "Figure 1 shows the BPP (bits per pixel) for different lossless compression schemes applied to a bi-level image. The proposed scheme has the lowest BPP, indicating the highest compression gain.", "reference": "1811.10673v1-Figure5-1.png"}, {"question": "How does the proposed model compare to H.264 in terms of visual quality at low bitrates?", "answer": "The proposed model delivers significantly better visual quality at low bitrates than H.264.", "explanation": "The figure shows that the reconstructed video using the proposed model (4th row) has sharper edges and more detail than the reconstructed videos using H.264 at 9 Kbps (2nd row) and 13 Kbps (3rd row). This is especially evident in the details of the person's face and clothing.", "reference": "1811.10673v1-Figure9-1.png"}, {"question": "How does the level of quantization affect the output of the soft edge detector?", "answer": "As the quantization level $k$ is decreased, the cardinality of colors co-located with edges decreases.", "explanation": "The figure shows that as the quantization level is decreased, the number of colors in the output image decreases. This is because the quantization process reduces the number of possible colors that can be represented.", "reference": "1811.10673v1-Figure4-1.png"}, {"question": "How does the quality of the reconstructed frames change as the resolution increases?", "answer": "The quality of the reconstructed frames increases monotonically as the resolution increases.", "explanation": "The table in the figure shows the PSNR, SSIM, and MS-SSIM scores for the reconstructed frames at different resolutions. These scores are all higher for higher resolutions, indicating that the quality of the reconstructed frames is better at higher resolutions.", "reference": "1811.10673v1-Table1-1.png"}, {"question": "How does the quality of the reconstructed frames change as the quantization level of the soft edge detector increases?", "answer": "The quality of the reconstructed frames increases as the quantization level of the soft edge detector increases.", "explanation": "The figure shows that as the quantization level increases, the reconstructed frames become more similar to the original frames. This is because a higher quantization level means that there are more clusters, which allows the soft edge detector to more accurately represent the edges in the image.", "reference": "1811.10673v1-Figure7-1.png"}, {"question": "Which quality factor improves the most as k is increased?", "answer": "MS-SSIM", "explanation": "The table shows that the MS-SSIM values increase the most as k is increased.", "reference": "1811.10673v1-Table2-1.png"}]}, "1706.00827v2": {"paper_id": "1706.00827v2", "all_figures": {"1706.00827v2-Figure1-1.png": {"caption": "Multi-class multi-instance fitting examples. Results on simultaneous plane and cylinder (top left), line and circle fitting (top right), motion (bottom left) and plane segmentation (bottom right).", "content_type": "figure", "figure_type": "photograph(s)"}, "1706.00827v2-Table3-1.png": {"caption": "Misclassification errors (%, average and median) for two-view plane segmentation on all the 19 pairs from AdelaideRMF test pairs using fixed parameters.", "content_type": "table", "figure_type": "table"}, "1706.00827v2-Table1-1.png": {"caption": "Table 1: The number of false positive (FP) and false negative (FN) instances for simultaneous line and circle fitting.", "content_type": "table", "figure_type": "N/A"}, "1706.00827v2-Table2-1.png": {"caption": "Misclassification error (%) for the two-view plane segmentation on AdelaideRMF test pairs: (1) johnsonna, (2) johnsonnb, (3) ladysymon, (4) neem, (5) oldclassicswing, (6) sene.", "content_type": "table", "figure_type": "table"}, "1706.00827v2-Table4-1.png": {"caption": "Misclassification errors (%) for two-view motion segmentation on the AdelaideRMF dataset. All the methods were tuned separately for each video by the authors. Tested image pairs: (1) cubechips, (2) cubetoy, (3) breadcube, (4) gamebiscuit, (5) breadtoycar, (6) biscuitbookbox, (7) breadcubechips, (8) cubebreadtoychips.", "content_type": "table", "figure_type": "table"}, "1706.00827v2-Table5-1.png": {"caption": "Misclassification errors (%, average and median) for two-view motion segmentation on all the 21 pairs from the AdelaideRMF dataset using fixed parameters.", "content_type": "table", "figure_type": "table"}, "1706.00827v2-Table6-1.png": {"caption": "Table 6: Misclassification error (%) of simultaneous plane and cylinder fitting to LIDAR data. See Fig. 6 for examples.", "content_type": "table", "figure_type": "N/A"}, "1706.00827v2-Figure3-1.png": {"caption": "Comparison of PEARL and Multi-X. Three random lines sampled at 100 locations, plus 200 outliers. Parameters of both methods are: hmax = 3, and the outlier threshold is (a) 6 and (b) 3 pixels.", "content_type": "figure", "figure_type": "plot"}, "1706.00827v2-Figure2-1.png": {"caption": "(Left) Three lines each generating 100 points with zero-mean Gaussian noise added, plus 50 outliers. (Right) 1000 line instances generated from random point pairs, the ground truth instance parameters (red dots) and the modes (green) provided by Mean-Shift shown in the model parameter domain: \u03b1 angle \u2013 vertical, offset \u2013 horizontal axis.", "content_type": "figure", "figure_type": "plot"}, "1706.00827v2-Figure4-1.png": {"caption": "AdelaideRMF (top) and Multi-H (bot.) examples. Colors indicate the planes Multi-X assigned points to.", "content_type": "figure", "figure_type": "photograph(s)"}, "1706.00827v2-Figure5-1.png": {"caption": "AdelaideRMF (top) and Hopkins (bot.) examples. Color indicates the motion Multi-X assigned a point to.", "content_type": "figure", "figure_type": "photograph(s)"}, "1706.00827v2-Table7-1.png": {"caption": "Misclassification errors (%, average and median) for multi-motion detection on 51 videos of Hopkins dataset: (1) Traffic2 \u2013 2 motions, 31 videos, (2) Traffic3 \u2013 3 motions, 7 videos, (3) Others2 \u2013 2 motions, 11 videos, (4) Others3 \u2013 3 motions, 2 videos, (5) All \u2013 51 videos.", "content_type": "table", "figure_type": "table"}, "1706.00827v2-Table8-1.png": {"caption": "Table 8: Processing times (sec) of Multi-X (M) and TLinkage (T) for the problem of fitting (1) lines and circles, (2) homographies, (3) two-view motions, (4) video motions, and (5) planes and cylinders. The number of data points is shown in the first column.", "content_type": "table", "figure_type": "N/A"}, "1706.00827v2-Figure6-1.png": {"caption": "Results of simultaneous plane and cylinder fitting to LIDAR point cloud in two scenes. Segmented scenes visualized from different viewpoints. There is only one cylinder on the two scenes: the pole of the traffic sign on the top. Color indicates the instance Multi-X assigned a point to.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "Which method achieved the most accurate results for simultaneous line and circle fitting?", "answer": "Multi-X achieved the most accurate results for simultaneous line and circle fitting.", "explanation": "Table 1 shows the number of false positive (FP) and false negative (FN) instances for each method. Ideally, we want both FP and FN to be as low as possible, indicating fewer falsely detected and missed features. As shown in the table, Multi-X is the only method that achieved **zero** false positives across all test cases (columns 1, 2, and 3). Additionally, it had the lowest number of false negatives in two out of three cases and tied for the lowest in the remaining case. This demonstrates that Multi-X consistently produced the most accurate results compared to the other methods.", "reference": "1706.00827v2-Table1-1.png"}, {"question": "Which method has the lowest average misclassification error for the cubechips image pair?", "answer": "Multi-X", "explanation": "The table shows the average and minimum misclassification errors for each method on each image pair. For the cubechips image pair, Multi-X has the lowest average misclassification error of 3.45%.", "reference": "1706.00827v2-Table4-1.png"}, {"question": "What is the difference between AdelaideRMF and Multi-H?", "answer": "AdelaideRMF tends to assign points to more planes than Multi-H.", "explanation": "In the top two images, which are examples of AdelaideRMF, the points are assigned to many different planes, as indicated by the different colors. In the bottom two images, which are examples of Multi-H, the points are assigned to fewer planes.", "reference": "1706.00827v2-Figure4-1.png"}, {"question": "What is the relationship between the color of the points and the motion of the object?", "answer": "The color of the points indicates the motion that the Multi-X algorithm assigned to each point.", "explanation": "The caption states that the color of the points indicates the motion that Multi-X assigned to a point. For example, in the top left image, the blue points on the Rubik's Cube are likely assigned to a different motion than the green points on the poker chips.", "reference": "1706.00827v2-Figure5-1.png"}, {"question": "Which of the five methods tested had the lowest average misclassification error?", "answer": "Multi-X", "explanation": "The table shows the average misclassification error for each method. Multi-X has the lowest average error of 2.97%.", "reference": "1706.00827v2-Table5-1.png"}, {"question": "In which scenario did Multi-X perform worse than another method in terms of misclassification error for simultaneous plane and cylinder fitting?", "answer": "Multi-X performed worse than PEARL in test case (6), with a misclassification error of 21.72% compared to PEARL's 17.35%. ", "explanation": "Table 2 presents the misclassification error percentages for different methods, including Multi-X and PEARL, across seven test cases. By comparing the values in the \"Multi-X\" and \"PEARL\" columns, we can identify instances where Multi-X underperformed. In test case (6), Multi-X has a higher error rate than PEARL, indicating its relatively poorer performance in that specific scenario.", "reference": "1706.00827v2-Table6-1.png"}, {"question": "How does the Mean-Shift algorithm perform in the presence of outliers?", "answer": "The Mean-Shift algorithm is robust to outliers.", "explanation": "The left panel of the figure shows three lines with outliers. The right panel shows the results of the Mean-Shift algorithm, which has correctly identified the three lines despite the presence of outliers. This is because the Mean-Shift algorithm is based on the density of points, and outliers do not significantly affect the density.", "reference": "1706.00827v2-Figure2-1.png"}, {"question": "Which method has the lowest average misclassification error?", "answer": "Multi-X", "explanation": "The table shows the average and median misclassification errors for different methods. The lowest average misclassification error is for Multi-X, which has an average error of 9.72%.", "reference": "1706.00827v2-Table3-1.png"}, {"question": "Which algorithm is generally faster for fitting planes and cylinders: Multi-X or T-Linkage?", "answer": "Multi-X is generally faster for fitting planes and cylinders compared to T-Linkage.", "explanation": "Looking at column (5) in Table 1, which shows the processing times for fitting planes and cylinders, we can see that the processing time for Multi-X is consistently lower than that of T-Linkage for all three data sizes (100, 500, and 1000). For example, with 500 data points, Multi-X takes 3.8 seconds while T-Linkage takes 15.9 seconds. This trend holds true for the other data sizes as well, indicating that Multi-X offers superior performance in terms of speed for this specific fitting task.", "reference": "1706.00827v2-Table8-1.png"}]}, "1805.06431v4": {"paper_id": "1805.06431v4", "all_figures": {"1805.06431v4-Figure4-1.png": {"caption": "Fitting results on datasets with (a) flipped function and (c) uniform corruptions. Resulting correlations of two components with (b) flipped function and (d) uniform corruptions.", "content_type": "figure", "figure_type": "** plot"}, "1805.06431v4-Figure5-1.png": {"caption": "The predictions results of the second mixture of test inputs whose labels are (a) 0 and (b) 1, respectively.", "content_type": "figure", "figure_type": "plot"}, "1805.06431v4-Table7-1.png": {"caption": "Table 7: Collision rates of compared methods on straight lanes.", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Table8-1.png": {"caption": "Table 8: Root mean square lane deviation distances (m) of compared methods on straight lanes.", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Figure8-1.png": {"caption": "Resulting trajectories of compared methods trained with mixed demonstrations. (best viewed in color).", "content_type": "figure", "figure_type": "schematic"}, "1805.06431v4-Table15-1.png": {"caption": "Table 15: Test accuracies on the Large Movie Review dataset with different corruption probabilities.", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Figure14-1.png": {"caption": "Learning curves of compared methods on CIFAR-10 experiments with different noise levels.", "content_type": "figure", "figure_type": "plot"}, "1805.06431v4-Figure6-1.png": {"caption": "(a-c) Average fitting errors while varying the outlier rates and (e-f) fitting results of the compared methods with 60% outliers using cosexp, linear, and step functions.", "content_type": "figure", "figure_type": "plot"}, "1805.06431v4-Table1-1.png": {"caption": "Table 1: The RMSEs of compared methods on the Boston Housing Dataset", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Table2-1.png": {"caption": "Table 2: Test accuracies on the CIFAR-10 dataset with by symmetric and asymmetric noises.", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Table5-1.png": {"caption": "Table 5: The RMSEs of compared methods on the Boston Housing Dataset", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Table6-1.png": {"caption": "Table 6: Average returns of compared methods on behavior cloning problems using MuJoCo", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Figure7-1.png": {"caption": "Figure 7: Reference function and fitting results of compared methods on different outlier rates, 0%,20% 40%, 80%, and 90%).", "content_type": "figure", "figure_type": "plot"}, "1805.06431v4-Figure1-1.png": {"caption": "A process of binary classification on corrupt data using the mixture of (a) densities and (b) classifiers through (4).", "content_type": "figure", "figure_type": "plot"}, "1805.06431v4-Table12-1.png": {"caption": "Table 12: Test accuracies on the MNIST dataset with randomly permutated label.", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Table4-1.png": {"caption": "Table 4: The RMSEs of compared methods on synthetic toy examples", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Table3-1.png": {"caption": "Table 3: The comparison between naive WideResNet and ChoiceNet on multile benchmark datasets.", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Figure2-1.png": {"caption": "Illustration of a Cholesky Block. Every block shares target weight matrix W\u2217 and auxiliary matrix Z, and outputs correlated weight matrix W\u0303k through CholeskyTransform (see (5)) to distinguish the abnormal pattern from normal one which will be learned by W\u2217.", "content_type": "figure", "figure_type": "schematic"}, "1805.06431v4-Table13-1.png": {"caption": "Table 13: Test accuracies on the CIFAR-10 datasets with symmetric noises.", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Figure12-1.png": {"caption": "Learning curves of compared methods on random shuffle experiments using MNIST with different noise levels.", "content_type": "figure", "figure_type": "plot"}, "1805.06431v4-Table11-1.png": {"caption": "Table 11: Test accuracies on the MNIST dataset with corrupt label.", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Table10-1.png": {"caption": "Table 10: Test accuracies on the MNIST dataset with biased label.", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Table14-1.png": {"caption": "Table 14: Test accuracies on the CIFAR-10 dataset with by symmetric and asymmetric noises.", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Figure13-1.png": {"caption": "Learning curves of compared methods on random permutation experiments using MNIST with different noise levels.", "content_type": "figure", "figure_type": "plot"}, "1805.06431v4-Figure3-1.png": {"caption": "Overall mechanism of ChoiceNet. It consists of K mixtures and each mixture outputs triplet (\u03c0k, \u00b5k,\u03a3k) via Algorithm 1. \u03c11 = 1 is reserved to model the target distribution.", "content_type": "figure", "figure_type": "schematic"}, "1805.06431v4-Table9-1.png": {"caption": "Table 9: Test accuracies on the MNIST datasets with corrupt labels.", "content_type": "table", "figure_type": "N/A"}, "1805.06431v4-Figure9-1.png": {"caption": "Figure 9: Descriptions of the featrues of an ego red car used in autonomous driving experiments.", "content_type": "figure", "figure_type": "Schematic"}, "1805.06431v4-Figure10-1.png": {"caption": "Manually collected trajectories of (a) safe driving mode and (b) careless driving mode. (best viewed in color).", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "Which method appears to be the safest for autonomous driving on straight lanes with different levels of outlier vehicles?", "answer": "ChoiceNet appears to be the safest method for autonomous driving on straight lanes, regardless of the percentage of outlier vehicles present.", "explanation": "Table 1 shows the collision rates of different methods on straight lanes with varying percentages of outlier vehicles (0% to 40%). ChoiceNet consistently demonstrates the lowest collision rate (0% or close to 0%) across all outlier percentages. This is further supported by the passage, which explicitly states that ChoiceNet outperforms other methods in terms of safety, as evidenced by its low collision rates.", "reference": "1805.06431v4-Table7-1.png"}, {"question": "Which of the compared methods is most likely to be the safest?", "answer": "ChoiceNet", "explanation": "The trajectories of the different methods are shown in the figure. ChoiceNet's trajectory is the one that stays closest to the center of the lane and avoids the oncoming car.", "reference": "1805.06431v4-Figure8-1.png"}, {"question": "How does the ChoiceNet model perform on datasets with uniform corruptions?", "answer": "The ChoiceNet model performs poorly on datasets with uniform corruptions.", "explanation": " The figure shows the fitting results and correlations of the ChoiceNet model on datasets with flipped functions and uniform corruptions. In (c), the ChoiceNet model is unable to accurately fit the data with uniform corruptions. This is further supported by the correlations in (d), which show that the two components of the ChoiceNet model have low correlations with the ground truth. ", "reference": "1805.06431v4-Figure4-1.png"}, {"question": "Which method performs the best when there are a lot of outliers in the data?", "answer": "ChoiceNet.", "explanation": "The figure shows that ChoiceNet is able to fit the reference function more accurately than the other methods when there are a lot of outliers in the data. For example, when the outlier rate is 80%, ChoiceNet is still able to fit the reference function quite well, while the other methods are not.", "reference": "1805.06431v4-Figure7-1.png"}, {"question": "Which of the two approaches, density estimation or mixture of classifiers, is more robust to outliers?", "answer": "Mixture of classifiers.", "explanation": "The figure shows that the mixture of classifiers approach is able to correctly classify the data points even when there are outliers present. This is because the mixture of classifiers approach is able to learn the different modes of the data distribution, while the density estimation approach is not.", "reference": "1805.06431v4-Figure1-1.png"}, {"question": "How does the performance of the different models change as the corruption level increases? Which model appears to be the most robust to label corruption?", "answer": "As the corruption level increases, the performance of all models decreases. However, ChoiceNet consistently outperforms both ConvNet and ConvNet+Mixup across all corruption levels, maintaining high accuracy even when almost half of the labels are incorrect. This suggests that ChoiceNet is significantly more robust to label corruption compared to the other models.", "explanation": "The table shows the test accuracies of different models on the MNIST dataset with varying levels of label corruption. By comparing the accuracies across different corruption levels (25%, 40%, 45%, 47%), we can observe the trend of decreasing performance for all models. However, the decline is much less severe for ChoiceNet, which maintains an accuracy above 92% even at the highest corruption level. This observation allows us to conclude that ChoiceNet is more robust to label corruption than the other models.", "reference": "1805.06431v4-Table12-1.png"}, {"question": "Which method appears to be most robust to the presence of outliers in the training data?", "answer": "ChoiceNet appears to be the most robust to outliers in the training data.", "explanation": "Table 1 shows the RMSEs of different methods for various percentages of outliers in the training data. While all methods perform well with no outliers (RMSE < 0.1), ChoiceNet consistently maintains the lowest RMSE even as the outlier rate increases. The passage also explicitly states that ChoiceNet successfully fits the target function even with outlier rates exceeding 40%, whereas other methods fail. This suggests that ChoiceNet is better able to handle noisy data and produce accurate predictions compared to the other methods.", "reference": "1805.06431v4-Table4-1.png"}, {"question": "Which method performs best when there is no label corruption (p = 0%) on the Large Movie Review dataset and how does its performance change as the corruption level increases?", "answer": "When there is no label corruption (p = 0%), Mixup achieves the highest test accuracy of 79.77%. However, as the corruption level increases, Mixup's performance deteriorates more rapidly compared to other methods. ChoiceNet, on the other hand, demonstrates a more stable performance across different corruption levels, maintaining the highest accuracy when p is 10%, 20%, 30%, and 40%.", "explanation": "The table displays the test accuracies of different methods under varying degrees of label corruption. By comparing the values in the p = 0% column, we can identify the best performing method in the absence of corruption. Additionally, by observing the trend of each method's accuracy as p increases, we can assess their relative robustness to label noise.", "reference": "1805.06431v4-Table15-1.png"}, {"question": "How does the accuracy of the WideResNet model compare to the ChoiceNet model on the CIFAR-10 dataset with 50% random shuffle?", "answer": "The WideResNet model has higher accuracy than the ChoiceNet model on the CIFAR-10 dataset with 50% random shuffle.", "explanation": "The figure shows the learning curves of the WideResNet and ChoiceNet models on the CIFAR-10 dataset with 50% random shuffle. The WideResNet model's learning curve is higher than the ChoiceNet model's learning curve, indicating that the WideResNet model has higher accuracy.", "reference": "1805.06431v4-Figure14-1.png"}, {"question": "Which of the four methods has the best performance in terms of average error for the step function?", "answer": "The proposed method.", "explanation": "From the plot (c), it can be seen that the proposed method has the lowest average error for all outlier rates compared to the other three methods.", "reference": "1805.06431v4-Figure6-1.png"}, {"question": " How does the performance of ChoiceNet compare to other methods under different noise settings? Briefly explain the strengths and weaknesses of ChoiceNet.", "answer": "ChoiceNet generally performs well compared to other methods, achieving the highest accuracy on both symmetric noise settings (sym-50% and sym-20%). However, it falls to second place under the Pair-45% asymmetric noise setting, indicating a weakness in handling this specific type of noise.", "explanation": "Table 2 presents the test accuracies of various methods under different noise conditions. By comparing the values in the table, we can see that ChoiceNet outperforms all other methods on the two symmetric noise settings, demonstrating its strength in handling such noise. However, under the Pair-45% asymmetric noise setting, ChoiceNet is surpassed by Co-teaching. This suggests that ChoiceNet may struggle with accurately inferring label distributions when noise patterns become more complex and asymmetric. The passage further clarifies this weakness, explaining that the \"Cholesky Block\" component of ChoiceNet struggles under Pair-45% noise due to the specific way this noise type assigns labels.", "reference": "1805.06431v4-Table2-1.png"}, {"question": "Which method generally performed better in the HalfCheetah task, ChoiceNet or MDN? How does the performance gap between these two methods change as the percentage of outliers increases?", "answer": "ChoiceNet generally performed better than MDN in the HalfCheetah task. This is evident from the higher average returns of ChoiceNet across all outlier percentages (10%, 20%, and 30%).\n\nThe performance gap between ChoiceNet and MDN appears to decrease as the percentage of outliers increases. At 10% outliers, ChoiceNet has a significantly higher average return than MDN (2068.14 vs. 192.53). However, at 30% outliers, the difference in average return is smaller (2035.91 vs. 363.08).", "explanation": "The table shows the average returns of different methods in the HalfCheetah task for different outlier percentages. By comparing the values in the ChoiceNet and MDN columns, we can directly see which method performed better for each outlier percentage. The difference in average return values reflects the performance gap between the two methods.", "reference": "1805.06431v4-Table6-1.png"}, {"question": "How does the performance of ChoiceNet compare to other methods under different noise settings on the CIFAR-10 dataset? Briefly explain the strengths and weaknesses of ChoiceNet. ", "answer": "ChoiceNet generally performs well compared to other methods, achieving the highest accuracy on both symmetric noise settings (sym-50% and sym-20%). However, it falls to second place under the Pair-45% asymmetric noise setting, indicating a weakness in handling this specific type of noise.", "explanation": "Table 2 presents the test accuracies of various methods under different noise conditions. By comparing the values in the table, we can see that ChoiceNet outperforms all other methods on the two symmetric noise settings, demonstrating its strength in handling such noise. However, under the Pair-45% asymmetric noise setting, ChoiceNet is surpassed by Co-teaching. This suggests that ChoiceNet may struggle with accurately inferring label distributions when noise patterns become more complex and asymmetric. The passage further clarifies this weakness, explaining that the \"Cholesky Block\" component of ChoiceNet struggles under Pair-45% noise due to the specific way this noise type assigns labels.", "reference": "1805.06431v4-Table14-1.png"}, {"question": "Which method performs best at all noise levels?", "answer": "ChoiceNet.", "explanation": "The figure shows that ChoiceNet consistently achieves the highest accuracy across all noise levels (25%, 40%, 45%, and 47%) on both the training and test sets.", "reference": "1805.06431v4-Figure13-1.png"}, {"question": "What is the role of the Cholesky block in the ChoiceNet architecture?", "answer": "The Cholesky block is used to decompose the covariance matrix \u03a3k into a lower triangular matrix and its transpose. This decomposition is used to ensure that the covariance matrix is positive definite, which is a requirement for the Gaussian distribution.", "explanation": "The Cholesky block is shown in the figure as a blue box. It takes the covariance matrix \u03a3k as input and outputs a lower triangular matrix. This matrix is then used to generate the variance of the Gaussian distribution.", "reference": "1805.06431v4-Figure3-1.png"}, {"question": "What is the purpose of the Cholesky Block in this figure?", "answer": "The Cholesky Block is used to distinguish abnormal patterns from normal patterns.", "explanation": "The Cholesky Block takes the target weight matrix W\u2217 and auxiliary matrix Z as input and outputs a correlated weight matrix W\u0303k. This correlated weight matrix is then used to learn the abnormal patterns.", "reference": "1805.06431v4-Figure2-1.png"}, {"question": "Is it more beneficial to use ConvNet+CN with or without Mixup when the corruption probability is 80%? Explain your reasoning.", "answer": "ConvNet+CN with Mixup achieves a higher accuracy (75.4%) than ConvNet+CN without Mixup (65.2%) when the corruption probability is 80%.", "explanation": "The table directly compares the test accuracies of different methods under varying corruption probabilities. By looking at the row corresponding to 80% corruption, we can see the performance of each method under that specific condition. The table clearly shows that ConvNet+CN combined with Mixup yields a higher accuracy than ConvNet+CN alone at that corruption level.", "reference": "1805.06431v4-Table13-1.png"}, {"question": "How does the accuracy of the Mixup method change as the level of random shuffle increases?", "answer": "The accuracy of the Mixup method decreases as the level of random shuffle increases.", "explanation": "The figure shows that the Mixup method achieves the highest accuracy with 50% random shuffle and the lowest accuracy with 95% random shuffle. This suggests that the Mixup method is more sensitive to the level of noise in the data than the other methods.", "reference": "1805.06431v4-Figure12-1.png"}]}, "1812.00108v4": {"paper_id": "1812.00108v4", "all_figures": {"1812.00108v4-Figure2-1.png": {"caption": "Figure 2: Multi-DPP is applied to increase diversity within the selected time-steps. When view labels are available, we also use cross-entropy to learn representative view(s) at each time-step.", "content_type": "figure", "figure_type": "Schematic"}, "1812.00108v4-Table3-1.png": {"caption": "Scalability Analysis: Our framework can be trained and tested on data of different number-of-views.", "content_type": "table", "figure_type": "table"}, "1812.00108v4-Table2-1.png": {"caption": "Fixed-cameras multi-view f1-scores. We train our supervised model on Multi-Ego and test it on three datasets.", "content_type": "table", "figure_type": "table"}, "1812.00108v4-Table1-1.png": {"caption": "MultiEgo benchmarking for two-view and three-view settings. Ours consistently outperforms the baselines on all the measures. We also run an ablation study to show the effect of optimizing the supervised Multi-DPP measure as compared to using only Cross-Entropy.", "content_type": "table", "figure_type": "table"}, "1812.00108v4-Figure1-1.png": {"caption": "Several views are recorded independently and intermittently overlap their fields-of-view. Our approach dynamically accounts for inter- and intra-view dependencies, providing a comprehensive summary of all views.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "How does the Multi-DPP module increase diversity within the selected time-steps?", "answer": "The Multi-DPP module increases diversity within the selected time-steps by using a determinantal point process (DPP) to select a subset of diverse time-steps from the input sequence.", "explanation": "The figure shows that the Multi-DPP module takes as input the feature vectors of all frames at each view and outputs a subset of diverse time-steps. This is done by using a DPP to select a subset of time-steps that are maximally dissimilar to each other.", "reference": "1812.00108v4-Figure2-1.png"}, {"question": "How does the performance of the model change as the number of views increases?", "answer": "The performance of the model generally improves as the number of views increases. For example, when the model is trained and tested on two-view data, the F1-score is 29.67. However, when the model is trained and tested on three-view data, the F1-score increases to 30.2. This suggests that the model is able to learn more effectively from data with more views.", "explanation": "The table in the figure shows the precision, recall, and F1-score of the model for different numbers of views. The F1-score is a measure of the overall performance of the model, and it is calculated as the harmonic mean of precision and recall.", "reference": "1812.00108v4-Table3-1.png"}, {"question": "Which method achieved the highest F1 score on the Lobby dataset?", "answer": "Ours-supervised achieved the highest F1 score on the Lobby dataset with a score of 93.4.", "explanation": "The table shows the F1 scores for different methods on three datasets: Office, Campus, and Lobby. The highest F1 score for the Lobby dataset is 93.4, which is achieved by the Ours-supervised method.", "reference": "1812.00108v4-Table2-1.png"}]}, "1812.00281v3": {"paper_id": "1812.00281v3", "all_figures": {"1812.00281v3-Figure5-1.png": {"caption": "We reconstruct the body occupancy map and its outer surface using shape-from-silhouette and associate the point cloud with body semantics (head, body, arms, and legs).", "content_type": "figure", "figure_type": "photograph(s)"}, "1812.00281v3-Figure6-1.png": {"caption": "Distribution of head pose, gaze and eye pose in normalized space for MPII-Gaze, UT-Multiview, RT-GENE and HUMBI. Horizontal and vertical axis represent yaw and pitch angle respectively (unit: degree).", "content_type": "figure", "figure_type": "plot"}, "1812.00281v3-Table2-1.png": {"caption": "Table 2: Bias and variance analysis of the distribution of head pose, gaze and eye pose (unit: degree, smallest bias and largest variance in bold, second with underline).", "content_type": "table", "figure_type": "N/A"}, "1812.00281v3-Figure15-1.png": {"caption": "The qualitative results of the monocular 3D body prediction network trained with different dataset combination. The top and bottom show the results tested on UP-3D and HUMBI Body respectively.", "content_type": "figure", "figure_type": "photograph(s)"}, "1812.00281v3-Figure16-1.png": {"caption": "Garment silhouette error.", "content_type": "figure", "figure_type": "plot"}, "1812.00281v3-Figure2-1.png": {"caption": "We present HUMBI that pushes towards two extremes: views and subjects. The view-specific appearance measured by 107 HD cameras regarding five elementary body expressions for 772 distinctive subjects.", "content_type": "figure", "figure_type": "plot"}, "1812.00281v3-Table4-1.png": {"caption": "Table 4: The mean error of 3D face mesh prediction for cross-data evaluation (unit: pixel).", "content_type": "table", "figure_type": "N/A"}, "1812.00281v3-Table3-1.png": {"caption": "Table 3: The mean error of 3D gaze prediction for the cross-data evaluation (unit: degree).", "content_type": "table", "figure_type": "N/A"}, "1812.00281v3-Figure12-1.png": {"caption": "The training setup for 3D mesh prediction from a single image.", "content_type": "figure", "figure_type": "** Schematic"}, "1812.00281v3-Table1-1.png": {"caption": "Table 1: Human body expression datasets.", "content_type": "table", "figure_type": "N/A"}, "1812.00281v3-Figure11-1.png": {"caption": "HUMBI body and cloth reconstruction results.", "content_type": "figure", "figure_type": "photograph(s)"}, "1812.00281v3-Figure10-1.png": {"caption": "Face reconstruction (Section B.3). (Top) Recovered 3D faces with various expressions (Bottom left) Alignment between projected mesh and subject\u2019s face. (Bottom right) Estimated illumination condition.", "content_type": "figure", "figure_type": "** photograph(s)"}, "1812.00281v3-Table7-1.png": {"caption": "Table 7: Cross-data evaluation results of 3D body keypoint prediction. Metric is AUC of PCK calculated over an error range of 0-150 mm.", "content_type": "table", "figure_type": "N/A"}, "1812.00281v3-Table8-1.png": {"caption": "Table 8: The mean error of 3D body mesh prediction for cross-data evaluation (unit: pixel).", "content_type": "table", "figure_type": "N/A"}, "1812.00281v3-Figure8-1.png": {"caption": "We conduct camera-ablation study to evaluate the accuracy of the garment reconstruction in terms of the density (left) and the accuracy (right).", "content_type": "figure", "figure_type": "plot"}, "1812.00281v3-Table6-1.png": {"caption": "Table 6: The mean error of 3D hand mesh prediction for cross-data evaluation (unit: pixel).", "content_type": "table", "figure_type": "N/A"}, "1812.00281v3-Figure3-1.png": {"caption": "(Top and bottom) HUMBI includes 772 distinctive subjects across gender, ethnicity, age, clothing style, and physical condition, which generates diverse appearance of human expressions. (Middle) For each subject, 107 HD cameras capture her/his expressions including gaze, face, hand, body, and garment.", "content_type": "figure", "figure_type": "photograph(s)"}, "1812.00281v3-Figure9-1.png": {"caption": "Gaze signals computed by our system (Sec. B.2). (Left) 3D demonstration of captured gaze placed on the black dotted body joints. Black arrow is gaze direction. Red, green and blue segment are x, y and z-axis of gaze frame. Brown segment is the center axis of the head cylinder. (Right) Gaze overlaid on a color image. Orange arrow is gaze direction. Dark blue box indicates eye region. Blue box wraps face. Yellow area is projection of the cylinder.", "content_type": "figure", "figure_type": "photograph(s)"}, "1812.00281v3-Figure4-1.png": {"caption": "View-specific appearance rendered from multiview images with median appearance and variance for (a) gaze, (b) face, (c) hand, (d) body.", "content_type": "figure", "figure_type": "photograph(s)"}}, "qa": [{"question": "What is the relationship between the camera yaw angle and the silhouette distance?", "answer": "The silhouette distance generally increases as the camera yaw angle increases.", "explanation": "The figure shows that the silhouette distance is higher for larger camera yaw angles, indicating that the silhouette is more distorted when the camera is at a greater angle to the person.", "reference": "1812.00281v3-Figure16-1.png"}, {"question": "How does HUMBI compare to other datasets in terms of the number of subjects?", "answer": "HUMBI has the highest number of subjects compared to the other datasets.", "explanation": "The figure shows a scatter plot of the number of views vs. the number of subjects for several datasets. HUMBI is located in the upper right corner of the plot, indicating that it has the highest number of views and subjects.", "reference": "1812.00281v3-Figure2-1.png"}, {"question": "Which dataset has the most concentrated distribution of gaze and head pose?", "answer": "MPII-Gaze", "explanation": "The figure shows the distribution of gaze, head pose, and eye pose for four different datasets. The MPII-Gaze dataset has the most concentrated distribution of gaze and head pose, as the heatmap is more concentrated around the center.", "reference": "1812.00281v3-Figure6-1.png"}, {"question": "What are the differences between the results of the monocular 3D body prediction network trained with different dataset combinations?", "answer": "The results of the monocular 3D body prediction network trained with different dataset combinations show that the Up3d+HUMBI dataset combination produces the most accurate results. This is evident in the images where the predicted 3D body poses are closer to the ground-truth poses than the other dataset combinations.", "explanation": "The figure shows the results of the monocular 3D body prediction network trained with different dataset combinations. The first column shows the input images, the second column shows the ground-truth 3D body poses, and the third, fourth, and fifth columns show the predicted 3D body poses for the Up3d, HUMBI, and Up3d+HUMBI dataset combinations, respectively.", "reference": "1812.00281v3-Figure15-1.png"}, {"question": "What are the different stages of HUMBI body and cloth reconstruction?", "answer": "The different stages of HUMBI body and cloth reconstruction are: \n1. Input image of the person (Ibody)\n2. Keypoint estimation (Kbody)\n3. Occupancy map generation (Obody)\n4. Body model fitting (Mbody)\n5. Cloth model fitting (Mcloth)", "explanation": "The figure shows the different stages of HUMBI body and cloth reconstruction. The input image is first used to estimate the keypoints of the body. These keypoints are then used to generate an occupancy map, which is a 3D representation of the body. The body model is then fitted to the occupancy map, and finally, the cloth model is fitted to the body model.", "reference": "1812.00281v3-Figure11-1.png"}, {"question": "Which dataset performs best when used alone for training a 3D body keypoint prediction model, and how does its performance compare to models trained on combined datasets?", "answer": "HUMBI performs best when used alone for training, with an average AUC of 0.399. While this is lower than the average AUC of models trained on combined datasets (0.433 for H36M+HUMBI and 0.413 for MI3D+HUMBI), HUMBI still achieves the highest score among the individual datasets.", "explanation": "The table shows the cross-data evaluation results for 3D body keypoint prediction. The diagonal cells represent the performance of models trained and tested on the same dataset. By comparing the average AUC values in the last row, we can see that HUMBI outperforms H36M and MI3D when used alone. However, combining HUMBI with either H36M or MI3D further improves the performance, suggesting that these datasets offer complementary information for training.", "reference": "1812.00281v3-Table7-1.png"}, {"question": "Which training data configuration resulted in the lowest prediction error for both UP-3D and HUMBI test sets?", "answer": "Training with UP-3D + HUMBI resulted in the lowest prediction error for both UP-3D and HUMBI test sets.", "explanation": "Table 1 shows the mean error of 3D body mesh prediction for different combinations of training and testing data. For both UP-3D and HUMBI test sets, the lowest error values (**18.4\u00b113.8** and **12.5\u00b18.4** respectively) are observed when the model is trained with **UP-3D + HUMBI**. This suggests that combining both datasets during training leads to better generalization and lower prediction errors compared to using either dataset alone.", "reference": "1812.00281v3-Table8-1.png"}, {"question": "How does the number of cameras used affect the accuracy of the garment reconstruction?", "answer": "The accuracy of the garment reconstruction increases as the number of cameras used increases.", "explanation": "The plot on the right shows that the error in the garment reconstruction decreases as the number of cameras used increases. This is because more cameras provide more viewpoints of the garment, which allows the algorithm to better reconstruct the 3D shape of the garment.", "reference": "1812.00281v3-Figure8-1.png"}, {"question": "How does HUMBI capture diverse appearance of human expressions?", "answer": "HUMBI includes 772 distinctive subjects across gender, ethnicity, age, clothing style, and physical condition, which generates diverse appearance of human expressions.", "explanation": "The figure shows that HUMBI includes people of different genders, ethnicities, ages, clothing styles, and physical conditions. This diversity helps to capture a wide range of human expressions.", "reference": "1812.00281v3-Figure3-1.png"}, {"question": "What is the difference between the \"median appearance\" and the \"view-specific appearance\"?", "answer": "The median appearance is the average of all the multiview images, while the view-specific appearance is a single image that is rendered from a specific viewpoint.", "explanation": "The figure shows that the median appearance is a single image that represents the average of all the multiview images. The view-specific appearance is a single image that is rendered from a specific viewpoint. The variance image shows how much the different multiview images vary from the median appearance.", "reference": "1812.00281v3-Figure4-1.png"}, {"question": "What is the purpose of the decoder in the 3D mesh prediction pipeline?", "answer": "The decoder is responsible for generating the final 3D mesh from the intermediate representations produced by the regression network.", "explanation": "The figure shows that the decoder takes the outputs of the regression network (Output 1 and Output 2) as input and produces the final 3D mesh. This suggests that the decoder performs some sort of post-processing or refinement on the intermediate representations to generate the final output.", "reference": "1812.00281v3-Figure12-1.png"}, {"question": "Which dataset provides data for **both** facial expressions and full-body motion capture, including clothing, in a natural setting (not synthesized)? ", "answer": "HUMBI is the only dataset that provides data for both facial expressions and full-body motion capture, including clothing, in a natural setting. ", "explanation": "Table 1 summarizes various human body expression datasets and their features. By looking at the columns for \"Face,\" \"Body,\" and \"Cloth,\" we can identify datasets containing relevant data. However, we also need to consider the \"Measurement method\" and the information in the caption to determine if the data is captured in a natural setting or synthesized. \n\n- Several datasets provide facial expression data (e.g., CMU Multi-PIE, 3DMM), but they lack full-body motion capture. \n- Datasets like CMU Mocap and Human 3.6M offer body motion capture but lack facial expression data. \n- While datasets like INRIA and BUFF include both face and body data in a natural setting, they lack clothing information. \n- HUMBI is the only dataset that has checkmarks for \"Face,\" \"Body,\" and \"Cloth\" columns and explicitly mentions \"natural\" in the \"Cloth\" column, indicating that it captures all these aspects in a real-world setting.", "reference": "1812.00281v3-Table1-1.png"}]}, "1706.03847v3": {"paper_id": "1706.03847v3", "all_figures": {"1706.03847v3-Table1-1.png": {"caption": "Table 1: Properties of the datasets.", "content_type": "table", "figure_type": "N/A"}, "1706.03847v3-Figure1-1.png": {"caption": "Mini-batch based negative sampling.", "content_type": "figure", "figure_type": "schematic"}, "1706.03847v3-Figure4-1.png": {"caption": "Training times with different sample sizes on the CLASS dataset.", "content_type": "figure", "figure_type": "plot"}, "1706.03847v3-Figure3-1.png": {"caption": "Recommendation accuracy with additional samples on the CLASS dataset. \"ALL\"means that there is no sampling, but scores are computed for all items in every step.", "content_type": "figure", "figure_type": "plot."}, "1706.03847v3-Figure5-1.png": {"caption": "The effect of the alpha parameter on recommendation accuracy at different sample sizes on the CLASS dataset. Left: cross-entropy loss; Middle: TOP1-max loss; Right: BPR-max loss.", "content_type": "figure", "figure_type": "plot"}, "1706.03847v3-Table2-1.png": {"caption": "Table 2: Recommendation accuracy with additional samples and different loss functions compared to item-kNN and the original GRU4Rec. Improvements over item-kNN and the original GRU4Rec (with TOP1 loss) results are shown in parentheses. Best results are typeset bold.", "content_type": "table", "figure_type": "N/A"}, "1706.03847v3-Figure6-1.png": {"caption": "Performance of GRU4Rec relative to the baseline in the online A/B test.", "content_type": "figure", "figure_type": "plot"}, "1706.03847v3-Table3-1.png": {"caption": "Results with unified embeddings. Relative improvement over the same network without unified item representation is shown in the parentheses.", "content_type": "table", "figure_type": "table"}, "1706.03847v3-Figure2-1.png": {"caption": "Median negative gradients of BPR and BPR-max w.r.t. the target score against the rank of the target item. Left: only minibatch samples are used (minibatch size: 32); Center: 2048 additional negative samples were added to the minibatch samples; Right: same setting as the center, focusing on ranks 0-200.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "How does the alpha parameter affect recommendation accuracy for different sample sizes on the CLASS dataset?", "answer": "The alpha parameter generally increases recommendation accuracy as the sample size increases. However, the effect of alpha varies depending on the loss function used. For cross-entropy loss, alpha has a relatively small effect on accuracy. For TOP1-max loss, alpha has a larger effect on accuracy, especially for smaller sample sizes. For BPR-max loss, alpha has a very large effect on accuracy, with higher values of alpha leading to much higher accuracy.", "explanation": "The figure shows the recall of the recommendation system for different values of alpha and different sample sizes. The recall is a measure of how well the system recommends relevant items. The figure shows that the recall generally increases as the sample size increases, and that the effect of alpha varies depending on the loss function used.", "reference": "1706.03847v3-Figure5-1.png"}, {"question": "Which combination of method and dataset achieved the highest Recall@20 score, and how much higher was it compared to the original GRU4Rec model?", "answer": "The highest Recall@20 score was achieved by the GRU4Rec with additional samples and BPR-max loss function on the RSC15 dataset. This score was 42.37% higher than the Recall@20 score of the original GRU4Rec model on the same dataset.", "explanation": "The table presents Recall@20 scores for different combinations of methods and datasets. By looking at the row for the RSC15 dataset and the column for the BPR-max loss function within the \"GRU4Rec with additional samples\" section, we can find the highest score (0.7211). The percentage improvement over the original GRU4Rec is also provided in parentheses within the same cell (+42.37%).", "reference": "1706.03847v3-Table2-1.png"}, {"question": "What is the performance of GRU4Rec relative to the baseline in terms of watch time?", "answer": "GRU4Rec has a slightly higher performance than the baseline in terms of watch time.", "explanation": "The bar for GRU4Rec in the \"Watch time\" category is slightly higher than the bar for the baseline.", "reference": "1706.03847v3-Figure6-1.png"}, {"question": "Which dataset contains the most interactions (events) in the training set and how much larger is it compared to the dataset with the least interactions in the training set?", "answer": "The VIDXL dataset contains the most interactions (events) in the training set with 69,312,698 events. This is roughly 7.7 times larger than the RSC15 dataset, which has the least interactions (9,011,321) in the training set. ", "explanation": "By looking at the \"Events\" column under the \"Train set\" section of Table 1, we can compare the number of interactions for each dataset. VIDXL clearly has the highest number, while RSC15 has the lowest. To determine the relative size difference, we simply divide the number of events in VIDXL by the number of events in RSC15 (69,312,698 / 9,011,321 \u2248 7.7).", "reference": "1706.03847v3-Table1-1.png"}, {"question": "What is the purpose of negative sampling?", "answer": "Negative sampling is a technique used to reduce the number of negative examples that need to be considered during training.", "explanation": "The figure shows how negative sampling works. A mini-batch of desired items is fed into the network, and the network outputs a score for each item. The target scores are then computed, with a score of 1 for the positive item and a score of 0 for all other items. However, instead of considering all negative items, only a small number of negative items are sampled. This reduces the computational cost of training while still providing a good approximation of the true loss function.", "reference": "1706.03847v3-Figure1-1.png"}, {"question": "How does the training time of the different losses change as the number of additional samples increases?", "answer": "The training time of all losses increases as the number of additional samples increases.", "explanation": "The figure shows the training time of different losses on the y-axis and the number of additional samples on the x-axis. As the number of additional samples increases, the training time for all losses also increases. This is because the model has to process more data as the number of samples increases, which takes more time.", "reference": "1706.03847v3-Figure4-1.png"}, {"question": "Which dataset has the highest Recall@20 and MRR@20?", "answer": "VIDXL has the highest Recall@20 and MRR@20.", "explanation": "The table shows the Recall@20 and MRR@20 for four different datasets. VIDXL has the highest values for both metrics.", "reference": "1706.03847v3-Table3-1.png"}, {"question": "How does the addition of negative samples affect the gradient of BPR and BPR-max with respect to the target score?", "answer": "The addition of negative samples increases the gradient of BPR and BPR-max with respect to the target score.", "explanation": "The plots in the center and right panels of the figure show that the gradients of BPR and BPR-max are higher when 2048 additional negative samples are added to the minibatch samples (center and right panels) than when only minibatch samples are used (left panel).", "reference": "1706.03847v3-Figure2-1.png"}]}, "1706.04269v2": {"paper_id": "1706.04269v2", "all_figures": {"1706.04269v2-Figure2-1.png": {"caption": "Illustration of two human search sequences from our Human Searches dataset for an AVA [21] training video (first row) and a THUMOS14 [24] training video (second row). The shaded green areas are where the search targets occur.", "content_type": "figure", "figure_type": "plot"}, "1706.04269v2-Figure1-1.png": {"caption": "Left: A partial search sequence a human performed to find the start of a Long Jump action (the shaded green area). Notably, humans are efficient in spotting actions without observing a large portion of the video. Right: An efficiency comparison between humans, Action Search, and other detection/proposal methods on THUMOS14 [24]. Our model is 5.8x more efficient than other methods.", "content_type": "figure", "figure_type": "** schematic"}, "1706.04269v2-Figure3-1.png": {"caption": "Fig. 3: Our model harnesses the temporal context from its current location and the history of what it has observed to predict the next search location in the video. At each step, (i) a visual encoder transforms the visual observation extracted from the model\u2019s current temporal location to a representative feature vector; (ii) an LSTM consumes this feature vector plus the state and temporal location produced in the previous step; (iii) the LSTM outputs its updated state and the next search location; (iv) the model moves to the new temporal location.", "content_type": "figure", "figure_type": "schematic"}, "1706.04269v2-Figure4-1.png": {"caption": "Fig. 4: Action spotting results for the AVA testing set for 1000 independent search trials per video. We report the cumulative spotting metric results on videos with action coverage (i.e. the percentage of video containing actions) \u2264 5%. Action Search takes 22%, 17%, and 13% fewer observations than the Direction Baseline on videos with at most 0.5%, 2.5%, and 5% action coverage, respectively.", "content_type": "figure", "figure_type": "plot"}, "1706.04269v2-Figure5-1.png": {"caption": "Qualitative search sequences produced by Action Search. The left column corresponds to AVA [21] testing videos, and the right column corresponds to THUMOS14 [24] testing videos. The top two rows depict examples when our model successfully spots the target action location (in green). The last row illustrate failure cases, i.e. when the action location (in red) is not spotted exactly. We observe that Action Search uses temporal context to reason about where to search next. In failure cases, we notice that our model often oscillates around actions without spotting frames within the exact temporal location.", "content_type": "figure", "figure_type": "** photograph(s)"}, "1706.04269v2-Table1-1.png": {"caption": "Temporal localization results (mAP at tIoU) on the THUMOS14 testing set. We assign \u2018\u2013\u2019 to unavailable mAP values. We report the average percentage of observed frames (S) for each approach. (a) Comparison against state-of-theart methods: Our method (Action Search + Priors + Res3D + S-CNN) achieves state-of-the-art results while observing only 17.3% of the video; (b) Video features effect: We compare C3D for Action Search visual encoder + the C3D-based classifier from [35] vs. ResNet for Action Search visual encoder + the Res3Dbased classifier from [41]; (c) The trade-off between Action Search training size and performance: mAP and S score improve as we increase the training size.", "content_type": "table", "figure_type": "table"}}, "qa": [{"question": "What are the three main components of the Action Search model architecture?", "answer": "The three main components of the Action Search model architecture are the visual encoder, the LSTM, and the spotting target.", "explanation": "The figure shows how these three components are connected and how they work together to predict the next search location in the video. The visual encoder takes the visual observation from the current temporal location and transforms it into a feature vector. The LSTM takes this feature vector, as well as the state and temporal location from the previous step, and outputs its updated state and the next search location. The spotting target is the location in the video where the model is currently searching for the action.", "reference": "1706.04269v2-Figure3-1.png"}, {"question": "Which method requires the fewest observations to spot an action in a video with 2.5% action coverage?", "answer": "Action Search", "explanation": "The figure shows that the Action Search method (green bars) consistently requires fewer observations than the other two methods (blue and light blue bars) across all levels of action coverage. At 2.5% action coverage, the Action Search method requires about 120 observations on average, while the Direction Baseline and Random Baseline methods require about 150 and 175 observations, respectively.", "reference": "1706.04269v2-Figure4-1.png"}, {"question": "How does Action Search use temporal context to reason about where to search next?", "answer": "Action Search uses temporal context to reason about where to search next by looking at the frames before and after the current frame. This allows the model to learn the temporal patterns of actions and to predict where the action is most likely to occur in the next frame.", "explanation": " The figure shows the search sequences produced by Action Search for different videos. The x-axis shows the model search step, and the y-axis shows the video time. The blue dots represent the frames that the model has searched, and the green and red boxes represent the ground-truth action locations. The figure shows that the model is able to use temporal context to successfully spot the target action location in some cases, but it also fails in some cases. In the failure cases, the model often oscillates around the action without spotting frames within the exact temporal location.", "reference": "1706.04269v2-Figure5-1.png"}, {"question": "How does the training size of the Action Search model affect its performance?", "answer": "As the training size increases, the mAP and S score of the Action Search model also improve.", "explanation": "This can be seen in Figure (c), where the mAP and S score are shown for different training sizes.", "reference": "1706.04269v2-Table1-1.png"}]}, "1706.04284v3": {"paper_id": "1706.04284v3", "all_figures": {"1706.04284v3-Figure1-1.png": {"caption": "(a) Upper: conventional semantic segmentation pipeline; lower: our proposed framework for joint image denoising and semantic segmentation. (b) Zoom-in regions of a noisy input, its denoised estimates using CBM3D and our proposed method, as well as its ground truth.", "content_type": "figure", "figure_type": "schematic"}, "1706.04284v3-Figure5-1.png": {"caption": "Two semantic segmentation examples from Pascal VOC 2012 validation set. From left to right: (a) the ground truth image, the denoised image using (b) the separately trained denoiser, (c) the denoiser trained with the reconstruction and segmentation joint loss, and (d) the denoiser trained with the classification network and evaluated for semantic segmentation. Their corresponding segmentation label maps are shown below. The zoom-in region which generates inaccurate segmentation in (b) is displayed in the red box.", "content_type": "figure", "figure_type": "** photograph(s)"}, "1706.04284v3-Figure2-1.png": {"caption": "(a) Overview of our proposed denoising network. (b) Architecture of the feature encoding module. (c) Architecture of the feature decoding module.", "content_type": "figure", "figure_type": "schematic"}, "1706.04284v3-Figure3-1.png": {"caption": "Overview of our proposed cascaded network.", "content_type": "figure", "figure_type": "schematic"}, "1706.04284v3-Table1-1.png": {"caption": "Table 1: Color image denoising results (PSNR) of different methods on Kodak dataset. The best result is shown in bold.", "content_type": "table", "figure_type": "N/A"}, "1706.04284v3-Figure4-1.png": {"caption": "(a) Two image denoising examples from Kodak dataset. We show (I) the ground truth image and the zoom-in regions of: (II) the denoised image by CBM3D; (III) the denoised image by DnCNN; the denoising result of our proposed model (IV) without the guidance of high-level vision information; (V) with the guidance of high-level vision information and (VI) the ground truth.", "content_type": "figure", "figure_type": "photograph(s)"}, "1706.04284v3-Table3-1.png": {"caption": "Table 3: Segmentation results (mIoU) after denoising noisy image input, averaged over Pascal VOC 2012 validation dataset. Red is the best and blue is the second best results.", "content_type": "table", "figure_type": "N/A"}, "1706.04284v3-Table2-1.png": {"caption": "Table 2: Classification accuracy after denoising noisy image input, averaged over ILSVRC2012 validation dataset. Red is the best and blue is the second best results.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "What is the difference between the conventional semantic segmentation pipeline and the proposed framework for joint image denoising and semantic segmentation?", "answer": "The conventional semantic segmentation pipeline performs semantic segmentation directly on the noisy input image, while the proposed framework first denoises the image before performing semantic segmentation.", "explanation": "This can be seen in Figure (a), which shows the two pipelines side-by-side. The conventional pipeline has a single step, where the noisy input image is fed into a semantic segmentation network. The proposed framework has two steps: first, the noisy input image is denoised using a denoising network, and then the denoised image is fed into a semantic segmentation network.", "reference": "1706.04284v3-Figure1-1.png"}, {"question": " Which denoiser performs the best on the sheep image, and how can you tell?", "answer": " The denoiser trained with the classification network and evaluated for semantic segmentation performs the best on the sheep image. This is because the segmentation label map for this denoiser is the most accurate, and it correctly identifies the sheep's body and legs. ", "explanation": " The figure shows the ground truth image and the denoised images using different denoisers. The segmentation label maps below each image show how well each denoiser performs. The denoiser trained with the classification network and evaluated for semantic segmentation has the most accurate segmentation label map, indicating that it performs the best.", "reference": "1706.04284v3-Figure5-1.png"}, {"question": "What is the purpose of the skip connections in the proposed denoising network?", "answer": "The skip connections are used to combine the features from the encoding and decoding modules at each scale. This helps to preserve the spatial information that is lost during the downsampling and upsampling operations.", "explanation": "The figure shows that the skip connections connect the output of the feature encoding module at each scale to the input of the feature decoding module at the same scale. This allows the decoding module to access the features from the encoding module, which helps to improve the reconstruction of the image.", "reference": "1706.04284v3-Figure2-1.png"}, {"question": "Which denoising method performs the best on average across all noise levels tested on the Kodak dataset?", "answer": "The proposed method performs the best on average across all noise levels tested on the Kodak dataset.", "explanation": "The last row of Table 1 shows the average PSNR for each method across all images in the Kodak dataset. For each noise level (\u03c3 = 25, 35, and 50), the proposed method achieves the highest average PSNR compared to the other methods listed. This indicates that, on average, the proposed method performs the best in terms of denoising images from the Kodak dataset for the tested noise levels.", "reference": "1706.04284v3-Table1-1.png"}]}, "1812.06589v2": {"paper_id": "1812.06589v2", "all_figures": {"1812.06589v2-Figure1-1.png": {"caption": "Illustration of proposed audio-visual coherence learning.", "content_type": "figure", "figure_type": "schematic"}, "1812.06589v2-Table4-1.png": {"caption": "Results of user study.", "content_type": "table", "figure_type": "table"}, "1812.06589v2-Figure6-1.png": {"caption": "Qualitative results of ablation.", "content_type": "figure", "figure_type": "photograph(s)"}, "1812.06589v2-Table3-1.png": {"caption": "Ablation study of the key components AMIE and DA in our method as well as two strategies applied in AMIE: Asymmetric Training (Asy.) and JS represented estimator (JS). Ours = Baseline + AMIE + DA, and AMIE = MINE + Asy. + JS.", "content_type": "table", "figure_type": "table"}, "1812.06589v2-Table2-1.png": {"caption": "Cross-dataset evaluation of our method on GRID dataset pre-trained on LRW dataset.", "content_type": "table", "figure_type": "table"}, "1812.06589v2-Figure2-1.png": {"caption": "Figure 2: Pipeline of our proposed method.", "content_type": "figure", "figure_type": "schematic"}, "1812.06589v2-Figure4-1.png": {"caption": "Figure 4: The illustration of the proposed dynamic attention.", "content_type": "figure", "figure_type": "photograph(s)"}, "1812.06589v2-Figure3-1.png": {"caption": "Visualization of distributions of real and generated frames. We reduce the dimension of frames into two-dimension via PCA for better demonstration. It is obvious that the generated samples are closer to the real samples than that with original MINE.", "content_type": "figure", "figure_type": "plot"}, "1812.06589v2-Figure5-1.png": {"caption": "Figure 5: Generation examples of our method comparing with Ground Truth (G.T.) (a), and Zhou et al. and Chen et al. (b). (Better zoom in to see the detail).", "content_type": "figure", "figure_type": "** photograph(s)"}, "1812.06589v2-Table1-1.png": {"caption": "Quantitative results.", "content_type": "table", "figure_type": "table"}}, "qa": [{"question": "How do the different methods compare in terms of their ability to generate realistic faces?", "answer": "The baseline method generates faces that are blurry and unrealistic, while the other methods generate faces that are more realistic.", "explanation": "The figure shows examples of faces generated by the different methods. The baseline method generates faces that are blurry and unrealistic, while the other methods generate faces that are more realistic.", "reference": "1812.06589v2-Figure6-1.png"}, {"question": "What is the effect of adding DA to the baseline method?", "answer": "Adding DA to the baseline method improves the PSNR and SSIM values, while slightly decreasing the LMD value.", "explanation": "The table shows that the baseline method has a PSNR of 28.88, an SSIM of 0.89, and an LMD of 1.36. When DA is added to the baseline method (b), the PSNR increases to 29.19, the SSIM increases to 0.90, and the LMD decreases to 1.37. This indicates that adding DA improves the image quality and reduces the distortion.", "reference": "1812.06589v2-Table3-1.png"}, {"question": "Which method performed the best on the GRID dataset?", "answer": "AMIE (Ours)", "explanation": "The table shows the results of different methods on the GRID dataset. AMIE (Ours) achieved the highest PSNR and SSIM values, and the lowest LMD value, indicating that it performed the best.", "reference": "1812.06589v2-Table2-1.png"}, {"question": "What is the role of the frame discriminator in the proposed method?", "answer": "The frame discriminator is used to detect whether the generated frame and audio are matched or not.", "explanation": "The figure shows that the frame discriminator takes the generated frame and audio as input and outputs a decision of whether they are matched or not. This information is used to train the talking face generator to produce frames that are more consistent with the input audio.", "reference": "1812.06589v2-Figure2-1.png"}, {"question": "How does the dynamic attention block improve the transition of generated video for arbitrary identities?", "answer": "The dynamic attention block decouples the lip-related and identity-related information, allowing the network to focus on the most important area for generating realistic talking faces.", "explanation": "Figure 2 shows how the dynamic attention block works. The block takes as input the previous generated frame and the current audio frame. It then uses a convolutional neural network to compute a set of attention maps, which are used to weight the different parts of the input frame. The attention maps are then used to generate the next frame. The figure shows that the attention maps focus on the lip area, which is the most important area for generating realistic talking faces.", "reference": "1812.06589v2-Figure4-1.png"}, {"question": "Which method, AMIE or MINE, produces generated frames that are closer in distribution to the real frames?", "answer": "MINE", "explanation": "The figure shows that the red dots, which represent the generated frames produced by MINE, are more closely clustered with the blue triangles, which represent the real frames, than the red dots produced by AMIE. This indicates that the MINE method produces generated frames that are closer in distribution to the real frames.", "reference": "1812.06589v2-Figure3-1.png"}, {"question": " What are the limitations of the Zhou \\textit{et al.} and Chen \\textit{et al.} methods for generating talking-face videos, as compared to the method proposed in the paper?", "answer": " The Zhou \\textit{et al.} method suffers from a \"zoom-in-and-out\" effect, while the Chen \\textit{et al.} method produces lip shapes that differ from the real ones.", "explanation": " Figure \\ref{fig:compare_results} (b) shows that the Zhou \\textit{et al.} method produces frames that appear to zoom in and out, while the Chen \\textit{et al.} method produces frames with inaccurate lip shapes. In contrast, the proposed method generates frames that are more realistic and synchronous with the audio input.", "reference": "1812.06589v2-Figure5-1.png"}, {"question": "Which method performed the best according to the LMD metric?", "answer": "AMIE (Ours)", "explanation": "The table shows the LMD values for different methods, and AMIE (Ours) has the lowest LMD value, which is desirable because lower LMD indicates better performance.", "reference": "1812.06589v2-Table1-1.png"}]}, "1805.06447v3": {"paper_id": "1805.06447v3", "all_figures": {"1805.06447v3-Table3-1.png": {"caption": "Table 3. Testing errors of classification results under different testing data transformations. ITN-V1 represents ITN with DDT transformation function and ITN-V2 represents ITN with DDT and ST transformation functions together.", "content_type": "table", "figure_type": "N/A"}, "1805.06447v3-Table2-1.png": {"caption": "Table 2. Testing errors of the classification results with limited training data, where 0.1% means the training data is randomly selected 0.1% of the MNIST training data while the testing data is the entire MNIST testing data.", "content_type": "table", "figure_type": "N/A"}, "1805.06447v3-Figure1-1.png": {"caption": "Figure 1. Illustration of the intuition of our ITN framework. ITN enhances the discriminator by generating additional pseudo-negative samples in the training step.", "content_type": "figure", "figure_type": ""}, "1805.06447v3-Table4-1.png": {"caption": "Table 4. Testing errors on MNIST and affNIST, where /w DA represents the method is trained with standard data augmentation.", "content_type": "table", "figure_type": "N/A"}, "1805.06447v3-Table5-1.png": {"caption": "Testing errors on SVHN and CIFAR-10.", "content_type": "table", "figure_type": "table"}, "1805.06447v3-Table6-1.png": {"caption": "Testing errors on the miniImageNet dataset.", "content_type": "table", "figure_type": "table"}, "1805.06447v3-Figure4-1.png": {"caption": "Figure 4. Samples generated by AC-GATN (B-CNN) and ITN (BCNN) on MNIST.", "content_type": "figure", "figure_type": "photograph(s)"}, "1805.06447v3-Figure5-1.png": {"caption": "Figure 5. Samples generated by ITN with different thresholds Tu. The number below each sample represents the threshold.", "content_type": "figure", "figure_type": "photograph(s)"}, "1805.06447v3-Table7-1.png": {"caption": "Table 7. Testing errors of ITN (B-CNN) with various thresholds on MNIST.", "content_type": "table", "figure_type": "N/A"}, "1805.06447v3-Table8-1.png": {"caption": "Testing errors of ITN and ITN-NG on MNIST, affNIST, and TMTA task, where ITN-NG is the version of ITN without generating pseudo-negative samples.", "content_type": "table", "figure_type": "table"}, "1805.06447v3-Figure3-1.png": {"caption": "Figure 3. Testing errors of AC-GATN (B-CNN) and ITN (B-CNN) on the MNIST dataset.", "content_type": "figure", "figure_type": "photograph(s)"}, "1805.06447v3-Table1-1.png": {"caption": "Table 1. Testing errors of TMTA task.", "content_type": "table", "figure_type": "N/A"}, "1805.06447v3-Figure2-1.png": {"caption": "Images generated by ITN. Each row from top to bottom represents the images generated on MNIST, affNIST, SVHN and CIFAR-10.", "content_type": "figure", "figure_type": "photograph(s)"}}, "qa": [{"question": "How does the performance of ITN-V2 compare to other methods when both DDT and ST transformations are applied to the CIFAR-10 dataset?", "answer": "ITN-V2 achieves the lowest testing error (56.95%) among all methods listed when both DDT and ST transformations are applied to the CIFAR-10 dataset.", "explanation": "The table shows the testing errors of different methods on both MNIST and CIFAR-10 datasets, with and without DDT and ST transformations. Looking at the \"CIFAR-10\" column with \"DDT + ST\" header, we can compare the error rates of all methods under these specific transformations. ITN-V2 shows the lowest error rate, indicating the best performance in resisting both DDT and ST variations among the listed methods.", "reference": "1805.06447v3-Table3-1.png"}, {"question": "Which method performs the best when trained with only 1% of the MNIST training data, and how much does data augmentation improve its performance in this scenario?", "answer": "When trained with only 1% of the MNIST training data, ITN (B-CNN) (w/ DA) performs the best with a testing error of 2.78%. Data augmentation further improves its performance by 0.4%, bringing the testing error down to 2.78% from 3.18% achieved by ITN (B-CNN) without data augmentation.", "explanation": "The table presents the testing errors of different methods under various training data limitations. By looking at the row corresponding to 1% and comparing the values across different methods, we can identify the best performing model. The difference in testing error between ITN (B-CNN) with and without data augmentation (w/ DA) indicates the improvement achieved through data augmentation.", "reference": "1805.06447v3-Table2-1.png"}, {"question": "How does the ITN framework generate pseudo-negative samples?", "answer": "The ITN framework generates pseudo-negative samples by applying learned transformations to positive samples.", "explanation": " The figure shows that the ITN framework consists of a transformation module and a CNN classifier. The transformation module learns to transform positive samples in a way that maximizes their variation from the original training samples. These transformed positive samples are then used as pseudo-negative samples to train the CNN classifier.\n\n**Figure type:** Schematic", "reference": "1805.06447v3-Figure1-1.png"}, {"question": "Which method performs best on the CIFAR-10 dataset?", "answer": "ITN (ResNet-32) with data augmentation performs best on the CIFAR-10 dataset with a testing error of 5.82%.", "explanation": "The table shows the testing errors for different methods on the SVHN and CIFAR-10 datasets. We can see that ITN (ResNet-32) with data augmentation has the lowest testing error for the CIFAR-10 dataset.", "reference": "1805.06447v3-Table5-1.png"}, {"question": "Which method achieved the lowest testing error on the miniImageNet dataset?", "answer": "ITTN (ResNet-32) (w/ DA) achieved the lowest testing error on the miniImageNet dataset with an error rate of 29.65%.", "explanation": "The table shows the testing errors of different methods on the miniImageNet dataset. The method with the lowest error rate is ITTN (ResNet-32) (w/ DA).", "reference": "1805.06447v3-Table6-1.png"}, {"question": "Which generative model generates more accurate and realistic samples on the MNIST dataset, AC-GATN or ITN?", "answer": "ITN generates more accurate and realistic samples on the MNIST dataset compared to AC-GATN.", "explanation": "Figure 2 shows the samples generated by AC-GATN and ITN on the MNIST dataset at different epochs. As the training progresses, the samples generated by ITN become increasingly clear and accurate, while some samples generated by AC-GATN remain misleading and inaccurate, even at epoch 100. This suggests that ITN is a better choice for generating realistic and accurate samples on the MNIST dataset.", "reference": "1805.06447v3-Figure4-1.png"}, {"question": "How does the quality of the generated samples change as the update threshold increases?", "answer": "The quality of the generated samples decreases as the update threshold increases.", "explanation": "Figure 5 shows samples generated by ITN with different update thresholds. The number below each sample represents the threshold. As the threshold increases, the samples become increasingly blurry and difficult to recognize.", "reference": "1805.06447v3-Figure5-1.png"}, {"question": "Describe the relationship between the update threshold (Tu) and the performance of ITN (B-CNN) on the MNIST dataset.", "answer": "The performance of ITN (B-CNN) on the MNIST dataset decreases as the update threshold (Tu) increases. This is evident from the increasing ITN error percentages as Tu goes from 1e-3 to 1e-1.", "explanation": "Table 1 explicitly shows the ITN error for various Tu values. As we move down the table, Tu increases, and correspondingly, the ITN error also increases. This trend indicates an inverse relationship between Tu and the performance of ITN. The passage further explains that this performance drop is due to the decrease in the quality of generated samples when the threshold is increased.", "reference": "1805.06447v3-Table7-1.png"}, {"question": "Which method has the lower testing error on the MNIST task?", "answer": "ITN", "explanation": "The table shows that ITN has a testing error of 0.47% on the MNIST task, while ITN-NG has a testing error of 0.49%.", "reference": "1805.06447v3-Table8-1.png"}, {"question": "Which generative model generates more accurate and realistic samples on the MNIST dataset, AC-GATN or ITN?", "answer": "ITN generates more accurate and realistic samples on the MNIST dataset compared to AC-GATN.", "explanation": "Figure 2 shows the samples generated by AC-GATN and ITN on the MNIST dataset at different epochs. As the training progresses, the samples generated by ITN become increasingly clear and accurate, while some samples generated by AC-GATN remain misleading and inaccurate, even at epoch 100. This suggests that ITN is a better choice for generating realistic and accurate samples on the MNIST dataset.", "reference": "1805.06447v3-Figure3-1.png"}, {"question": "Which method performs best on the TMTA task and how much does data augmentation contribute to its performance?", "answer": "The ITN (B-CNN) method with data augmentation (DA) performs best on the TMTA task, achieving a testing error of 21.31%. Data augmentation contributes significantly to its performance, as the ITN (B-CNN) method without DA has a higher testing error of 31.67%.", "explanation": "Table 1 presents the testing errors of different methods on the TMTA task. The method with the lowest error rate is considered the best performing. We can see that ITN (B-CNN) with DA has the lowest error rate (21.31%) among all methods. Additionally, comparing the performance of ITN (B-CNN) with and without DA reveals a substantial improvement in error rate when DA is used, indicating its significant contribution to the performance.", "reference": "1805.06447v3-Table1-1.png"}]}, "1805.07567v2": {"paper_id": "1805.07567v2", "all_figures": {"1805.07567v2-Table3-1.png": {"caption": "Table 3. Quantitative comparison of different methods on 6 popular datasets. Our proposed FLoss consistently improves performance in terms of both MAE (the smaller the better) and F-measure (the larger the better). Especially in terms of Mean F-measure, we outperform the state-of-the-art with very clear margins, because our method is able to produce high-contrast predictions that can achieve high F-measure under a wide range of thresholds.", "content_type": "table", "figure_type": "N/A"}, "1805.07567v2-Figure3-1.png": {"caption": "Salient object detection examples on several popular datasets. F-DHS, F-Amulet and F-DSS indicate the original architectures trained with our proposed FLoss. FLoss leads to sharp salient confidence, especially on the object boundaries.", "content_type": "figure", "figure_type": "photograph(s)"}, "1805.07567v2-Figure4-1.png": {"caption": "(a) F-measures under different thresholds on the ECSSD dataset. (b) The mean and variance of optimal threshold to. FLoss-based methods hold stable to across different datasets (lower to variances) and different backbone architectures (F-DHS, F-Amulet and F-DSS hold very close mean to).", "content_type": "figure", "figure_type": "plot"}, "1805.07567v2-Figure5-1.png": {"caption": "Precision, Recall, F-measure and Maximal F-measure (\u2022) of DSS (- - -) and F-DSS (\u2014) under different thresholds. DSS tends to predict unknown pixels as the majority class\u2013the background, resulting in high precision but low recall. FLoss is able to find a better compromise between precision and recall.", "content_type": "figure", "figure_type": "plot"}, "1805.07567v2-Table4-1.png": {"caption": "Table 4. Performance comparisons across the original cross-entropy loss (Eq. 10), balanced cross-entropy loss (Eq. 15) and our proposed FLoss (Eq. 6). Original cross-entropy learns a biased prior towards the major class (the background). This is evidenced by the low recall: many positive points are mis-predicted as negative because of biased prior. By assigning loss weights on foreground/background samples, the balanced cross-entropy loss can alleviate the unbalancing problem. Our proposed method performs better than the balanced cross-entropy loss, because the F-measure criterion can automatically adjust data unbalance.", "content_type": "table", "figure_type": "N/A"}, "1805.07567v2-Figure6-1.png": {"caption": "Precision, Recall, F-measure of model trained under different \u03b22 (Eq. 1). The precision decreases with the growing of \u03b22 whereas recall increases. This characteristic gives us much flexibility to adjust the balance between recall and precision: use larger \u03b22 in a recall-first application and lower \u03b22 otherwise.", "content_type": "figure", "figure_type": "** \n\nPlot."}, "1805.07567v2-Figure7-1.png": {"caption": "Performance versus training iterations. Our method presents faster convergence and higher converged performance.", "content_type": "figure", "figure_type": "plot"}, "1805.07567v2-Figure1-1.png": {"caption": "Surface plot of different loss functions in a 2-point 2-class classification circumstance. Columns from left to right: F-measure loss defined in Eq. 6, log F-measure loss defined in Eq. 8 and cross-entropy loss in Eq. 10. In top row the ground-truth is [0, 1] and in bottom row the ground-truth is [1, 1]. Compared with cross-entropy loss and Log-FLoss, FLoss holds considerable gradient even in the saturated area, which will force to produce polarized predictions.", "content_type": "figure", "figure_type": "plot"}, "1805.07567v2-Table1-1.png": {"caption": "Table 1. Statistics of SOD datasets. \u2018#Images\u2019 indicates the number of images in a dataset and \u2018contrast\u2019 represents the general contrast between foreground/background. The lower the contrast, the more challenging the dataset is.", "content_type": "table", "figure_type": "N/A"}, "1805.07567v2-Table2-1.png": {"caption": "Table 2. Performance comparison of Log-FLoss (Eq. 8) and FLoss (Eq. 6). FLoss performs better than Log-FLoss on most datasets in terms of MaxF, MeanF and MAE. Specifically FLoss enjoys a large improvement in terms of MeanF because of its high-contrast predictions.", "content_type": "table", "figure_type": "N/A"}, "1805.07567v2-Figure2-1.png": {"caption": "Example saliency maps by FLoss (bottom) and LogFLoss (middle). Our proposed FLoss method produces highcontrast saliency maps.", "content_type": "figure", "figure_type": "photograph(s)"}}, "qa": [{"question": "Which method has the fastest convergence and highest converged performance?", "answer": "F-DSS", "explanation": "The F-DSS line (red dashed line) reaches the highest F-measure value first and also has the highest F-measure value at the end of the training process.", "reference": "1805.07567v2-Figure7-1.png"}, {"question": "Which dataset would you expect to be the most challenging for a model trained on MSRA-B to perform well on, and why?", "answer": "The DUT-OMRON dataset is likely the most challenging for a model trained on MSRA-B.", "explanation": "The passage states that the lower the contrast between foreground and background, the more challenging the dataset. According to the table, DUT-OMRON has the lowest contrast among all the listed datasets, suggesting it presents a greater challenge for models trained on the high-contrast MSRA-B dataset. \n\nAdditionally, DUT-OMRON has a much larger number of images compared to MSRA-B, which could potentially introduce more diverse and complex scenarios for the model to handle. \n\nWhile other factors like object complexity and size variance also contribute to difficulty, based on the information provided, the low contrast and larger size of DUT-OMRON make it a strong candidate for being the most challenging for a model trained on MSRA-B.", "reference": "1805.07567v2-Table1-1.png"}, {"question": "Which model performs best in terms of Mean F-measure on the DUT-OMRON dataset when trained on the MB dataset? How does the FLoss variant of this model compare to its base version?", "answer": "The DSS+FLoss model performs best in terms of Mean F-measure on the DUT-OMRON dataset when trained on the MB dataset, achieving a score of 0.755.\n\nThe FLoss variant of the DSS model shows a clear improvement over the base DSS model, with a Mean F-measure increase from 0.738 to 0.755.", "explanation": "The table provides the Mean F-measure scores for different models on various datasets, including DUT-OMRON, when trained on the MB dataset. By comparing the scores within the DUT-OMRON column and focusing on the MB training data rows, we can identify DSS+FLoss as the top performer. Additionally, comparing DSS+FLoss to DSS within the same dataset and training data conditions shows the positive impact of the FLoss variant.", "reference": "1805.07567v2-Table3-1.png"}, {"question": "Which algorithm achieves a better balance between precision and recall?", "answer": "F-DSS.", "explanation": "The plot shows that F-DSS has a higher F-measure than DSS for all thresholds. The F-measure is a harmonic mean of precision and recall, so a higher F-measure indicates a better balance between the two.", "reference": "1805.07567v2-Figure5-1.png"}, {"question": "Why does the proposed FLoss method perform better than the balanced cross-entropy loss, even though both methods aim to address the data imbalance problem in salient object detection?", "answer": "The FLoss method performs better than the balanced cross-entropy loss because it can automatically adjust to data imbalance using the F-measure criterion, while the balanced cross-entropy loss relies on pre-defined weights for positive and negative samples.", "explanation": "Table 1 shows the performance of three methods: DSS with original cross-entropy loss, DSS with balanced cross-entropy loss, and DSS with FLoss. The FLoss method consistently achieves the highest scores across all datasets in terms of MaxF, MeanF, and MAE. \n\nThe passage explains that both the balanced cross-entropy loss and FLoss attempt to address the data imbalance problem. However, the balanced cross-entropy loss requires manually setting weights for positive and negative samples based on their proportion in a mini-batch. This approach might not be optimal for all cases. \n\nIn contrast, FLoss utilizes the F-measure, which inherently balances precision and recall, allowing it to automatically adapt to the data imbalance without requiring predefined weights. This adaptability likely contributes to FLoss's superior performance compared to the balanced cross-entropy loss.", "reference": "1805.07567v2-Table4-1.png"}, {"question": " \n\nWhat is the effect of increasing the value of \u03b22 on the precision and recall of the model? ", "answer": " \n\nIncreasing the value of \u03b22 decreases the precision and increases the recall of the model.", "explanation": " \n\nThe figure shows that the precision curve (red) slopes downward as \u03b22 increases, while the recall curve (green) slopes upward. This indicates that increasing \u03b22 leads to a decrease in precision and an increase in recall.", "reference": "1805.07567v2-Figure6-1.png"}, {"question": "Which method produces higher contrast saliency maps, FLoss or Log-FLoss?", "answer": "FLoss", "explanation": "The figure shows example saliency maps produced by FLoss and Log-FLoss. The FLoss maps have higher contrast than the Log-FLoss maps, as can be seen by the sharper edges and more distinct foreground objects.", "reference": "1805.07567v2-Figure2-1.png"}]}, "1707.00524v2": {"paper_id": "1707.00524v2", "all_figures": {"1707.00524v2-Figure5-1.png": {"caption": "Comparison of the code loss and the frame reconstruction loss (MSE) for autoencoder after the training of phase 1 & phase 2.", "content_type": "figure", "figure_type": "plot"}, "1707.00524v2-Table1-1.png": {"caption": "Table 1: The prediction loss in MSE for the trained prediction model.", "content_type": "table", "figure_type": "N/A"}, "1707.00524v2-Figure3-1.png": {"caption": "The prediction and reconstruction result for each task domain. For each task, we present 1 set of frames, where the four frames are organized as follows: (1) the ground-truth frame seen by the agent; (2) the predicted frame by the prediction model; (3) the reconstruction of autoencoder trained only with reconstruction loss; (4) the reconstruction of autoencoder trained after the second phase (i.e., trained with both reconstruction loss and code matching loss). Overall, the prediction model could perfectly produce frame output, while the fully trained autoencoder generates slightly blurred frames.", "content_type": "figure", "figure_type": "photograph(s)"}, "1707.00524v2-Figure1-1.png": {"caption": "An illustration over the decision making for the informed exploration framework. At state St, the agent needs to choose from a (1) t to a (|A|)", "content_type": "figure", "figure_type": "Schematic"}, "1707.00524v2-Figure2-1.png": {"caption": "Deep neural network architectures adopted for informed exploration. Up: action-conditional prediction model for predicting over future transition frames; down: autoencoder model for conducting hashing over the state space.", "content_type": "figure", "figure_type": "schematic"}, "1707.00524v2-Figure4-1.png": {"caption": "Left: the predicted future trajectories for each action in Breakout. In each row, the first frame is the ground-truth frame and the following five frames are the predicted future trajectories with length 5. In each row, the agent takes one of the following actions (continuously): (1) no-op; (2) fire; (3) right; (4) left. Right: the hash codes for the frames in the same row ordered in a top-down manner. To save the space, four binary codes are grouped into one hex code, i.e., in a range of [0,15]. The color map is normalized linearly by hex value.", "content_type": "figure", "figure_type": "photograph(s)"}, "1707.00524v2-Table2-1.png": {"caption": "Performance score for the proposed approach and baseline RL approaches.", "content_type": "table", "figure_type": "table"}}, "qa": [{"question": "Which model achieved the highest performance score on the Breakout game?", "answer": "A3C-CTS", "explanation": "The table shows the performance scores for different models on various games. The highest score for the Breakout game is 473.93, which is achieved by the A3C-CTS model.", "reference": "1707.00524v2-Table2-1.png"}, {"question": "Which game has the highest code loss in phase 2?", "answer": "Pacman", "explanation": "The figure shows the code loss for different games in phase 1 and phase 2. The height of the bars represents the code loss. In phase 2, the bar for Pacman is the highest, indicating that it has the highest code loss.", "reference": "1707.00524v2-Figure5-1.png"}, {"question": "What is the difference between the predicted frame and the reconstructed frame for each task domain?", "answer": "The predicted frame is generated by the prediction model, while the reconstructed frame is generated by the autoencoder. The predicted frame is typically more accurate than the reconstructed frame, as the prediction model is trained to predict the future state of the environment, while the autoencoder is only trained to reconstruct the input image.", "explanation": "The figure shows the ground-truth frame, the predicted frame, and the reconstructed frame for each task domain. The predicted frame is typically very similar to the ground-truth frame, while the reconstructed frame is often slightly blurred.", "reference": "1707.00524v2-Figure3-1.png"}, {"question": "What is the difference between the encoder and decoder networks in the action-conditional prediction model?", "answer": "The encoder network takes a one-hot action and the current state as input and outputs a latent representation of the state. The decoder network takes the latent representation and outputs a prediction of the next state.", "explanation": "The figure shows that the encoder network has a smaller input size than the decoder network. This is because the encoder network is only taking in the current state and the action, while the decoder network is taking in the latent representation of the state, which is a more compact representation of the information.", "reference": "1707.00524v2-Figure2-1.png"}]}, "1812.10735v2": {"paper_id": "1812.10735v2", "all_figures": {"1812.10735v2-Figure1-1.png": {"caption": "Figure 1: Example of a non-overlapping sentence. The attention weights of the aspect food are from the model ATAE-LSTM (Wang et al., 2016).", "content_type": "figure", "figure_type": "schematic"}, "1812.10735v2-Table2-1.png": {"caption": "Table 2: Results of the ALSC task in single-task settings in terms of accuracy (%) and Macro-F1 (%).", "content_type": "table", "figure_type": "N/A"}, "1812.10735v2-Table4-1.png": {"caption": "Table 4: Results of the ACD task. Rest14 has 5 aspect categories while Rest15 has 13 ones.", "content_type": "table", "figure_type": "N/A"}, "1812.10735v2-Table3-1.png": {"caption": "Table 3: Results of the ALSC task in multi-task settings in terms of accuracy (%) and Macro-F1 (%).", "content_type": "table", "figure_type": "N/A"}, "1812.10735v2-Figure2-1.png": {"caption": "Figure 2: Network Architecture. The aspect categories are embedded as vectors. The model encodes the sentence using LSTM. Based on its hidden states, aspect-specific sentence representations for ALSC and ACD tasks are learned via constrained attention. Then aspect level sentiment prediction and aspect category detection are made.", "content_type": "figure", "figure_type": "schematic"}, "1812.10735v2-Figure4-1.png": {"caption": "Figure 4: Visualization of attention weights of different aspects in the ACD task from M-CAN-2Ro. The a/m is short for anecdotes/miscellaneous.", "content_type": "figure", "figure_type": "table"}, "1812.10735v2-Figure5-1.png": {"caption": "The regularization loss curves of Rs and Ro during the training of AT-CAN-Ro.", "content_type": "figure", "figure_type": "plot"}, "1812.10735v2-Figure3-1.png": {"caption": "Visualization of attention weights of different aspects in the ALSC task. Three different models are compared.", "content_type": "figure", "figure_type": "plot"}, "1812.10735v2-Figure6-1.png": {"caption": "Figure 6: Examples of overlapping case and error case. The a/m is short for anecdotes/miscellaneous.", "content_type": "figure", "figure_type": "table"}, "1812.10735v2-Table1-1.png": {"caption": "Table 1: The numbers of single- and multi-aspect sentences. OL and NOL denote the overlapping and nonoverlapping multi-aspect sentences, respectively.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "What is the difference between an overlapping case and an error case?", "answer": "An overlapping case is when multiple aspects share the same opinion snippet, while an error case is when the model incorrectly identifies an aspect or opinion.", "explanation": "The figure shows two examples of each case. In the overlapping case, the sentence contains two aspects, \"food\" and \"service,\" both described by the opinion snippet \"highly disappointed.\" The model correctly identifies both aspects and the shared opinion words. In the error case, the model incorrectly identifies the aspect \"a/m\" and the opinion \"disappointing.\"", "reference": "1812.10735v2-Figure6-1.png"}, {"question": "Which dataset has a higher proportion of sentences containing multiple aspects: Rest14 or Rest15?", "answer": "Rest14 has a higher proportion of sentences containing multiple aspects compared to Rest15.", "explanation": "While both datasets have a majority of single-aspect sentences, we can calculate the percentage of multi-aspect sentences in each dataset by dividing the total number of multi-aspect sentences by the total number of sentences. For Rest14, this is 482 (total multi-aspect) / 2535 (total sentences) = 19.01%. For Rest15, it is 309 (total multi-aspect) / 931 (total sentences) = 16.43%. Therefore, Rest14 has a slightly higher proportion of sentences with multiple aspects.", "reference": "1812.10735v2-Table1-1.png"}, {"question": "Why do you think the performance of all models is generally lower on Rest15 compared to Rest14?", "answer": "The performance of all models is generally lower on Rest15 because it has a larger number of aspect categories (13) compared to Rest14 (5). This increased complexity makes it more challenging for the models to accurately identify and classify the aspects.", "explanation": "The caption of Table 1 explicitly states the difference in the number of aspect categories between Rest14 and Rest15. Comparing the F1 scores across both datasets, we can observe a consistent decrease in performance for all models on Rest15. This suggests that the increased number of categories in Rest15 contributes to the overall decrease in performance.", "reference": "1812.10735v2-Table4-1.png"}, {"question": "Which model performed best on the Rest15 dataset for binary classification, and how does its performance compare to the best model for 3-way classification on the same dataset?", "answer": "For binary classification on the Rest15 dataset, M-CAN-2$R_o$ achieved the highest performance with an accuracy of 82.14% and Macro-F1 of 81.58%. In comparison, the best performing model for 3-way classification on Rest15 was M-CAN-2$R_s$, achieving an accuracy of 78.22% and Macro-F1 of 55.80%. This indicates that M-CAN-2$R_o$ performed better in both accuracy and Macro-F1 for binary classification compared to the best model for 3-way classification on the same dataset.", "explanation": "Table 1 provides the performance results of different models on both Rest14 and Rest15 datasets for both 3-way and binary classifications. By comparing the accuracy and Macro-F1 values for each model on the Rest15 dataset, we can identify the best performing models for each classification task. The table clearly shows the values for each model and allows for direct comparison of their performance.", "reference": "1812.10735v2-Table3-1.png"}, {"question": "What are the two main tasks that the CAN network is designed to perform?", "answer": "Aspect-level sentiment classification (ALSC) and aspect category detection (ACD).", "explanation": "The figure shows two separate paths for ALSC and ACD, each with its own attention layer and prediction layer. The ALSC path predicts the sentiment of each aspect, while the ACD path detects the categories of the aspects.", "reference": "1812.10735v2-Figure2-1.png"}]}, "1707.01917v2": {"paper_id": "1707.01917v2", "all_figures": {"1707.01917v2-Figure2-1.png": {"caption": "Overview of Step 2 of TFBA. Induction of higher-order schemata from the tri-partite graph formed from the columns of matrices A, B, and C. Triangles in this graph (solid) represent a 3-ary schema, n-ary schemata for n > 3 can be induced from the 3-ary schemata. Please refer to Section 3.2.2 for details.", "content_type": "figure", "figure_type": "Schematic"}, "1707.01917v2-Table3-1.png": {"caption": "Details of hyper-parameters set for different datasets.", "content_type": "table", "figure_type": "table"}, "1707.01917v2-Table2-1.png": {"caption": "Details of dimensions of tensors constructed for each dataset used in the experiments.", "content_type": "table", "figure_type": "table"}, "1707.01917v2-Figure1-1.png": {"caption": "Overview of Step 1 of TFBA. Rather than factorizing the higher-order tensor X , TFBA performs joint Tucker decomposition of multiple 3-mode tensors, X 1, X 2, and X 3, derived out of X . This joint factorization is performed using shared latent factors A, B, and C. This results in binary schemata, each of which is stored as a cell in one of the core tensors G1, G2, and G3. Please see Section 3.2.1 for details.", "content_type": "figure", "figure_type": "schematic"}, "1707.01917v2-Table1-1.png": {"caption": "Notations used in the paper.", "content_type": "table", "figure_type": "table"}, "1707.01917v2-Table4-1.png": {"caption": "Examples of schemata induced by TFBA. Please note that some of them are 3-ary while others are 4-ary. For details about schema induction, please refer to Section 3.2.", "content_type": "table", "figure_type": "table"}, "1707.01917v2-Table5-1.png": {"caption": "Higher-order RSI accuracies of various methods on the three datasets. Induced schemata for each dataset and method are evaluated by three human evaluators, E1, E2, and E3. TFBA performs better than HardClust for Shootings and NYT Sports datasets. Even though HardClust achieves better accuracy on MUC dataset, it has several limitations, see Section 4 for more details. Chambers-13 solves a slightly different problem called event schema induction, for more details about the comparison with Chambers-13 see Section 4.1.", "content_type": "table", "figure_type": "table"}}, "qa": [{"question": "What does the induced schema Win <A4, B3, C2> represent?", "answer": "The induced schema Win <A4, B3, C2> represents the fact that player A4 won tournament C2, defeating player B3.", "explanation": "The induced schema is shown in the bottom right corner of the figure. It is derived from the tri-partite graph, which shows the relationships between players (A), opponents (B), and tournaments (C). The schema Win <A4, B3, C2> indicates that there is a connection between player A4, opponent B3, and tournament C2, and that this connection represents a win for player A4.", "reference": "1707.01917v2-Figure2-1.png"}, {"question": "Which dataset has the highest value for the hyperparameter  \u03bba?", "answer": "The NYT Sports dataset has the highest value for \u03bba (0.9).", "explanation": "The table shows the values of the hyperparameters for each dataset. The NYT Sports dataset has the highest value for \u03bba.", "reference": "1707.01917v2-Table3-1.png"}, {"question": "What is the shape of the tensor $x^1$ for the Shootings dataset?", "answer": "The shape of the tensor $x^1$ for the Shootings dataset is 3365 x 1295 x 50.", "explanation": "The table in the image shows the dimensions of the tensors constructed for each dataset used in the experiments. The first column of the table lists the datasets, and the second column lists the shapes of the corresponding $x^1$ tensors. The shape of the tensor $x^1$ for the Shootings dataset is given in the second row of the table as 3365 x 1295 x 50.", "reference": "1707.01917v2-Table2-1.png"}, {"question": "What is the definition of a non-negative tensor?", "answer": "A non-negative tensor is a tensor whose elements are all non-negative real numbers.", "explanation": "The figure defines a non-negative tensor as an element of the set of non-negative real numbers raised to the power of the tensor's order.", "reference": "1707.01917v2-Table1-1.png"}, {"question": "What is the role of OpenIE in Step 1 of TFBA?", "answer": "OpenIE is used to extract tuples from the unlabeled text corpus. These tuples are then used to create the 3-mode tensors X1, X2, and X3.", "explanation": "The figure shows that OpenIE is used to process the unlabeled text corpus and produce tuples. These tuples are then used as input to the joint Tucker decomposition process, which produces the binary schemata.", "reference": "1707.01917v2-Figure1-1.png"}, {"question": "Which method achieves the highest accuracy on the Shootings dataset?", "answer": "TFBA", "explanation": "The table shows the accuracy of different methods on different datasets. For the Shootings dataset, TFBA has the highest average accuracy of 0.76.", "reference": "1707.01917v2-Table5-1.png"}]}, "1707.00189v3": {"paper_id": "1707.00189v3", "all_figures": {"1707.00189v3-Table2-1.png": {"caption": "Table 2: Ranking performance using filtered NYT and Wiki. Significant improvements and reductions compared to unfiltered dataset aremarkedwith \u2191 and \u2193 (paired t-test,p < 0.05).", "content_type": "table", "figure_type": "N/A"}, "1707.00189v3-Table1-1.png": {"caption": "Table 1: Ranking performance when trained using contentbased sources (NYT and Wiki). Significant differences compared to the baselines ([B]M25, [W]T10, [A]OL) are indicated with \u2191 and \u2193 (paired t-test, p < 0.05).", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "Which model performs best when trained on the NYT dataset and evaluated on the WT14 dataset, and how does its performance compare to the baselines?", "answer": "The Conv-KNRM model performs best when trained on the NYT dataset and evaluated on the WT14 dataset, achieving an nDCG@20 score of 0.3215. This performance is significantly better than all the baselines: BM25 (B), WT10 (W), and AOL (A).", "explanation": "Looking at the \"WT14\" column and the row corresponding to \"NYT\" under each model, we can compare the nDCG@20 scores. Conv-KNRM has the highest score (0.3215) in that column. The upward arrows next to the score indicate that this performance is statistically significantly better than all the baselines according to a paired t-test.", "reference": "1707.00189v3-Table1-1.png"}]}, "1706.08146v3": {"paper_id": "1706.08146v3", "all_figures": {"1706.08146v3-Figure5-1.png": {"caption": "Figure 5: NMF reconstruction error vs. projection matrix column sparsity.", "content_type": "figure", "figure_type": "plot"}, "1706.08146v3-Figure6-1.png": {"caption": "Figure 6: Accuracy of tensor decomposition on compressed EEG data. Left: Normalized reconstruction error; dashed line indicates baseline reconstruction error on original data. Right: Median Pearson correlations between recovered factors and factors computed from original data.", "content_type": "figure", "figure_type": "plot"}, "1706.08146v3-Figure1-1.png": {"caption": "Figure 1: Schematic illustration of compressed matrix factorization. (i) The matrix M\u0303 is a compressed version of the full data matrix M . (ii) We directly factorize M\u0303 to obtain matrices W\u0303 and H\u0303. (iii) Finally, we approximate the left factor of M via sparse recovery on each column of W\u0303 .", "content_type": "figure", "figure_type": "schematic"}, "1706.08146v3-Figure4-1.png": {"caption": "Figure 4: Visualization of a factor from the tensor decomposition of EEG data that correlates with the onset of seizures in a patient (red dotted lines). The factor recovered from a 5\u00d7 compressed version of the tensor (bottom) retains the peaks that are indicative of seizures.", "content_type": "figure", "figure_type": "** plot"}, "1706.08146v3-Table1-1.png": {"caption": "Table 1: Summary of DNA microarray gene expression datasets, along with runtime (seconds) for each stage of the NMF pipeline on compressed data. Factorize-Recover runs only r instances of sparse recovery, as opposed to the m instances used by the alternative, Recover-Factorize.", "content_type": "table", "figure_type": "N/A"}, "1706.08146v3-Figure2-1.png": {"caption": "Approximation errors Err(X,X\u2217) := \u2016X \u2212X\u2217\u2016F /\u2016X\u2217\u2016F for sparse PCA and NMF on synthetic data with varying column sparsity k of W and projection dimension d. The values of d correspond to 10\u00d7, 5\u00d7, and 2.5\u00d7 compression respectively. Err(W\u0303 , PW ) measures the distance between factors in the compressed domain: low error here is necessary for accurate sparse recovery. Err(W\u0302 ,W ) measures the error after sparse recovery: the recovered factors W\u0302 typically incur only slightly higher error than the oracle lower bound (dotted lines) where PW is known exactly.", "content_type": "figure", "figure_type": "plot"}, "1706.08146v3-Figure3-1.png": {"caption": "Figure 3: Normalized reconstruction errors \u2016W\u0302 H\u0302 \u2212M\u2016F /\u2016M\u2016F for NMF on gene expression data with varying compression factors n/d. FR (blue, solid) is Factorize-Recover, RF (orange, dotted) is RecoverFactorize. The horizontal dashed line is the error when M is decomposed in the original space. Perhaps surprisingly, when n/d > 3, we observe a reduction in reconstruction error when compressed data is first factorized. See the text for further discussion.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "What is the relationship between projection sparsity and normalized reconstruction error?", "answer": "The normalized reconstruction error decreases as the projection sparsity increases, up to a certain point. After that, the error starts to increase again.", "explanation": "The figure shows a plot of the normalized reconstruction error versus the projection sparsity. The error decreases rapidly at first, then levels off and starts to increase again. This suggests that there is an optimal value of projection sparsity that minimizes the reconstruction error.", "reference": "1706.08146v3-Figure5-1.png"}, {"question": "What is the relationship between compression factor and reconstruction error?", "answer": "The reconstruction error increases as the compression factor increases.", "explanation": "The left panel of Figure 1 shows that the normalized reconstruction error increases as the compression factor increases. This is because compressing the data reduces the amount of information that is available, which makes it more difficult to reconstruct the original data accurately.", "reference": "1706.08146v3-Figure6-1.png"}, {"question": "What are the three steps involved in compressed matrix factorization?", "answer": "The three steps involved in compressed matrix factorization are: \n\n1. Compress the full data matrix M to obtain a compressed matrix M\u0303. \n2. Factorize M\u0303 to obtain matrices W\u0303 and H\u0303. \n3. Approximate the left factor of M via sparse recovery on each column of W\u0303.", "explanation": "The figure shows the three steps involved in compressed matrix factorization.", "reference": "1706.08146v3-Figure1-1.png"}, {"question": "Which dataset would likely benefit the most from using the Fac.-Recover approach instead of Recover-Fac. in terms of computational efficiency?", "answer": "The Leukemia dataset would likely benefit the most from using the Fac.-Recover approach.", "explanation": "The passage states that the computation time for NMF is dominated by the cost of solving instances of the LP, which is directly related to the number of features in the dataset. Table 1 shows that the Leukemia dataset has by far the largest number of features (54,675) compared to the other two datasets. Since \\textsc{Fac.-Recover} only needs to run sparse recovery for a smaller number of features (r) compared to the full set of features (m) required by \\textsc{Recover-Fac.}, it would likely offer significant computational savings for the Leukemia dataset.", "reference": "1706.08146v3-Table1-1.png"}, {"question": "What is the effect of increasing the projection dimension d on the approximation error for sparse PCA and NMF?", "answer": "Increasing the projection dimension d decreases the approximation error for both sparse PCA and NMF.", "explanation": "The figure shows that the approximation error decreases as the projection dimension d increases. This is because a higher projection dimension allows for a more accurate representation of the original data.", "reference": "1706.08146v3-Figure2-1.png"}, {"question": "Which method achieves lower approximation error when the compression factor is greater than 3?", "answer": "Factorize-Recover", "explanation": "The figure shows that the blue line (Factorize-Recover) is below the orange line (Recover-Factorize) when the compression factor is greater than 3.", "reference": "1706.08146v3-Figure3-1.png"}]}, "1901.00056v2": {"paper_id": "1901.00056v2", "all_figures": {"1901.00056v2-Table5-1.png": {"caption": "Hyperparameter settings.", "content_type": "table", "figure_type": "table"}, "1901.00056v2-Table6-1.png": {"caption": "Hyperparameters.", "content_type": "table", "figure_type": "table"}, "1901.00056v2-Figure3-1.png": {"caption": "Sensitivity analysis.", "content_type": "figure", "figure_type": "plot"}, "1901.00056v2-Table1-1.png": {"caption": "Dataset Statistics.", "content_type": "table", "figure_type": "table"}, "1901.00056v2-Figure2-1.png": {"caption": "Figure 2: Synonym discovery during the inference phase with SYNONYMNET.", "content_type": "figure", "figure_type": "** schematic"}, "1901.00056v2-Table4-1.png": {"caption": "Table 4: Performance on Synonym Discovery.", "content_type": "table", "figure_type": "N/A"}, "1901.00056v2-Table3-1.png": {"caption": "Candidate entities retrieved using nearest neighbors on Word2vec (upper) and the discovered synonym entities using SYNONYMNET for UNGA (lower).", "content_type": "table", "figure_type": "table"}, "1901.00056v2-Table2-1.png": {"caption": "Table 2: Test performance in AUC and MAP on three datasets. \u2020 indicates the significant improvement over all baselines (p < 0.05).", "content_type": "table", "figure_type": "N/A"}, "1901.00056v2-Figure1-1.png": {"caption": "Overview of the proposed model SYNONYMNET. The diamonds are entities. Each circle is associated with a piece of context in which an entity appears. SYNONYMNET learns to minimize the loss calculated using multiple pieces of contexts via bilateral matching with leaky units.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "What is the range of values for the context number hyperparameter?", "answer": "The range of values for the context number hyperparameter is from 1 to 20.", "explanation": "The table shows the hyperparameter settings, and the context number hyperparameter is listed with a range of values from 1 to 20.", "reference": "1901.00056v2-Table5-1.png"}, {"question": "What is the effect of increasing the margin on the AUC and MAP values?", "answer": "The AUC and MAP values initially increase with increasing margin, but then decrease after a certain point.", "explanation": "The figure shows that the AUC and MAP values for both metrics generally increase with increasing margin, but then decrease after a certain point. This suggests that there is an optimal margin value for maximizing the performance of the model.", "reference": "1901.00056v2-Figure3-1.png"}, {"question": "Which model and training objective combination performs best on the PubMed + UMLS dataset, and how does it compare to the DPE baseline?", "answer": "The SYNONYMNET(Pairwise) model with Leaky Unit performs best on the PubMed + UMLS dataset, achieving an AUC of 0.9838 and a MAP of 0.9872. This is a statistically significant improvement over the DPE baseline, which achieved an AUC of 0.9513 and a MAP of 0.9623.", "explanation": "The table shows the performance of different models and training objectives on three datasets, including PubMed + UMLS. We can identify the best performing model and training objective combination for this dataset by looking at the highest AUC and MAP values in the corresponding column. The table also indicates statistically significant improvements with the symbol \u2020, confirming that \\modelname (Pairwise) with Leaky Unit significantly outperforms DPE on this dataset.", "reference": "1901.00056v2-Table2-1.png"}, {"question": "Which dataset has the most entities?", "answer": "MedBook + MKG", "explanation": "The table shows that the MedBook + MKG dataset has 32,002 entities, which is more than any other dataset.", "reference": "1901.00056v2-Table1-1.png"}, {"question": "What are the four steps involved in the synonym discovery process using {\\modelname}?", "answer": " The four steps involved in the synonym discovery process are: \n\n1. **Entity representation learning:** Learn entity representations from the corpus using WEMBED.\n2. **NN search:** Perform a nearest neighbor search to find candidate entities for the query entity.\n3. **Synonym score calculation:** Calculate the synonym score between the query entity and each candidate entity using SYNONYM NET.\n4. **Synonym entity discovery:** Select the candidate entities with the highest synonym scores as the discovered synonym entities.", "explanation": " The figure shows the four steps involved in the synonym discovery process using {\\modelname}. The figure shows how the query entity is first embedded into a vector space, and then how this vector is used to find candidate entities. The figure also shows how the SYNONYM NET is used to calculate the synonym score between the query entity and each candidate entity. Finally, the figure shows how the candidate entities with the highest synonym scores are selected as the discovered synonym entities.", "reference": "1901.00056v2-Figure2-1.png"}, {"question": "What is the role of the Leaky Unit in the SYNONYMNET model?", "answer": "The Leaky Unit helps to aggregate the context information from different sources and allows the model to learn the relationships between entities and their contexts.", "explanation": "The Leaky Unit is shown in the figure as a white circle with arrows pointing to it from the Context Encoder and the Context Retriever. The arrows indicate that the Leaky Unit receives information from both of these sources. The Leaky Unit then outputs a single representation of the context information, which is used by the Bilateral Matching unit to learn the relationships between entities and their contexts.", "reference": "1901.00056v2-Figure1-1.png"}, {"question": "Which dataset and evaluation metric combination shows the largest performance gap between the best performing model and the baseline model DPE?", "answer": "The largest performance gap is observed in the PubMed + UMLS dataset using the F1@K metric with K=1.", "explanation": "Table 2 presents the performance of different models on synonym discovery for three datasets and three K values for the P@K, R@K, and F1@K metrics. To find the largest performance gap between the best model and DPE, we need to compare their F1@K scores for each dataset and K value. \n\nOn PubMed + UMLS, the best model achieves an F1@1 score of 0.2915, while DPE achieves a score of 0.1253 (not shown in the table but mentioned in the passage). This difference of **0.1662** is the largest observed gap across all datasets and K values. \n \nWhile other datasets and metrics might show larger absolute differences in F1@K scores, the relative difference in this case is more significant, highlighting a substantial performance advantage of the best model over DPE on this specific dataset and metric.", "reference": "1901.00056v2-Table4-1.png"}]}, "1805.08465v3": {"paper_id": "1805.08465v3", "all_figures": {"1805.08465v3-Table1-1.png": {"caption": "Table 1: Performance comparison of image steganography. In the experiment, we use SIR (dB) to quantify the distortion of both cover(C) and secret(S) images, where larger value of SIR indicates better performance. For each row, the SIR value will be highlighted if it outperforms other methods under a given parameter.", "content_type": "table", "figure_type": "N/A"}, "1805.08465v3-Figure2-1.png": {"caption": "Illustration on robustness of Reshuffled-TD on non-ideal experimental conditions. Sub-figure (a) shows the tSIR performance of the method which is influenced by Gaussian noise. In the sub-figure, group 1 corresponds the rank which satisfies the exact-recovery condition, while the rank in group 2 is not. Sub-figure (b) shows the estimation accuracy of the number of components, and the values shown above the bars are the corresponding tSIR performance of the proposed method.", "content_type": "figure", "figure_type": "plot"}, "1805.08465v3-Figure1-1.png": {"caption": "Results on synthetic data to validate our exact-recovery results. We vary different experiment parameters, such as rank r, size n and number of the components N . In each plot, the darker areas denote the worse reconstruction (tSIR \u2264 15dB) while the white areas denote a good recovery (tSIR \u2265 25dB). The gray boundary shows the phase transition, while the red line denotes the phase transition predicted by our theoretical bound derived in Corollary 1.", "content_type": "figure", "figure_type": "plot"}, "1805.08465v3-Figure3-1.png": {"caption": "Figure 3: An example to illustrate the performance of image steganography by different methods. In the figure, the first row shows the original cover images (the first column) and the container images generated by different methods; The second row shows the original secret images (the first column) and its recovery by different methods.", "content_type": "figure", "figure_type": "photograph(s)"}}, "qa": [{"question": "Which steganography method achieves the best performance in terms of distortion for both cover and secret images when embedding 2 bits per channel?", "answer": "The proposed method achieves the best performance for both cover and secret images when embedding 2 bits per channel.", "explanation": "The table shows the Signal to Interference Ratio (SIR) for different steganography methods, with higher values indicating better performance (less distortion). When comparing the SIR values for 2 bits/chn across all datasets, the \"Ours\" column consistently shows the highest or second-highest values for both cover (C) and secret (S) images. This indicates that the proposed method offers superior performance in terms of minimizing distortion for both types of images at this embedding rate.", "reference": "1805.08465v3-Table1-1.png"}]}, "1707.01922v5": {"paper_id": "1707.01922v5", "all_figures": {"1707.01922v5-Figure3-1.png": {"caption": "An overview of the ZDDA testing procedure. We use the SUN RGB-D [36] images for illustration. Different from the color coding in Fig. 2, the colors here are purely used to distinguish different CNNs/classifiers/predictions", "content_type": "figure", "figure_type": "schematic"}, "1707.01922v5-Table7-1.png": {"caption": "Table 7. Performance comparison with different numbers of classes in scene classification. The reported numbers are classification accuracy (%). The color of each cell reflects the performance ranking in each column, where darker color means better performance. PRGB-D represents the task-irrelevant RGB-D pairs", "content_type": "table", "figure_type": "N/A"}, "1707.01922v5-Table6-1.png": {"caption": "Table 6. The performance comparison of the domain adaptation task MNIST\u2192MNIST-M. The color of each cell reflects the performance ranking (darker is better). For ZDDA2, we report the best overall accuracy from Table 5. All the listed methods except ZDDA2 use the MNIST-M training data. Without the access to the MNIST-M training data, ZDDA2 can still achieve the accuracy comparable to those of the competing methods (even outperform most of them) in this task", "content_type": "table", "figure_type": "N/A"}, "1707.01922v5-Figure1-1.png": {"caption": "Fig. 1. We propose zero-shot deep domain adaptation (ZDDA) for domain adaptation and sensor fusion. ZDDA learns from the task-irrelevant dual-domain pairs when the task-relevant target-domain training data is unavailable. In this example domain adaptation task (MNIST [27]\u2192MNIST-M [13]), the task-irrelevant gray-RGB pairs are from the Fashion-MNIST [46] dataset and the Fashion-MNIST-M dataset (the colored version of the Fashion-MNIST [46] dataset with the details in Sec. 4.1)", "content_type": "figure", "figure_type": "schematic"}, "1707.01922v5-Table3-1.png": {"caption": "Table 3. The statistics of the datasets we use. For NIST, we use the \u201cby class\u201d dataset, remove the digits, and treat uppercase and lowercase letters as different classes. For EMNIST, we use the \u201cEMNIST Letters\u201d split which only contains the letters. We create the colored datasets from the original ones using Ganin\u2019s method [13] (see Sec. 4.1 for details). We refer to each dataset by the corresponding dataset ID (e.g. DN and DN -M refer to the NIST and the NIST-M datasets, respectively)", "content_type": "table", "figure_type": "N/A"}, "1707.01922v5-Table5-1.png": {"caption": "Table 5. The overall / average per class accuracy (%) of the domain adaptation tasks (gray scale images \u2192 RGB images) formed by the datasets in Table 3, where we introduce the dataset IDs and use them to refer to the datasets here. The middle four rows show the performance of ZDDA2. The color of each cell reflects the performance ranking in each column, where darker is better. The number in the parenthesis of the middle four rows is the semantic similarity between the T-R and T-I datasets measured by word2vec [29], where larger numbers represent higher semantic similarity. The T-R target-domain training data is only available for the row \u201ctarget only\u201d", "content_type": "table", "figure_type": "N/A"}, "1707.01922v5-Figure4-1.png": {"caption": "Performance comparison between the two sensor fusion methods with black images as the noisy images. We compare the classification accuracy (%) of (a) naive fusion and (b) ZDDA3 under different noise levels in both RGB and depth testing data. (c) shows that ZDDA3 outperforms the naive fusion under most conditions", "content_type": "figure", "figure_type": "plot"}, "1707.01922v5-Table1-1.png": {"caption": "Table 1. Problem setting comparison between ZDDA, unsupervised domain adaptation (UDA), multi-view learning (MVL), and domain generalization (DG)", "content_type": "table", "figure_type": "N/A"}, "1707.01922v5-Table9-1.png": {"caption": "Table 9. Validation of ZDDA\u2019s performance with different base network architectures in scene classification. The reported numbers are classification accuracy (%). The definition of PRGB-D and the representation of the cell color in each column are the same as those in Table 7", "content_type": "table", "figure_type": "N/A"}, "1707.01922v5-Table4-1.png": {"caption": "Table 4. The base network architecture (BNA) we use in our experiments. For each BNA, We specify the layer separating the source/target CNN and the source classifier in Fig. 2. The layer name in the right column is based on the official Caffe [24] and SqueezeNet v1.1 [23] implementation of each BNA", "content_type": "table", "figure_type": "N/A"}, "1707.01922v5-Table2-1.png": {"caption": "Table 2. Working condition comparison between ZDDA and other existing methods. Among all the listed methods, only ZDDA can work under all four conditions", "content_type": "table", "figure_type": "N/A"}, "1707.01922v5-Table8-1.png": {"caption": "Table 8. Validation of ZDDA\u2019s performance (in mean classification accuracy (%)) with different training/testing splits and choices of classes in scene classification. GN stands for GoogleNet [38]. The definition of PRGB-D and the representation of the cell color in each column are the same as those in Table 7", "content_type": "table", "figure_type": "N/A"}, "1707.01922v5-Figure2-1.png": {"caption": "Fig. 2. An overview of the ZDDA training procedure. We use the images from the SUN RGB-D [36] dataset for illustration. ZDDA simulates the target-domain representation using the source-domain data, builds a joint network with the supervision from the source domain, and trains a sensor fusion network. In step 1, we choose to train s1 and fix t, but we can also train t and fix s1 to simulate the target-domain representation. In step 2, t can also be trainable instead of being fixed, but we choose to fix it to make the number of trainable parameters manageable. The details are explained in Sec. 3", "content_type": "figure", "figure_type": "** schematic"}}, "qa": [{"question": "What is the difference between testing domain adaptation and testing sensor fusion?", "answer": "In testing domain adaptation, the source and target CNNs are trained on different domains, and the joint classifier is used to predict the class of the target data. In testing sensor fusion, the source and target CNNs are trained on the same domain, and the joint classifier is used to predict the class of the target data using both the source and target data.", "explanation": "Figure (a) shows the testing procedure for domain adaptation, while Figure (b) shows the testing procedure for sensor fusion.", "reference": "1707.01922v5-Figure3-1.png"}, {"question": "Which method performs better in terms of classification accuracy?", "answer": "ZDDA3", "explanation": "Figure (c) shows the difference in classification accuracy between ZDDA3 and naive fusion. In most cases, the difference is positive, which means that ZDDA3 performs better than naive fusion.", "reference": "1707.01922v5-Figure4-1.png"}, {"question": "What is the role of the task-irrelevant data in ZDDA?", "answer": "The task-irrelevant data is used to simulate the RGB representation using the gray scale image. This allows ZDDA to learn a joint network that can be used to classify digits in both the gray scale and RGB domains.", "explanation": "The figure shows that the task-irrelevant data consists of gray-scale and RGB image pairs. These pairs are used to train a network that can convert gray-scale images to RGB images. This network is then used to classify digits in the RGB domain, even though no RGB training data is available.", "reference": "1707.01922v5-Figure1-1.png"}, {"question": "What is the key difference between ZDDA and UDA/MVL in terms of the available training data?", "answer": "The key difference lies in the availability of target-domain training data. While UDA and MVL methods require T-R training data from the target domain, ZDDA does not. ZDDA only requires T-R training data from a single source domain.", "explanation": "Table 1 clearly shows this distinction in the first row. Both UDA and MVL have a green \"Y\" under the column \"given T-R target-domain training data?\", indicating that they require such data. In contrast, ZDDA has a red \"N\" under the same column, signifying that it does not need target-domain training data. The passage further emphasizes this difference by stating that \"in ZDDA, T-R target-domain training data is unavailable and the only available T-R training data is in one source domain.\"", "reference": "1707.01922v5-Table1-1.png"}, {"question": "If you are performing domain adaptation with ZDDA using AlexNet as the base network architecture and $D_F$ as the target domain, which layers of the network would be considered part of the source CNN and which would be part of the source classifier?", "answer": "In this scenario, the source CNN would consist of the AlexNet architecture up to and including the \"fc7\" layer. The remaining layers of AlexNet would then be used as the source classifier.", "explanation": "Table 1 provides information about the base network architectures (BNA) used in the experiments and specifies the layer that separates the source/target CNN from the source classifier. Looking at the row for AlexNet, we see that \"fc7\" is listed as the dividing layer. This means that for tasks using AlexNet, the source CNN comprises the network up to and including \"fc7\", while the remaining layers form the source classifier.", "reference": "1707.01922v5-Table4-1.png"}, {"question": "Which of the following statements about the training procedure of ZDDA is true?\n\n(a) ZDDA simulates the target-domain representation using the source-domain data. (b) ZDDA builds a joint network with the supervision from the target domain. (c) ZDDA trains a sensor fusion network in step 1. (d) ZDDA trains a sensor fusion network in step 2.", "answer": "(a) ZDDA simulates the target-domain representation using the source-domain data.", "explanation": "The passage states that \"ZDDA simulates the target-domain representation using the source-domain data.\" This is shown in step 1 of the figure, where the target CNN is used to simulate the target-domain representation using the source-domain data.", "reference": "1707.01922v5-Figure2-1.png"}]}, "1901.00398v2": {"paper_id": "1901.00398v2", "all_figures": {"1901.00398v2-Figure2-1.png": {"caption": "Figure 2: Accuracy of human evaluators on individual reviews: H1 - individual votes; H2 - majority votes.", "content_type": "figure", "figure_type": "** plot"}, "1901.00398v2-Figure8-1.png": {"caption": "Figure 8: Screenshot of the instructions presented to Amazon Mechanical Turk workers.", "content_type": "figure", "figure_type": "\"other\""}, "1901.00398v2-Figure9-1.png": {"caption": "Figure 9: Screenshot of the Amazon Mechanical Turk user study interface.", "content_type": "figure", "figure_type": "photograph(s)"}, "1901.00398v2-Table4-1.png": {"caption": "Table 4: Accuracy of deep (LSTM, CNN, CNN & LSTM) and shallow (SVM, RF, NB, XGBoost) meta-adversarial evaluators. The lower the better. Meta-adversarial evaluators do better than humans on individual reviews, with less bias between the two classes. GAN-based generators are considered best by meta-adversarial evaluators.", "content_type": "table", "figure_type": "N/A"}, "1901.00398v2-Figure10-1.png": {"caption": "Figure 10: Text-Overlap Evaluators (BLEU, ROUGE, METEOR and CIDEr) scores for individual generators. The higher the better. The rankings are overall similar, as GAN-based generators are ranked low.", "content_type": "figure", "figure_type": "plot"}, "1901.00398v2-Figure4-1.png": {"caption": "Figure 4: Text-Overlap Evaluators (BLEU and CIDEr) scores for individual generators. The higher the better. The rankings are overall similar, as GAN-based generators are ranked low.", "content_type": "figure", "figure_type": "plot"}, "1901.00398v2-Figure5-1.png": {"caption": "Kendall \u03c4 -b between human and automated evaluators. Human\u2019s ranking is positively correlated to text-overlap evaluators and negatively correlated to adversarial evaluators (\u2217 is p \u2264 0.05).", "content_type": "figure", "figure_type": "plot"}, "1901.00398v2-Figure3-1.png": {"caption": "Accuracy of human (H1, H2) and metaadversarial evaluators (LSTM, SVM) on reviews generated by individual generators. The lower the accuracy, the better the generator.", "content_type": "figure", "figure_type": "plot"}, "1901.00398v2-Table3-1.png": {"caption": "Table 3: Accuracy of deep (LSTM) and shallow (SVM) meta-adversarial evaluators. The lower the better. Meta-adversarial evaluators do better than humans on individual reviews, with less bias between the two classes. GAN-based generators are considered to be the best by meta-adversarial evaluators.", "content_type": "table", "figure_type": "N/A"}, "1901.00398v2-Table9-1.png": {"caption": "Table 9: BLEU results when evaluating the generated reviews using G-train as the reference corpus (a lower score indicates less n-grams in common between the training set G-train and the generated text). GAN models present low similarity with the training set.", "content_type": "table", "figure_type": "N/A"}, "1901.00398v2-Figure6-1.png": {"caption": "Kendall \u03c4 -b correlation coefficients between human evaluators and automated evaluators, tested on the annotated subset of D-test with majority votes as ground-truth (\u2217 denotes p \u2264 0.05).", "content_type": "figure", "figure_type": "plot"}, "1901.00398v2-Figure1-1.png": {"caption": "Figure 1: Overview of the Experiment Procedure.", "content_type": "figure", "figure_type": "schematic"}, "1901.00398v2-Table1-1.png": {"caption": "Table 1: Candidate models for review generation.", "content_type": "table", "figure_type": "N/A"}, "1901.00398v2-Figure12-1.png": {"caption": "Figure 12: Kendall \u03c4 -b correlation coefficients between BLEU G-train and Self-BLEU rankings, and the three evaluation methods - human evaluators H1, H2, discriminative evaluators and word-overlap based evaluators (* denotes p \u2264 0.05). Meta-discriminators have been trained on D-train, D-valid sets and tested on the annotated D-test set with ground-truth test labels.", "content_type": "figure", "figure_type": "plot"}, "1901.00398v2-Figure7-1.png": {"caption": "Figure 7: Self-BLEU scores (the lower the more diverse) and lexical diversity scores (the higher the more diverse) are highly correlated in ranking the generators.", "content_type": "table", "figure_type": "N/A"}, "1901.00398v2-Table7-1.png": {"caption": "Table 7: Kendall tau-b, Spearman and Pearson correlation coefficients between Self-BLEU diversity rankings and the three evaluation methods - human evaluators H1, H2, discriminative evaluators and word-overlap based evaluators (* denotes statistical significant result with p \u2264 0.05). Meta-discriminators have been trained on D-train, D-valid sets and tested on the annotated D-test set with ground-truth test labels.", "content_type": "figure", "figure_type": "plot"}, "1901.00398v2-Table5-1.png": {"caption": "Table 5: Kendall tau-b, Spearman and Pearson correlation coefficients between human evaluators H1, H2, and discriminative evaluators and word-overlap evaluators (* denotes statistical significant result with p \u2264 0.05).", "content_type": "table", "figure_type": "N/A"}, "1901.00398v2-Table8-1.png": {"caption": "Table 8: Kendall tau-b, Spearman and Pearson correlation coefficients between BLEU G-train rankings and the three evaluation methods - human evaluators H1, H2, discriminative evaluators and word-overlap based evaluators (* denotes statistical significant result with p \u2264 0.05). Meta-discriminators have been trained on D-train, D-valid sets and tested on the annotated Dtest set with ground-truth test labels.", "content_type": "figure", "figure_type": "plot"}, "1901.00398v2-Table6-1.png": {"caption": "Table 6: Self-BLEU diversity scores per generator (the lower the more diverse), and lexical diversity scores (the higher the more diverse). There is high correlation between the two metrics with respect to the rankings of the generative text models.", "content_type": "table", "figure_type": "N/A"}, "1901.00398v2-Figure11-1.png": {"caption": "Accuracy of deep (LSTM) and shallow (SVM) meta-discriminators when tested on the annotated subset of D-test, with majority votes as groundtruth. The lower the better.", "content_type": "figure", "figure_type": "plot"}, "1901.00398v2-Table2-1.png": {"caption": "Table 2: Number of generated reviews by each model.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": " Which type of review was more accurately identified by the human evaluators, human-written or machine-generated? ", "answer": "The human evaluators were more accurate at identifying human-written reviews than machine-generated reviews.", "explanation": " The figure shows that the accuracy of the human evaluators was higher for human-written reviews than for machine-generated reviews. For example, the accuracy of H1 for human-written reviews predicted as human-written was 80%, while the accuracy for machine-generated reviews predicted as human-written was only 40%.", "reference": "1901.00398v2-Figure2-1.png"}, {"question": "Which type of generator generally produced reviews that were most easily identified as machine-generated by the meta-adversarial evaluators?", "answer": "MLE SeqGAN and Word LSTM with temperature 1.0.", "explanation": "The table shows the accuracy of meta-adversarial evaluators in identifying machine-generated reviews. Lower accuracy indicates that the reviews are more difficult to distinguish from human-written ones. We can see that MLE SeqGAN and Word LSTM with temperature 1.0 consistently achieve the lowest accuracy across most evaluators, implying that these generators produced reviews that were most similar to human-written ones and thus hardest to detect as machine-generated.", "reference": "1901.00398v2-Table4-1.png"}, {"question": "What is the task that the AMT workers are being asked to do?", "answer": "The AMT workers are being asked to decide whether each of twenty one paragraphs extracted from product reviews is real (written by a person) or fake (written by a computer algorithm).", "explanation": "The instructions in Figure \\ref{user_instructions} state that the workers will be presented with twenty one paragraphs extracted from product reviews, and that they should try to decide whether each review is real or fake.", "reference": "1901.00398v2-Figure8-1.png"}]}, "1805.08751v2": {"paper_id": "1805.08751v2", "all_figures": {"1805.08751v2-Figure3-1.png": {"caption": "Relationships of Articles, Creators and Subjects.", "content_type": "figure", "figure_type": "schematic"}, "1805.08751v2-Figure4-1.png": {"caption": "Gated Diffusive Unit (GDU).", "content_type": "figure", "figure_type": "schematic"}, "1805.08751v2-Figure5-1.png": {"caption": "The Architecture of Framework FAKEDETECTOR.", "content_type": "figure", "figure_type": "Schematic"}, "1805.08751v2-TableI-1.png": {"caption": "TABLE I PROPERTIES OF THE HETEROGENEOUS NETWORKS", "content_type": "table", "figure_type": "table"}, "1805.08751v2-Figure7-1.png": {"caption": "Multi-Class Credibility Inference of News Articles 7(a)-7(d), Creators 7(e)-7(h) and Subjects 7(i)-7(l).", "content_type": "figure", "figure_type": "plot"}, "1805.08751v2-Figure6-1.png": {"caption": "Bi-Class Credibility Inference of News Articles 6(a)-6(d), Creators 6(e)-6(h) and Subjects 6(i)-6(l).", "content_type": "figure", "figure_type": "plot"}, "1805.08751v2-Figure2-1.png": {"caption": "Hybrid Feature Learning Unit (HFLU).", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "What is the role of the GDU and HFLU modules in the FAKEDETECTOR framework?", "answer": "The GDU (Gated Dilated Unit) modules are responsible for extracting features from the input data, while the HFLU (Hybrid Feature Learning Unit) modules are responsible for fusing the features extracted by the GDU modules.", "explanation": "The figure shows that the GDU and HFLU modules are used in both the encoder and decoder parts of the FAKEDETECTOR framework. The GDU modules take the input data and extract features, which are then passed to the HFLU modules. The HFLU modules then fuse the features from the different GDU modules and produce the final output.", "reference": "1805.08751v2-Figure5-1.png"}]}, "1707.06320v2": {"paper_id": "1707.06320v2", "all_figures": {"1707.06320v2-Table1-1.png": {"caption": "Table 1: Retrieval (higher is better) results on COCO, plus median rank (MEDR) and mean rank (MR) (lower is better). Note that while this work underwent review, better methods have been published, most notably VSE++ (Faghri et al., 2017).", "content_type": "table", "figure_type": "N/A"}, "1707.06320v2-Table2-1.png": {"caption": "Table 2: Accuracy results on sentence classification and entailment tasks.", "content_type": "table", "figure_type": "N/A"}, "1707.06320v2-Table3-1.png": {"caption": "Table 3: Thorough investigation of the contribution of grounding, ensuring equal number of components and identical architectures, on the variety of sentence-level semantic benchmark tasks. STb=SkipThought-like model with bidirectional LSTM+max. 2\u00d7STb-1024=ensemble of 2 different STb models with different initializations. GroundSent is STb-1024+Cap2Cap/Img/Both. We find that performance improvements are sometimes due to having more parameters, but in most cases due to grounding.", "content_type": "table", "figure_type": "N/A"}, "1707.06320v2-Table4-1.png": {"caption": "Table 4: Mean and variance of dataset concreteness, over all words in the datasets.", "content_type": "table", "figure_type": "N/A"}, "1707.06320v2-Table5-1.png": {"caption": "Table 5: Spearman \u03c1s correlation on four standard semantic similarity evaluation benchmarks.", "content_type": "table", "figure_type": "N/A"}, "1707.06320v2-Figure1-1.png": {"caption": "Model architecture: predicting either an image (Cap2Img), an alternative caption (Cap2Cap), or both at the same time (Cap2Both).", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "Which model performs the best for caption retrieval in terms of R@1 and MEDR? Briefly explain why the performance might be better than other models.", "answer": "Cap2Img performs the best for caption retrieval in terms of both R@1 (27.1) and MEDR (4.0). This suggests that the model is more successful at retrieving the most relevant caption for a given image compared to other models.", "explanation": "The table shows the performance of different models on the COCO5K caption retrieval task. R@1 measures the percentage of times the correct caption is ranked first, while MEDR indicates the median rank of the correct caption across all searches. Cap2Img has the highest R@1 and lowest MEDR, suggesting it excels at finding the most relevant caption. This might be because Cap2Img focuses solely on predicting image features from captions, allowing it to specialize in this task, while Cap2Both, which considers both image and caption prediction, might face optimization challenges due to interference between the two signals.", "reference": "1707.06320v2-Table1-1.png"}, {"question": "Which type of grounding appears to be most beneficial for the MRPC task, and how does its performance compare to the baseline model (ST-LN)?", "answer": "GroundSent-Cap appears to be most beneficial for the MRPC task, achieving an accuracy of 72.9/82.2 compared to the baseline model ST-LN's 69.6/81.2.", "explanation": "Table 1 presents the accuracy results for different models on various semantic classification and entailment tasks. The MRPC task results are shown in the fifth column. Comparing the scores of different models on this task, we can see that GroundSent-Cap outperforms the others, including the baseline model ST-LN, by a small margin. This suggests that grounding with captions is particularly helpful for the MRPC task.", "reference": "1707.06320v2-Table2-1.png"}, {"question": "Which model performs best on the SNLI dataset, and how much does grounding contribute to its performance compared to the baseline STb-1024 model?", "answer": "The GroundSent-Both model performs best on the SNLI dataset, achieving an accuracy of 72.0%. Grounding contributes to an improvement of 4.7% compared to the baseline STb-1024 model, which achieves 67.3%.", "explanation": "The table displays the performance of different models on various datasets, including SNLI. By comparing the accuracy of the GroundSent-Both model (with grounding) to the STb-1024 model (without grounding), we can determine the contribution of grounding to the performance improvement.", "reference": "1707.06320v2-Table3-1.png"}, {"question": "How do the word embeddings learned by the Cap2Img model compare to the original GloVe embeddings in terms of semantic similarity?", "answer": "The word embeddings learned by the Cap2Img model outperform the original GloVe embeddings in terms of semantic similarity.", "explanation": "Table 1 shows the Spearman correlation scores for different word embedding models on four standard semantic similarity benchmarks. A higher correlation score indicates better performance in capturing semantic similarity. Comparing the scores of Cap2Img and GloVe across all four benchmarks, we see that Cap2Img consistently achieves higher scores. This suggests that the grounded word projections learned by the Cap2Img model lead to word embeddings that better capture semantic relationships compared to the original GloVe embeddings.", "reference": "1707.06320v2-Table5-1.png"}, {"question": "What is the role of the \"max\" function in the model architecture?", "answer": "The \"max\" function is used to select the most probable word at each time step in the decoding process.", "explanation": "The figure shows that the \"max\" function is applied to the output of the LSTM at each time step. This selects the word with the highest probability, which is then used as input to the next time step.", "reference": "1707.06320v2-Figure1-1.png"}]}, "1707.08608v3": {"paper_id": "1707.08608v3", "all_figures": {"1707.08608v3-Table11-1.png": {"caption": "Table 11: Comparison of runtime for difference inference procedures in the noise-free constraint setting: Viterbi, A*(He et al. 2017) and GBI. For SRL-100 refer Table 1 and SRL-NW is a model trained on NW genre.", "content_type": "table", "figure_type": "N/A"}, "1707.08608v3-Table10-1.png": {"caption": "Table 10: Comparison of different inference procedures: Viterbi, A*(He et al. 2017) and GBI with noisy and noise-free constraints. Note that the (+/-) F1 are reported w.r.t Viterbi decoding on the same column.", "content_type": "table", "figure_type": "N/A"}, "1707.08608v3-Table5-1.png": {"caption": "Table 5: Evaluation of syntactic parser and SRL system on out-of-domain data. F1 scores are reported on the failure set. SRL model was trained on NW and the syntactic parser was trained on WSJ Section on OntoNote v5.0. Except PT, which is new and old Testament, all failure rate on out-domain data is higher than that of in-domain (11.9% for parsing and 18.1% for SRL) as suspected. The table shows that GBI can be successfully applied to resolve performance degradation on out-of-domain data.", "content_type": "table", "figure_type": "N/A"}, "1707.08608v3-Table9-1.png": {"caption": "A sequence transduction example for which enforcing the constraints improves accuracy. Red indicates errors.", "content_type": "table", "figure_type": "table"}, "1707.08608v3-Table7-1.png": {"caption": "A semantic role labeling example for which the method successfully enforces syntactic constraints. The initial output has an inconsistent span for token \u201dreally like this\u201d. Enforcing the constraint not only corrects the number of agreeing spans, but also changes the semantic role \u201dB-ARG2\u201d to \u201dB-ARGM-ADV\u201d and \u201dI-ARG2\u201d to \u201dB-ARG2\u201d..", "content_type": "table", "figure_type": "table"}, "1707.08608v3-Table8-1.png": {"caption": "A shift-reduce example for which the method successfully enforces constraints. The initial output has only nine shifts, but there are ten tokens in the input. Enforcing the constraint not only corrects the number of shifts to ten, but changes the implied tree structure to the correct tree.", "content_type": "table", "figure_type": "table"}, "1707.08608v3-Table6-1.png": {"caption": "A shift-reduce example for which the method successfully enforces constraints. The initial unconstrained decoder prematurely reduces \u201cSo it\u201d into a phrase, missing the contracted verb \u201cis.\u201d Errors then propagate through the sequence culminating in the final token missing from the tree (a constraint violation). The constrained decoder is only able to deal with this at the end of the sequence, while our method is able to harness the constraint to correct the early errors.", "content_type": "table", "figure_type": "table"}, "1707.08608v3-Table4-1.png": {"caption": "Table 4: Evaluation of GBI on simpler, low-resource seq2seq networks. Here, we also evaluate whether GBI can be used in combination with different inference techniques: greedy and beam search of various widths.", "content_type": "table", "figure_type": "N/A"}, "1707.08608v3-Table3-1.png": {"caption": "Table 3: Evaluation of GBI on syntactic parsing using GNMT seq2seq. Note that GBI without beam search performs higher than BS-9 in Table 2.", "content_type": "table", "figure_type": "N/A"}, "1707.08608v3-Table1-1.png": {"caption": "Table 1: Comparison of the GBI vs. A*inference procedure for SRL. We report the avg. disagreement rate, F1-scores and exact match for the failure set (columns 5-10) and F1-score for the whole test set (last 2 columns). Also, we report performances on a wide range of reference models SRL-X, where X denotes % of dataset used for training. We employ Viterbi decoding as a base inference strategy (before) and apply GBI (after) in combination with Viterbi.", "content_type": "table", "figure_type": "N/A"}, "1707.08608v3-Table2-1.png": {"caption": "Table 2: Parsing Networks with various performances (BS-9 means beam size 9). Net1,2 are GNMT seq2seq models whereas Net3-5 are lower-resource and simpler seq2seq models, providing a wide range of model performances on which to test GBI.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "Which genre in the SRL-NW network has the lowest failure rate and how does its inference time compare to other genres within the same network?", "answer": "The PT genre within the SRL-NW network has the lowest failure rate at 10.01%. Its inference time is also the lowest across all genres in the SRL-NW network for all three inference procedures (Viterbi, GBI, and A*).", "explanation": "The table shows the failure rate and inference time for each genre in both the SRL-100 and SRL-NW networks. By comparing the failure rate values within the SRL-NW network, we can identify PT as having the lowest rate. Additionally, by comparing the inference times for PT to other genres in the same network, we can see that it consistently requires the least amount of time for all three procedures.", "reference": "1707.08608v3-Table11-1.png"}, {"question": "Which genre shows the **largest absolute improvement** in F1 score on the failure set after applying GBI for **both** syntactic parsing and SRL?", "answer": "Pivot Corpus (PT) shows the largest absolute improvement in F1 score on the failure set after applying GBI for both syntactic parsing and SRL.", "explanation": "Looking at the \"F1 on failure set\" columns in Table 1, we can compare the \"before\" and \"after\" scores for each genre and task. \n\nFor syntactic parsing, PT improves by 4.4 points (75.8 - 71.4), which is the highest increase among all genres. \n\nSimilarly, for SRL, PT again shows the biggest improvement, with a 16.5 point increase (63.69 - 47.19) after applying GBI. \n\nTherefore, PT demonstrates the largest absolute improvement in both tasks based on the F1 scores on the failure set.", "reference": "1707.08608v3-Table5-1.png"}, {"question": "How did the accuracy of the model change as the iterations progressed?", "answer": "The accuracy of the model increased from 66.7% to 100% as the iterations progressed.", "explanation": "The table shows that the accuracy of the model increased from 66.7% to 100% as the iterations progressed.", "reference": "1707.08608v3-Table9-1.png"}, {"question": "What is the effect of enforcing syntactic constraints on the semantic role labeling output?", "answer": "Enforcing syntactic constraints can correct the number of agreeing spans, and also change the semantic roles assigned to tokens.", "explanation": "The figure shows that the initial output has an inconsistent span for token \u201dreally like this\u201d. Enforcing the constraint not only corrects the number of agreeing spans, but also changes the semantic role \u201dB-ARG2\u201d to \u201dB-ARGM-ADV\u201d and \u201dI-ARG2\u201d to \u201dB-ARG2\u201d.", "reference": "1707.08608v3-Table7-1.png"}, {"question": "What is the relationship between the number of shifts and the accuracy of the output?", "answer": "The accuracy of the output increases as the number of shifts increases.", "explanation": "The figure shows that the accuracy of the output is 33.3% when there are 9 shifts, and 100% when there are 10 shifts.", "reference": "1707.08608v3-Table8-1.png"}, {"question": "Which inference method consistently leads to the highest F1 score on the failure set across all three networks (Net3, Net4, and Net5)?", "answer": "Beam search with a width of 9 consistently leads to the highest F1 score on the failure set across all three networks.", "explanation": "The table shows the F1 scores on the failure set for different inference methods and network architectures. By comparing the F1 scores within each network, we can see that Beam 9 consistently achieves the highest score, indicating better performance in identifying and correcting failures compared to other methods like Greedy or Beam search with smaller widths.", "reference": "1707.08608v3-Table4-1.png"}, {"question": "How does GBI compare to A* in terms of reducing disagreement rate on the SRL-100 network's failure set?", "answer": "GBI is more effective than A* in reducing the disagreement rate on the SRL-100 network's failure set. After applying GBI, the average disagreement rate drops to 24.92%, while A* only reduces it to 33.91%. This represents an 19.93% greater reduction in disagreement rate when using GBI compared to A*.", "explanation": "Table 1 provides the average disagreement rate on the failure set for both GBI and A* across different SRL networks. Looking specifically at the SRL-100 network, we can see that the \"after\" values under the \"Average Disagreement\" column show a larger decrease for GBI (44.85% to 24.92%) compared to A* (44.85% to 33.91%). This indicates that GBI is more successful in reducing the number of predicted spans that disagree with the true syntactic parse.", "reference": "1707.08608v3-Table1-1.png"}]}, "1809.00263v5": {"paper_id": "1809.00263v5", "all_figures": {"1809.00263v5-Figure1-1.png": {"caption": "Figure 1: Difference between video interpolation and video infilling. Camera 1 captures frames 1 to 19. Video interpolation aims to generate 5 frames between frame 7 and 8. A low frame rate camera 2 only captures frame 1, 7, 13 and 19. Video infilling focuses on generating a plausible intermediate dynamic sequence for camera 2 (a plausible sequence can be different from the frames 8 to 12).", "content_type": "figure", "figure_type": "schematic"}, "1809.00263v5-Figure7-1.png": {"caption": "Average PSNR and SSIM at each step in test sets.", "content_type": "figure", "figure_type": "plot"}, "1809.00263v5-Figure9-1.png": {"caption": "SDVI generates higher variances coincident to the \u201dwall bouncing\u201d event, indicated by the two dash lines(e.g. first sequence: red lines mark the bounces of the digit 6 and blue ones mark the bounces of 7).", "content_type": "figure", "figure_type": "plot"}, "1809.00263v5-Table3-1.png": {"caption": "Hyper parameters for training on different datasets", "content_type": "table", "figure_type": "table"}, "1809.00263v5-Table2-1.png": {"caption": "The dimensionalities of different features", "content_type": "table", "figure_type": "table"}, "1809.00263v5-Figure2-1.png": {"caption": "Figure 2: The difference of the randomness between shortterm and long-term intervals: The camera in scenario 1 can capture every other frame and the camera in scenario 2 captures 1 frame for every 4 frames. The red and the green trajectories indicate two possible motions in each scenario.", "content_type": "figure", "figure_type": "schematic"}, "1809.00263v5-Table1-1.png": {"caption": "Table 1: Metrics averaging over all 7 intermediate frames. We report the scores of the best-sampled sequences for SDVI.", "content_type": "table", "figure_type": "N/A"}, "1809.00263v5-Figure10-1.png": {"caption": "The arm in the best sequence follows the same movements in ground truth: first upward left then downward left. In another sampled sequence, the arm firstly goes straight up and then straight left, finally downward left.", "content_type": "figure", "figure_type": "photograph(s)"}, "1809.00263v5-Figure3-1.png": {"caption": "Training of SDVI: All Encoder (green) share the same weights. The blue and the yellow network are Extractor and Decoder. Reference module creates dynamic constraint h\u0302t at each step. At step t, Inference module takes Xt\u22121 and h\u0302t, while Posterior module takes Xt. Inference module and Posterior module will produce different zt and therefore different output frames X\u0303infr", "content_type": "figure", "figure_type": "schematic"}, "1809.00263v5-Figure16-1.png": {"caption": "A more complicated UCF101 example: a real basketball video sequence involving multiple objects. Our method can model the dynamic correctly and generate better moving objects than SuperSloMo and SepConv.", "content_type": "figure", "figure_type": "photograph(s)"}, "1809.00263v5-Figure12-1.png": {"caption": "Our best-sampled sequence keeps the arm straight. In a randomly sampled sequence, the forearm bends first then stretches straight in the end.", "content_type": "figure", "figure_type": "photograph(s)"}, "1809.00263v5-Figure13-1.png": {"caption": "The sliding tendency of SepConv will cause motion errors and high LMS.", "content_type": "figure", "figure_type": "photograph(s)"}, "1809.00263v5-Figure11-1.png": {"caption": "Figure 11: Best view in color. See Appendix E in the supplemental material for more comparisons on UCF101.", "content_type": "figure", "figure_type": "** photograph(s)"}, "1809.00263v5-Figure4-1.png": {"caption": "Figure 4: A two layers RBConvLSTM: The initial cell states of the first layer are assigned as Cstart and Cend. hS and hT are taken as inputs. Combined with the residuals (red arrows), each layer\u2019s outputs (yellow arrows) would go through a convolution module and become the inputs (green arrows) to the next layer.", "content_type": "figure", "figure_type": "schematic"}, "1809.00263v5-Figure5-1.png": {"caption": "Inference of SDVI: Without ground truth frame Xt\u22121, the generated frame X\u0303t\u22121 serves as the input to Inference module on step t.", "content_type": "figure", "figure_type": "** Schematic"}, "1809.00263v5-Figure6-1.png": {"caption": "The sampled vector (in the middle) is applied on all locations.", "content_type": "figure", "figure_type": "schematic"}, "1809.00263v5-Figure15-1.png": {"caption": "a snapshot of the gifs in the \u201cvideo result.html\u201d", "content_type": "figure", "figure_type": "photograph(s)"}, "1809.00263v5-Figure14-1.png": {"caption": "shows the full comparisons for he wave action.", "content_type": "figure", "figure_type": "photograph(s)"}}, "qa": [{"question": "What is the value of the learning rate \u03b1 for the BAIR dataset?", "answer": "0.0002", "explanation": "The table shows the values of the hyperparameters for training on different datasets. The value of \u03b1 for the BAIR dataset is listed as 0.0002.", "reference": "1809.00263v5-Table3-1.png"}, {"question": "Which feature has the highest dimensionality in the first two dimensions?", "answer": "All features have the same dimensionality in the first two dimensions.", "explanation": "The table shows that all features have a dimensionality of 4 in both the first and second dimensions.", "reference": "1809.00263v5-Table2-1.png"}, {"question": "What is the relationship between the length of the interval and the uncertainty in the generated frames?", "answer": "The uncertainty in the generated frames increases with the length of the interval.", "explanation": "The figure shows two scenarios: one with a short-term interval and one with a long-term interval. In the short-term interval scenario, the camera captures every other frame, resulting in less uncertainty in the generated frames. In the long-term interval scenario, the camera captures 1 frame for every 4 frames, resulting in more uncertainty in the generated frames.", "reference": "1809.00263v5-Figure2-1.png"}, {"question": "Explain the likely reason why the \"SDVI loss term 1&3\" model performs worse than the full SDVI model in terms of PSNR and SSIM across all datasets.", "answer": "The \"SDVI loss term 1&3\" model only uses the pixel reconstruction loss and the inclusive KL divergence loss, while the full SDVI model additionally incorporates the pixel prediction loss and the exclusive KL divergence loss. According to the passage, the exclusive KL divergence term encourages the inference distribution to be more accurate, while the pixel prediction loss further improves video quality during inference. Therefore, the absence of these terms in the \"SDVI loss term 1&3\" model likely explains its inferior performance compared to the full SDVI model.", "explanation": "Table 1 shows that the full SDVI model consistently achieves higher PSNR and SSIM values than the \"SDVI loss term 1\\&3\" model across all datasets. This observation suggests that the additional loss terms in the full model contribute to improved reconstruction quality and video quality during inference. The passage provides the theoretical justification for including these additional terms, specifically highlighting their roles in promoting accuracy and diversity in the inference distribution and enhancing video quality. By comparing the performance of the two models and referencing the detailed explanation of the loss function in the passage, we can understand how the different loss terms contribute to the overall performance of the SDVI model.", "reference": "1809.00263v5-Table1-1.png"}, {"question": "What is the difference between the Inference module and the Posterior module?", "answer": "The Inference module takes the previous frame (Xt-1) and the dynamic constraint (h\u0302t) as input, while the Posterior module takes the current frame (Xt) as input. This means that the Inference module is trying to predict the next frame based on the previous frame and the dynamic constraint, while the Posterior module is trying to reconstruct the current frame.", "explanation": "The figure shows that the Inference module and the Posterior module have different inputs. The Inference module takes Xt-1 and h\u0302t as input, while the Posterior module takes Xt as input.", "reference": "1809.00263v5-Figure3-1.png"}, {"question": "Which method generates the best moving objects?", "answer": "SDVI", "explanation": "The SDVI method is able to model the dynamic of the basketball video sequence correctly and generate better moving objects than SuperSloMo and SepConv. This can be seen in the figure, where the SDVI method is able to generate more realistic and accurate moving objects than the other two methods.", "reference": "1809.00263v5-Figure16-1.png"}, {"question": "What is the effect of the sliding tendency of SepConv on the generated images?", "answer": "The sliding tendency of SepConv will cause motion errors and high LMS.", "explanation": "The figure shows the ground truth of the missing sequence and the generated images by different methods. The generated images by SepConv have a sliding tendency, which causes the person in the images to appear to be moving faster than they actually are. This is evident in the high LMS values for SepConv.", "reference": "1809.00263v5-Figure13-1.png"}, {"question": "What is the role of the residual connections in the RBConvLSTM network?", "answer": "The residual connections add the output of the previous layer to the input of the next layer. This helps to improve the flow of information through the network and can help to prevent vanishing gradients.", "explanation": "The figure shows that the outputs of each layer (yellow arrows) are added to the inputs of the next layer (green arrows). This is indicated by the red arrows, which represent the residual connections.", "reference": "1809.00263v5-Figure4-1.png"}, {"question": "What is the relationship between the feature maps of $\\sigma$ and $\\mu$ and the sampled vector?", "answer": "The sampled vector is element-wise multiplied by the feature map of $\\sigma$ and added to the feature map of $\\mu$.", "explanation": "The figure shows the feature maps of $\\sigma$ and $\\mu$ on the left and right, respectively. The sampled vector is shown in the middle. The \"$\\times$\" and \"$+$\" symbols indicate that the sampled vector is multiplied and added to the feature maps, respectively.", "reference": "1809.00263v5-Figure6-1.png"}]}, "1708.00160v2": {"paper_id": "1708.00160v2", "all_figures": {"1708.00160v2-Figure5-1.png": {"caption": "A sample decision tree and the list of all extracted feature conjunctions based on Fernandes et al.\u2019s (2012) approach.", "content_type": "figure", "figure_type": "schematic"}, "1708.00160v2-Table3-1.png": {"caption": "Evaluating the informativeness of DDPMine, MPP and EPM patterns on standard datasets.", "content_type": "table", "figure_type": "table"}, "1708.00160v2-Figure4-1.png": {"caption": "Conditional FP-Tree for the p = {head=F, ant=NAM} pattern.", "content_type": "figure", "figure_type": "schematic"}, "1708.00160v2-Figure1-1.png": {"caption": "Left to right: (partial) constructed FP-Tree after adding each of the three given samples. The right-most tree is the final FP-Tree that represents all input samples.", "content_type": "figure", "figure_type": "schematic"}, "1708.00160v2-Figure2-1.png": {"caption": "FP-Tree with corresponding support values of the nodes.", "content_type": "figure", "figure_type": "schematic"}, "1708.00160v2-Figure3-1.png": {"caption": "Conditional FP-Tree for the p = {head=F} pattern.", "content_type": "figure", "figure_type": "schematic"}, "1708.00160v2-Table4-1.png": {"caption": "Table 4: Comparisons on the CoNLL test set. The F1 gains that are statistically significant: (1) \u201c+EPM\u201d compared to \u201ctoppairs\u201d, \u201cranking\u201d and \u201cJIM\u201d, (2) \u201c+EPM\u201d compared to \u201creinforce\u201d based on MUC, B3 and LEA, (3) \u201csingle\u201d compared to \u201c+EPM\u201d based on MUC and B3, and (4) \u201censemble\u201d compared to other systems. Significance is measured based on the approximate randomization test (p < 0.05) (Noreen, 1989).", "content_type": "table", "figure_type": "N/A"}, "1708.00160v2-Table5-1.png": {"caption": "Table 5: Impact of different EPM feature groups on the CoNLL development set.", "content_type": "table", "figure_type": "N/A"}, "1708.00160v2-Table1-1.png": {"caption": "Table 1: Impact of linguistic features on deep-coref models on the CoNLL development set.", "content_type": "table", "figure_type": "N/A"}, "1708.00160v2-Table2-1.png": {"caption": "Out-of-domain evaluation of deep-coref models on the WikiCoref dataset.", "content_type": "table", "figure_type": "table"}, "1708.00160v2-Table7-1.png": {"caption": "Table 7: In-domain and out-of-domain evaluations for the pt and wb genres of the CoNLL test set. The highest scores are boldfaced.", "content_type": "table", "figure_type": "N/A"}, "1708.00160v2-Table6-1.png": {"caption": "Table 6: Out-of-domain evaluation on the WikiCoref dataset. The highest F1 scores are boldfaced.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "What is the probability of finding the pattern {head=F, ant=NAM} in the data?", "answer": "1", "explanation": "The figure shows the conditional FP-Tree for the pattern {head=F, ant=NAM}. The numbers in parentheses next to each node represent the support of the itemset represented by the path from the root to that node. The support of the pattern {head=F, ant=NAM} is 1.0, which means that the pattern appears in all of the transactions in the data.", "reference": "1708.00160v2-Figure4-1.png"}, {"question": "What is the support value of the node \"ana=NAM\"?", "answer": "2", "explanation": "The support value of a node is the number of transactions that contain the itemset represented by the node. In this case, the node \"ana=NAM\" has a support value of 2, which means that there are 2 transactions that contain the itemset \"ana=NAM\".", "reference": "1708.00160v2-Figure2-1.png"}, {"question": "Which coreference model performs best on the CoNLL test set according to the F$_1$ score? Is this performance statistically significant compared to all other models in the table?", "answer": "The \"ensemble\" model of e2ef achieves the highest F$_1$ score of 68.83 on the CoNLL test set. Yes, this performance is statistically significant compared to all other models listed in the table, as indicated by the caption and footnote referencing the approximate randomization test.", "explanation": "The table presents the performance of different coreference models on the CoNLL test set using various metrics, including F$_1$ score. By looking at the \"CoNLL\" column and comparing the F$_1$ values, we can identify the \"ensemble\" model of e2e-coref as having the highest score. The caption further clarifies which performance differences are statistically significant, confirming that the \"ensemble\" model's superior performance is statistically meaningful.", "reference": "1708.00160v2-Table4-1.png"}, {"question": "Which deep-coref model performed best on the WikiCoref dataset, according to the table?", "answer": "The CoNLL model performed best on the WikiCoref dataset, with an F1 score of 53.40 when using the +linguistic evaluation metric.", "explanation": "The table shows the performance of several deep-coref models on the WikiCoref dataset, measured using three different evaluation metrics: ranking, top-pairs, and +linguistic. The CoNLL model achieved the highest F1 score for all three metrics.", "reference": "1708.00160v2-Table2-1.png"}]}, "1809.00458v1": {"paper_id": "1809.00458v1", "all_figures": {"1809.00458v1-Figure4-1.png": {"caption": "The GB-KMV sketch of dataset in Example 1", "content_type": "figure", "figure_type": "table"}, "1809.00458v1-Figure3-1.png": {"caption": "The G-KMV sketch of the dataset in Example 1 with hash value threshold \u03c4 = 0.5", "content_type": "figure", "figure_type": "table"}, "1809.00458v1-Figure5-1.png": {"caption": "Effect of Buffer Size Approximate Algorithms. In the experiments, the approximate algorithms evaluated are as follows.", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-Figure15-1.png": {"caption": "Accuracy versus Similarity threshold", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-Figure14-1.png": {"caption": "The distribution of Accuracy", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-Figure16-1.png": {"caption": "EleFreq z-value varying from 0.4 to 1.2 with recSize z-value 1.0; recSize z-value varying from 0.8 to 1.4 with eleFreq z-value 0.8", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-TableI-1.png": {"caption": "TABLE I. THE SUMMARY OF NOTATIONS", "content_type": "table", "figure_type": "table"}, "1809.00458v1-TableIII-1.png": {"caption": "TABLE III. THE SPACE USAGE(%)", "content_type": "table", "figure_type": "table"}, "1809.00458v1-Figure12-1.png": {"caption": "Accuracy versus Space on WEBSPAM", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-Figure13-1.png": {"caption": "Accuracy versus Space on WDC", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-Figure11-1.png": {"caption": "Accuracy versus Space on REUTERS", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-Figure1-1.png": {"caption": "A four-record dataset and a query Q; C(Q,Xi) is the containment similarity of Q in Xi", "content_type": "figure", "figure_type": "table"}, "1809.00458v1-Figure8-1.png": {"caption": "Accuracy versus Space on DELIC", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-Figure7-1.png": {"caption": "Accuracy versus Space on COD", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-Figure9-1.png": {"caption": "Accuracy versus Space on ENRON", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-Figure10-1.png": {"caption": "Accuracy versus Space on NETFLIX", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-TableII-1.png": {"caption": "TABLE II. CHARACTERISTICS OF DATASETS", "content_type": "table", "figure_type": "table"}, "1809.00458v1-Figure2-1.png": {"caption": "The KMV sketch of the dataset in Example 1, each signature consists of element-hash value pairs. ki is the signature size of Xi", "content_type": "figure", "figure_type": "table"}, "1809.00458v1-Figure19-1.png": {"caption": "Supplementary experiments", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-Figure18-1.png": {"caption": "Sketch Construction Time", "content_type": "figure", "figure_type": "plot"}, "1809.00458v1-Figure17-1.png": {"caption": "Time versus Accuracy", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which dataset shows a higher variance in F1 score with increasing buffer size?", "answer": "ENRON", "explanation": "The plot for ENRON shows a larger change in F1 score as the buffer size increases, indicating higher variance. This can be seen by comparing the slopes of the lines connecting the data points in the two plots.", "reference": "1809.00458v1-Figure5-1.png"}, {"question": "Which algorithm performs best on the ENRON dataset?", "answer": "GB-KMV", "explanation": "The figure shows the F1 score for different algorithms on different datasets. The GB-KMV algorithm has the highest F1 score on the ENRON dataset.", "reference": "1809.00458v1-Figure15-1.png"}, {"question": "Which of the two algorithms (GB-KMV or LSH-E) is the fastest on average across all datasets?", "answer": "LSH-E", "explanation": "The figure shows the time taken by each algorithm for different F-1 scores. The LSH-E line is consistently below the other two lines, indicating that it is the fastest on average.", "reference": "1809.00458v1-Figure14-1.png"}, {"question": "Which method performs better, GB-KMV or LSH-E, and how does the performance change with different values of eleFreq and recSize?", "answer": "GB-KMV generally performs better than LSH-E, as indicated by the higher F1 scores across the range of eleFreq and recSize values. For both methods, the F1 score tends to decrease as recSize increases, while the impact of eleFreq varies depending on the method.", "explanation": "The figure shows the F1 scores for GB-KMV and LSH-E at different values of eleFreq and recSize. The F1 score is a measure of performance that combines precision and recall. A higher F1 score indicates better performance.", "reference": "1809.00458v1-Figure16-1.png"}, {"question": "What is the difference between the Jaccard similarity and the containment similarity?", "answer": "The Jaccard similarity measures the overlap between two sets, while the containment similarity measures how much one set is contained within another set.", "explanation": "The table defines the Jaccard similarity as J(Q, X) = |Q \u2229 X| / |Q \u222a X|, which measures the ratio of the number of elements in the intersection of Q and X to the number of elements in the union of Q and X. The containment similarity is defined as C(Q, X) = |Q \u2229 X| / |Q|, which measures the ratio of the number of elements in the intersection of Q and X to the number of elements in Q.", "reference": "1809.00458v1-TableI-1.png"}, {"question": "Which dataset requires the most storage space when using the LSH-E method?", "answer": "REUTERS", "explanation": "The table shows the space usage (%) for each dataset and method. For the LSH-E method, the REUTERS dataset has the highest space usage of 329%.", "reference": "1809.00458v1-TableIII-1.png"}, {"question": "Which algorithm performs better in terms of F1 score and precision when the space used is 5%?", "answer": "GB-KMV performs better in terms of F1 score and precision when the space used is 5%.", "explanation": "The plot on the left shows the F1 score for both algorithms, and the plot on the right shows the precision for both algorithms. At 5% space used, the GB-KMV line is higher than the LSH-E line in both plots, indicating that GB-KMV performs better in terms of both F1 score and precision.", "reference": "1809.00458v1-Figure12-1.png"}, {"question": "Which method has the highest F-1 score when space used is 10%?", "answer": "GB-KMV", "explanation": "The figure shows the F-1 score for both methods at 5% and 10% space used. At 10% space used, the F-1 score for GB-KMV is slightly higher than that of LSH-E.", "reference": "1809.00458v1-Figure13-1.png"}, {"question": "Which dataset has the highest average record length?", "answer": "CaOpenData", "explanation": "The table shows the average record length for each dataset. The highest average record length is 6284, which is for the CaOpenData dataset.", "reference": "1809.00458v1-TableII-1.png"}, {"question": "What is the relationship between the element-hash value pairs and the signature size?", "answer": "The element-hash value pairs are the elements of the signature, and the signature size is the number of element-hash value pairs in the signature.", "explanation": "The table shows that each signature consists of a set of element-hash value pairs. The number of element-hash value pairs in each signature is given by the corresponding value in the  column.", "reference": "1809.00458v1-Figure2-1.png"}, {"question": "How does the running time of GB-KM vary with the F-1 score?", "answer": "The running time of GB-KM increases as the F-1 score increases.", "explanation": "In Figure (a), the GB-KM curve shows an upward trend as the F-1 score increases. This indicates that as the accuracy of the algorithm increases, the running time also increases.", "reference": "1809.00458v1-Figure19-1.png"}, {"question": "Which method has a lower running time for all datasets - GB-KMV or LSH-E?", "answer": "GB-KMV", "explanation": "The figure shows the running time of two methods, GB-KMV and LSH-E, for different datasets. The bars for GB-KMV are consistently lower than the bars for LSH-E, indicating that GB-KMV has a lower running time for all datasets.", "reference": "1809.00458v1-Figure18-1.png"}, {"question": "What is the containment similarity of Q in X1?", "answer": "0.67", "explanation": "The containment similarity of Q in X1 is shown in the table under the column C'(Q, Xi).", "reference": "1809.00458v1-Figure1-1.png"}, {"question": "Which method is more efficient at utilizing space while maintaining high accuracy?", "answer": "GB-KMV is more efficient at utilizing space while maintaining high accuracy.", "explanation": "The plot on the left shows that GB-KMV achieves higher accuracy than LSH-E while using less space.", "reference": "1809.00458v1-Figure7-1.png"}, {"question": "Which algorithm performs better in terms of F1 Score and Precision on ENRON?", "answer": "GB-KMV performs better than LSH-E in terms of F1 Score and Precision.", "explanation": "The figure shows that the F1 Score and Precision of GB-KMV are consistently higher than those of LSH-E across different SpaceUsed values.", "reference": "1809.00458v1-Figure9-1.png"}]}, "1708.01425v4": {"paper_id": "1708.01425v4", "all_figures": {"1708.01425v4-Figure2-1.png": {"caption": "Overview of the methodology of reconstructing implicit warrants for argument reasoning comprehension.", "content_type": "figure", "figure_type": "schematic"}, "1708.01425v4-Figure3-1.png": {"caption": "Figure 3: Cohen\u2019s \u03ba agreement for stance annotation on 98 comments. As a trade-off between reducing costs (i.e., discarding fewer instances) and increasing reliability, we chose 5 annotators and a threshold of 0.95 for this task, which resulted in \u03ba = 0.58 (moderate to substantial agreement).", "content_type": "figure", "figure_type": "plot"}, "1708.01425v4-Table2-1.png": {"caption": "Accuracy of each approach (humans and systems) on the development set and test set, respectively.", "content_type": "table", "figure_type": "table"}, "1708.01425v4-Figure4-1.png": {"caption": "Human upper bounds on the argument reasoning comprehension task with respect to education and formal training in reasoning, logic, or argumentation. For each configuration, the mean values are displayed together with the number of participants (above the bar) and with their standard deviations (error bars).", "content_type": "figure", "figure_type": "plot"}, "1708.01425v4-Table1-1.png": {"caption": "Details and statistics of the datasets resulting from the eight steps of our methodology implemented in a crowdsourcing process. *Input instances were filtered by their \u2018logic score\u2019 assigned in Step 6, such that the weakest 30% were discarded. A more detailed description is available in the readme file of the source code.", "content_type": "table", "figure_type": "table"}, "1708.01425v4-Figure5-1.png": {"caption": "Figure 5: Intra-warrant attention. Only the attention vector for the warrant W1 is shown; the attention vector for W0 is constructed analogously. Grey areas represent a modification with additional context.", "content_type": "figure", "figure_type": "Schematic"}}, "qa": [{"question": "What are the different steps involved in reconstructing implicit warrants for argument reasoning comprehension?", "answer": "The different steps involved in reconstructing implicit warrants for argument reasoning comprehension are:\n1. Sampling comments\n2. Stance annotation\n3. Reason span annotations\n4. Reason gist summarization\n5. Reason disambiguation\n6. Alternative warrant\n7. Alternative warrant validation\n8. Warrant for original claim\n9. Warrant validation", "explanation": "The figure shows a schematic of the methodology for reconstructing implicit warrants for argument reasoning comprehension. The figure shows the different steps involved in the process, from sampling comments to validating the warrant for the original claim.", "reference": "1708.01425v4-Figure2-1.png"}, {"question": "What is the relationship between the number of workers per \"expert\" and Cohen's kappa agreement for stance annotation?", "answer": "The Cohen's kappa agreement for stance annotation increases as the number of workers per \"expert\" increases.", "explanation": "The figure shows that the Cohen's kappa agreement increases as the number of workers per \"expert\" increases, regardless of the MACE threshold. This suggests that having more workers per \"expert\" leads to more reliable annotations.", "reference": "1708.01425v4-Figure3-1.png"}, {"question": "Which approach performs best on the development set?", "answer": "Intra-warrant attention with context.", "explanation": "The table shows that the Intra-warrant attention with context approach has the highest accuracy on the development set, with a score of 0.638.", "reference": "1708.01425v4-Table2-1.png"}, {"question": "Does formal training in reasoning, logic, or argumentation seem to have a significant effect on argument reasoning comprehension accuracy for people with graduate degrees?", "answer": "No, it does not appear to have a significant effect.", "explanation": "The figure shows that the accuracy for people with graduate degrees who have no training, some training, and extensive training is all around 80%. The error bars for these groups also overlap, indicating that the differences between the groups are not statistically significant.", "reference": "1708.01425v4-Figure4-1.png"}, {"question": "Which step in the methodology resulted in the largest decrease in the size of the dataset?", "answer": "Step 4, Reason disambiguation.", "explanation": "The table shows that the input data for Step 4 had a size of 5,119, while the output data had a size of 1,955. This is a decrease of over 60%.", "reference": "1708.01425v4-Table1-1.png"}, {"question": "How does the intra-warrant attention mechanism work?", "answer": "The intra-warrant attention mechanism uses a BiLSTM to encode the reason and claim, and then provides this encoded information as an attention vector to LSTM layers for each warrant. The attention vector allows the model to focus on specific parts of the reason and claim that are most relevant to each warrant.", "explanation": "The figure shows how the intra-warrant attention mechanism works. The reason and claim are first encoded using a BiLSTM. This encoded information is then used to create an attention vector, which is then provided to LSTM layers for each warrant. The attention vector allows the model to focus on specific parts of the reason and claim that are most relevant to each warrant.", "reference": "1708.01425v4-Figure5-1.png"}]}, "1708.02153v2": {"paper_id": "1708.02153v2", "all_figures": {"1708.02153v2-Table2-1.png": {"caption": "Table 2: Influence of ten different points of interest computed with the same parameters as in the main paper (Parzen: \u03c3 = 4.7);Lime: Euclidean distance and 3.0 kernel width).", "content_type": "table", "figure_type": "N/A"}, "1708.02153v2-Table3-1.png": {"caption": "Table 3: The effect of different parameters and different distance measures.", "content_type": "table", "figure_type": "N/A"}, "1708.02153v2-Table1-1.png": {"caption": "Table 1: Influence of two different points of interest (POI)", "content_type": "table", "figure_type": "N/A"}, "1708.02153v2-Table4-1.png": {"caption": "Table 4: Two example results of MIM influence measurement. Age is given in decades, features 5, 11, 12 and 13 are binary.", "content_type": "table", "figure_type": "N/A"}, "1708.02153v2-Figure1-1.png": {"caption": "Parzen violates monotonicity; the point of interest ~x0 is marked with a green circle. Its influence is the slope of the blue arrow above it.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "How does increasing the parameter value (\u03c1 for LIME with Euclidean distance, \u03bc for LIME with cosine similarity, and \u03c3 for Parzen) seem to affect the influence vectors?", "answer": "As the parameter value increases, the influence vectors generally become smoother and less noisy.", "explanation": "Table 2 showcases the influence vectors and shifted POIs for different parameter values within each method (LIME with Euclidean distance, LIME with cosine similarity, and Parzen). By visually comparing the \"Influence\" images across increasing parameter values within each section, we can see a general trend of the influence vectors becoming less jagged and exhibiting smoother transitions. This suggests that higher parameter values lead to smoother and less noisy influence vectors.", "reference": "1708.02153v2-Table3-1.png"}, {"question": "Which explanation method seems to place the most emphasis on specific, localized features rather than smooth, gradual changes in pixel intensity?", "answer": "LIME appears to place the most emphasis on specific, localized features.", "explanation": "The passage describes the LIME influence visualization as \"more 'shattered' compared to MIM and Parzen,\" indicating a less smooth and more focused influence pattern. This suggests that LIME assigns higher importance to specific pixels or small groups of pixels, rather than considering gradual changes in intensity across larger areas. \n\nThis observation is further supported by the visual comparison of the \"Shifted\" images in the table. While MIM and Parzen result in relatively smooth shifts in brightness, LIME's shifted images show more abrupt changes and sharper contrasts, suggesting a stronger focus on specific features.", "reference": "1708.02153v2-Table1-1.png"}, {"question": "Explain why the \"Last contact\" feature has a significant positive influence on the SSL score in both examples, even though it is not directly used by the SSL algorithm.", "answer": "The \"Last contact\" feature shows a strong positive influence on the SSL score because it is likely correlated with other features that are used by the algorithm. As the passage mentions, data-driven methods like MIM can assign influence to features that are not directly used by the model if they are correlated with other influential features. In this case, a recent \"Last contact\" date might be correlated with a higher number of recent offenses or other factors that contribute to a higher SSL score.", "explanation": "Table 1 shows the \"Infl.\" value for \"Last contact\" is positive and relatively large in both examples (45.32 and 46.2), indicating a significant positive influence on the SSL score. However, the passage clarifies that the SSL algorithm itself does not directly use this feature. This apparent contradiction can be explained by the fact that \"Last contact\" might be correlated with other features that are used by the algorithm and contribute to a higher score.", "reference": "1708.02153v2-Table4-1.png"}]}, "1708.05239v3": {"paper_id": "1708.05239v3", "all_figures": {"1708.05239v3-Figure2-1.png": {"caption": "Figure 2: 10,000 samples drawn from the the target under scenario (a) (left) and scenario (b) (right) using the HMC and pseudo-extended HMC samplers.", "content_type": "figure", "figure_type": "** plot"}, "1708.05239v3-Figure1-1.png": {"caption": "Figure 1: Original target density \u03c0(x) (left) and extended target (right) with N = 2.", "content_type": "figure", "figure_type": "plot"}, "1708.05239v3-Figure7-1.png": {"caption": "Figure 7: Average mean squared error (MSE) (given on the log scale) of the first and second moments taken over 20 independent simulations for varying number of pseudo-samples N , where MSE is scaled by computational time (CT) and plotted as MSE\u00d7 CT.", "content_type": "figure", "figure_type": "plot"}, "1708.05239v3-Figure9-1.png": {"caption": "Plots of marginal posterior densities for a random subsample of variables. Each column represents a different variable and each row is a different MCMC sampler, HMC, PE-HMC (N=2) and PE-HMC (N=5), respectively", "content_type": "figure", "figure_type": "plot"}, "1708.05239v3-Figure10-1.png": {"caption": "Log-predictive density on held-out test data (random 20% of full data) for the prostate cancer dataset comparing the HMC and pseudo-extended HMC samplers, with N = 2 and N = 5. For the case of fixed \u03b2 = [0.25, 0.5, 0.75], the number of pseudo-samples N = 2.", "content_type": "figure", "figure_type": "plot"}, "1708.05239v3-Figure6-1.png": {"caption": "Figure 6: 10,000 samples from the target (left) and extended target (right) using HMC sampler", "content_type": "figure", "figure_type": "plot"}, "1708.05239v3-Figure4-1.png": {"caption": "Figure 4: Root mean squared error (log scale) of the first and second moment of the target taken over 10 independent simulations and calculated for each of the proposed methods. Results labeled [0.1-0.9] correspond to pseudo-extended MCMC with fixed \u03b2 = [0.1\u2212 0.9].", "content_type": "figure", "figure_type": "plot"}, "1708.05239v3-Figure3-1.png": {"caption": "Figure 3: Two-dimensional projection of 10, 000 samples drawn from the target using each of the proposed methods, where the first plot gives the ground-truth sampled directly from the Boltzmann machine relaxation distribution. A temperature ladder of length 1,000 was used for both simulated tempering and annealed importance sampling.", "content_type": "figure", "figure_type": "plot"}, "1708.05239v3-Figure8-1.png": {"caption": "Figure 8: Average mean squared error (MSE) (given on the log scale) taken over 10 independent simulations with varying number of pseudo-samples N , where the MSE is scaled by computational time as MSE\u00d7 CT", "content_type": "figure", "figure_type": "plot"}, "1708.05239v3-Figure5-1.png": {"caption": "Log-predictive densities on held-out test data (random 20% of full data) for two cancer datasets comparing the HMC and pseudo-extended HMC samplers, with N = 2 and N = 5. For the case of fixed \u03b2 = [0.25, 0.5, 0.75], the number of pseudo-samples N = 2.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which MCMC sampler appears to have the most consistent performance across the different variables?", "answer": "PE-HMC (N=5)", "explanation": "The marginal posterior densities for PE-HMC (N=5) are all relatively similar in shape and spread, suggesting that this sampler is able to effectively explore the posterior distribution for all of the variables. In contrast, the other two samplers show more variability in their performance across the different variables.", "reference": "1708.05239v3-Figure9-1.png"}, {"question": "How does the performance of the PE-N=5 sampler compare to the HMC sampler?", "answer": "The PE-N=5 sampler performs better than the HMC sampler.", "explanation": "The box plot for the PE-N=5 sampler is higher than the box plot for the HMC sampler, indicating that the PE-N=5 sampler has a higher log-predictive density on held-out test data.", "reference": "1708.05239v3-Figure10-1.png"}]}, "1809.01246v1": {"paper_id": "1809.01246v1", "all_figures": {"1809.01246v1-Figure5-1.png": {"caption": "The square hashing", "content_type": "figure", "figure_type": "schematic"}, "1809.01246v1-Figure6-1.png": {"caption": "Fig. 6. A sample of the modified version of data structure", "content_type": "figure", "figure_type": "schematic"}, "1809.01246v1-Figure12-1.png": {"caption": "True Negative Recall of Reachability Queries", "content_type": "figure", "figure_type": "plot"}, "1809.01246v1-Figure13-1.png": {"caption": "Buffer Percentage", "content_type": "figure", "figure_type": "plot"}, "1809.01246v1-Figure1-1.png": {"caption": "Fig. 1. A sample graph stream", "content_type": "figure", "figure_type": "** Schematic"}, "1809.01246v1-Figure11-1.png": {"caption": "Average Relative Error of Node Queries", "content_type": "figure", "figure_type": "** Plot"}, "1809.01246v1-Figure10-1.png": {"caption": "Average Precision of 1-hop Successor Queries", "content_type": "figure", "figure_type": "plot"}, "1809.01246v1-Figure2-1.png": {"caption": "Fig. 2. A sample map function", "content_type": "figure", "figure_type": ""}, "1809.01246v1-Figure8-1.png": {"caption": "Average Relative Error of Edge Queries", "content_type": "figure", "figure_type": "plot"}, "1809.01246v1-TableI-1.png": {"caption": "TABLE I UPDATE SPEED (MIPS)", "content_type": "table", "figure_type": "table"}, "1809.01246v1-Figure9-1.png": {"caption": "Average Precision of 1-hop Precursor Queries", "content_type": "figure", "figure_type": "plot"}, "1809.01246v1-Figure4-1.png": {"caption": "Fig. 4. A sample of the basic version of data structure", "content_type": "figure", "figure_type": "schematic"}, "1809.01246v1-Figure3-1.png": {"caption": "Influence of M on Accuracy", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "How does the square hashing process work?", "answer": "Square hashing is a process that uses two hash functions to map a source/destination pair to a bucket in a two-dimensional array. The first hash function, h_i(s), maps the source address to a row in the array, and the second hash function, h_i(d), maps the destination address to a column in the array. The intersection of the row and column is the bucket where the fingerprint is stored.", "explanation": "The figure shows a two-dimensional array of buckets. Each bucket can be either empty, occupied, or mapped. An occupied bucket contains a fingerprint, which is a hash of the source and destination addresses. A mapped bucket is a bucket that has been assigned to a source/destination pair but does not yet contain a fingerprint. An empty bucket has not been assigned to a source/destination pair. The figure also shows an example of how a fingerprint is stored in a bucket. The fingerprint <f(s), f(d)> is stored in the bucket at the intersection of row 1 and column 3.", "reference": "1809.01246v1-Figure5-1.png"}, {"question": "What is the relationship between the buffer percentage and the width of the room?", "answer": "The buffer percentage decreases as the width of the room increases.", "explanation": "The figure shows that the buffer percentage decreases as the width of the room increases for all three data sets. This is because as the width of the room increases, there is more space for the data to be stored, and therefore less need for buffering.", "reference": "1809.01246v1-Figure13-1.png"}, {"question": "How are edges aggregated in the graph sketch $G_h$?", "answer": "Edges are aggregated by adding their weights together.", "explanation": "The figure shows the graph stream $S$ and the corresponding graph sketch $G_h$. In the graph stream, there are two edges between nodes $a$ and $c$, with weights 1 and 4. In the graph sketch, these two edges are combined into a single edge with weight 5.", "reference": "1809.01246v1-Figure1-1.png"}, {"question": "How does the Average Relative Error (ARE) of node queries change as the width increases for different configurations of GSS and TCM?", "answer": "The ARE of node queries generally decreases as the width increases for all configurations of GSS and TCM. However, there are some fluctuations in the ARE for some configurations.", "explanation": "The figure shows the ARE of node queries for different configurations of GSS and TCM on five different datasets. The x-axis of each plot represents the width, and the y-axis represents the ARE. The lines in each plot represent the different configurations of GSS and TCM. The figure shows that the ARE generally decreases as the width increases, which indicates that the accuracy of the node queries improves as the width increases.", "reference": "1809.01246v1-Figure11-1.png"}, {"question": "What is the relationship between the table and the graph sketch in the figure?", "answer": "The table provides the mapping between the nodes in the original graph and their corresponding hash values, which are used to create the graph sketch.", "explanation": " The table shows the hash values (H(v)) for each node (a-g) in the original graph. These hash values are used to map the nodes to their corresponding nodes in the graph sketch. For example, nodes a and d both have a hash value of 2, so they are combined into a single node in the graph sketch.\n\n**Figure type:** Schematic", "reference": "1809.01246v1-Figure2-1.png"}, {"question": "Which graph shows the largest improvement in accuracy for the TCM(8*memory) method compared to the GSS(fsize=12) method?", "answer": "The graph for the Caida-networkflow dataset shows the largest improvement in accuracy for the TCM(8*memory) method compared to the GSS(fsize=12) method.", "explanation": "The graph for the Caida-networkflow dataset shows the largest difference in the y-axis values between the two methods.", "reference": "1809.01246v1-Figure8-1.png"}, {"question": "Which data structure is the fastest for updating on the email-EuAll dataset?", "answer": "GSS (no sampling)", "explanation": "The table shows the update speed of different data structures on different datasets. The update speed is measured in MIPS (millions of instructions per second). The higher the MIPS, the faster the update speed. For the email-EuAll dataset, GSS has the highest MIPS (2.2887), which means it is the fastest data structure for updating on this dataset.", "reference": "1809.01246v1-TableI-1.png"}, {"question": "How does the average precision of TCM(256*memory) compare to the other two algorithms in the email-EuAll dataset?", "answer": "The average precision of TCM(256*memory) is lower than the other two algorithms in the email-EuAll dataset.", "explanation": "The figure shows the average precision of three algorithms for five different datasets. The average precision of TCM(256*memory) is shown as a blue line. In the email-EuAll dataset, the blue line is below the other two lines, indicating that the average precision of TCM(256*memory) is lower than the other two algorithms.", "reference": "1809.01246v1-Figure9-1.png"}, {"question": "Which query type has the highest accuracy when M/|V| is small?", "answer": "Edge query.", "explanation": "The figure shows that the edge query has a higher correct rate than the other two query types when M/|V| is small. This can be seen by comparing the heights of the surfaces in the three plots.", "reference": "1809.01246v1-Figure3-1.png"}]}, "1708.03797v1": {"paper_id": "1708.03797v1", "all_figures": {"1708.03797v1-Figure1-1.png": {"caption": "Overview of HDMF", "content_type": "figure", "figure_type": "schematic"}, "1708.03797v1-Table1-1.png": {"caption": "Dataset Information", "content_type": "table", "figure_type": "** table"}, "1708.03797v1-Table2-1.png": {"caption": "Table 2: Recommendation Performance of Various Models (in %)", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "What is the role of the code layer in the HDMF architecture?", "answer": "The code layer is responsible for generating a compressed representation of the input data. This compressed representation is then used by the decoder to reconstruct the original data.", "explanation": "The figure shows that the code layer is located in the middle of the HDMF architecture, between the encoder and decoder. The encoder takes the input data and transforms it into a compressed representation, which is then fed into the code layer. The code layer further compresses this representation before passing it on to the decoder. The decoder then uses this compressed representation to reconstruct the original data.", "reference": "1708.03797v1-Figure1-1.png"}, {"question": "Which model achieved the best overall performance in terms of ranking relevant tags for users?", "answer": "HDMF achieved the best overall performance.", "explanation": "The table shows the performance of various models on several metrics, including Precision at different cut-off ranks (P@k), Recall at different cut-off ranks (R@k), F-score at different cut-off ranks (F@k), Mean Average Precision (MAP), and Mean Reciprocal Rank (MRR). Higher values indicate better performance for all metrics. Observing the bolded values in the table, which represent the highest scores achieved for each metric, we can see that HDMF consistently outperforms all other models across all the listed metrics. This suggests that HDMF is most effective at ranking relevant tags for users compared to the other models considered.", "reference": "1708.03797v1-Table2-1.png"}]}, "1709.02755v5": {"paper_id": "1709.02755v5", "all_figures": {"1709.02755v5-Figure3-1.png": {"caption": "Figure 3: Mean validation accuracies (y-axis) and standard deviations of the CNN, 2-layer LSTM and 2-layer SRU models. We plot the curves of the first 100 epochs. X-axis is the training time used (in seconds). Timings are performed on NVIDIA GeForce GTX 1070 GPU, Intel Core i7-7700K Processor and cuDNN 7003.", "content_type": "figure", "figure_type": "plot"}, "1709.02755v5-Figure1-1.png": {"caption": "Figure 1: Average processing time in milliseconds of a batch of 32 samples using cuDNN LSTM, wordlevel convolution conv2d (with filter width k = 2 and k = 3), and the proposed SRU. We vary the number of tokens per sequence (l) and feature dimension (d).", "content_type": "figure", "figure_type": "plot"}, "1709.02755v5-Table2-1.png": {"caption": "Table 2: Exact match (EM) and F1 scores of various models on SQuAD (Section 4.2). We also report the total processing time per epoch and the time spent in RNN computations. SRU outperforms other models, and is more than five times faster than cuDNN LSTM.", "content_type": "table", "figure_type": "N/A"}, "1709.02755v5-Table6-1.png": {"caption": "Table 6: Translation training configuration.", "content_type": "table", "figure_type": "N/A"}, "1709.02755v5-Figure6-1.png": {"caption": "Figure 6: Empirical estimation of the variance ratio Var[ct]/Var[xt] at each layer in a randomly initialized SRU model. We use the pre-trained word2vec embeddings as input, resulting an initial ratio slightly higher than 1/3. As expected, the ratio increases to 1 in deep layers.", "content_type": "figure", "figure_type": "plot"}, "1709.02755v5-Figure2-1.png": {"caption": "Figure 2: Training curves of SRU on classification. The x-axis is the number of training steps and the y-axis is the training loss. Scaling correction improves the training progress, especially for deeper models with many stacked layers.", "content_type": "figure", "figure_type": "plot"}, "1709.02755v5-Table4-1.png": {"caption": "Table 4: Validation and test BPCs of different recurrent models on Enwik8 dataset. The last column presents the training time per epoch. For SRU with projection, we set the projection dimension to 512.", "content_type": "table", "figure_type": "N/A"}, "1709.02755v5-Table1-1.png": {"caption": "Table 1: Test accuracies on classification benchmarks (Section 4.1). The first block presents best reported results of various methods. The second block compares SRU and other baselines given the same setup. For the SST dataset, we report average results of 5 runs. For other datasets, we perform 3 independent trials of 10-fold cross validation (3\u00d710 runs). The last column compares the wall clock time (in seconds) to finish 100 epochs on the SST dataset.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "How does the validation accuracy of the SRU model compare to that of the cuDNN LSTM and CNN models?", "answer": "The SRU model achieves comparable or slightly higher validation accuracy than the cuDNN LSTM and CNN models on all six benchmarks.", "explanation": "Figure 2 shows the mean validation accuracies of the three models on the six benchmarks. The SRU model's curve is generally above or close to the curves of the other two models, indicating that it achieves comparable or slightly higher accuracy.", "reference": "1709.02755v5-Figure3-1.png"}, {"question": "How does the processing time of SRU compare to that of cuDNN LSTM and word-level convolution with filter widths k=2 and k=3?", "answer": "The processing time of SRU is significantly faster than that of cuDNN LSTM and word-level convolution with filter widths k=2 and k=3.", "explanation": "The figure shows the average processing time of a batch of 32 samples using different architectures. The x-axis shows the number of tokens per sequence (l) and feature dimension (d), and the y-axis shows the processing time in milliseconds. The figure shows that SRU has a lower processing time than the other architectures across all values of l and d.", "reference": "1709.02755v5-Figure1-1.png"}, {"question": "According to Table 1 and the passage, how does the performance of the SRU model compare to the LSTM model in terms of both accuracy and training speed on the SQuAD dataset?", "answer": "The SRU model outperforms the LSTM model in both accuracy and training speed on the SQuAD dataset.", "explanation": "Table 1 shows that the SRU model achieves higher EM and F1 scores compared to the LSTM model. Additionally, the passage states that SRU exhibits over 5x speed-up over LSTM and 53-63% reduction in total training time. This indicates that SRU not only achieves better accuracy but also trains significantly faster than the LSTM model.", "reference": "1709.02755v5-Table2-1.png"}, {"question": "Based on the table, how does the training process handle large vocabulary sizes?", "answer": "The training process uses several techniques to handle large vocabulary sizes. These include:\n\n1. **Token-based batching:** Instead of grouping sentences of similar lengths together, the training process batches together a fixed number of tokens (5120 tokens per batch). This approach ensures that the model sees a consistent amount of vocabulary regardless of sentence length variation.\n2. **Shared embedding:** This technique maps both source and target words to the same embedding space, effectively reducing the memory footprint needed to store word representations. \n3. **Positional encoding:** This method injects information about the position of words in a sentence into the model, helping it better understand long-range dependencies within the text. ", "explanation": "The table provides various hyperparameters used for training the translation model. By analyzing specific parameters like `batch_type`, `share_embedding`, and `position_encoding`, we can understand how the model is designed to cope with large vocabularies. These specific settings enable efficient processing and representation of large vocabulary sizes within the model's memory and architecture.", "reference": "1709.02755v5-Table6-1.png"}, {"question": "How does the variance of the hidden state $h_t$ compare to the variance of the input $x_t$ in deep layers of the SRU model?", "answer": "According to the passage, the variance of the hidden state is approximately equal to the variance of the input in deep layers.", "explanation": "The figure shows that the ratio of the variance of the cell state to the variance of the input increases to 1 in deep layers. This implies that the variance of the hidden state is approximately equal to the variance of the input.", "reference": "1709.02755v5-Figure6-1.png"}, {"question": "How does scaling correction affect the training of SRU models?", "answer": "Scaling correction improves the training progress of SRU models, especially for deeper models with many stacked layers.", "explanation": "The figure shows the training curves of SRU models with and without scaling correction. The x-axis is the number of training steps and the y-axis is the training loss. The curves with scaling correction (red) have a lower loss and converge faster than the curves without scaling correction (black). This is especially noticeable for the 20-layer model.", "reference": "1709.02755v5-Figure2-1.png"}, {"question": "How does the performance of SRU with 8 layers compare to the best reported results on the SUBJ dataset, and how does its training time compare to the other models in the \"Our setup\" section?", "answer": "While SRU with 8 layers achieves high test accuracy within the \"Our setup\" section on the SUBJ dataset (93.7%), it falls slightly short of the best reported result of 95.5% achieved by Zhao et al. (2015). However, SRU's training time of 879 seconds for 100 epochs on the SST dataset is faster than the LSTM model (2409 seconds) but slower than the CNN model (417 seconds) and the QRNN models (345 and 371 seconds).", "explanation": "The table shows the test accuracies for different models on various datasets, including SUBJ. Comparing the values in the corresponding columns allows us to assess the relative performance of SRU with 8 layers against other models. Additionally, the last column provides training time information for the SST dataset, enabling comparison of training efficiency between SRU and the other models in the \"Our setup\" section.", "reference": "1709.02755v5-Table1-1.png"}]}, "1809.02731v3": {"paper_id": "1809.02731v3", "all_figures": {"1809.02731v3-Table3-1.png": {"caption": "Results on unsupervised evaluation tasks (Pearson\u2019s r \u00d7 100) . Bold numbers are the best results among unsupervised transfer models, and underlined numbers are the best ones among all models. \u2018WR\u2019 refers to", "content_type": "table", "figure_type": "table"}, "1809.02731v3-Table4-1.png": {"caption": "Comparison of the learnt representations in our system with the same dimensionality as pretrained word vectors on unsupervised evaluation tasks. The encoding function that is learnt to compose a sentence representation from pretrained word vectors outperforms averaging word vectors, which supports our argument that learning helps to produce higher-quality sentence representations.", "content_type": "table", "figure_type": "table"}, "1809.02731v3-Table5-1.png": {"caption": "Results on supervised evaluation tasks. Bold numbers are the best results among unsupervised transfer models with ordered sentences, and underlined numbers are the best ones among all models.", "content_type": "table", "figure_type": "table"}, "1809.02731v3-Table1-1.png": {"caption": "Summary statistics of the two corpora used. For simplicity, the two corpora are referred to as B and U in the following tables respectively.", "content_type": "table", "figure_type": "table"}, "1809.02731v3-Table2-1.png": {"caption": "The effect of the invertible constraint on the linear projection. The arrow and its associated value of a representation is the relative performance gain or loss compared to its comparison partner with the invertible constraint. As shown, the invertible constraint does help improve each representation, an ensures the ensemble of two encoding functions gives better performance. Better view in colour.", "content_type": "table", "figure_type": "table"}}, "qa": [{"question": "Which model performed best on average across all tasks?", "answer": "The Linear model performed best on average with a score of 70.0.", "explanation": "The table shows the performance of three models on seven different tasks. The average performance is shown in the last row of the table.", "reference": "1809.02731v3-Table4-1.png"}, {"question": "Which corpus has more sentences, and by how much?", "answer": "The UMBC News corpus has more sentences, by approximately 60.5 million.", "explanation": "The table shows that the BookCorpus has 74 million sentences, while the UMBC News corpus has 134.5 million sentences.", "reference": "1809.02731v3-Table1-1.png"}, {"question": "Which model performs the best on the STS16 task with unsupervised training?", "answer": "The Bijective model performs the best on the STS16 task with unsupervised training.", "explanation": "The table shows the performance of different models on the STS16 task with unsupervised training. The Bijective model has the highest score of 75.8, which indicates that it performs the best.", "reference": "1809.02731v3-Table3-1.png"}]}, "1809.03149v2": {"paper_id": "1809.03149v2", "all_figures": {"1809.03149v2-Figure9-1.png": {"caption": "The impact of different positions on CTR.", "content_type": "figure", "figure_type": "** Plot"}, "1809.03149v2-Figure1-1.png": {"caption": "Advertising with Adaptive Exposure and Our System Structure.", "content_type": "figure", "figure_type": "schematic"}, "1809.03149v2-Figure4-1.png": {"caption": "The relationship between ratio and the value of advertising products. (a): The relationship between ratio and commodity ecpm, price. (b): The relationship between ratio and commodity ecpm", "content_type": "figure", "figure_type": "plot"}, "1809.03149v2-Figure3-1.png": {"caption": "Learning Curves: DDPG with CHER Compared with DDPG without CHER.", "content_type": "figure", "figure_type": "** plot"}, "1809.03149v2-Table1-1.png": {"caption": "List of notations.", "content_type": "table", "figure_type": "table"}, "1809.03149v2-Figure5-1.png": {"caption": "Learning Curves Compared with Policy \u03c01.", "content_type": "figure", "figure_type": "plot"}, "1809.03149v2-Figure6-1.png": {"caption": "Learning Curves Compared with Policy \u03c02.", "content_type": "figure", "figure_type": "plot"}, "1809.03149v2-Table3-1.png": {"caption": "Table 3: The Performance of Our Approach for each Hour.", "content_type": "table", "figure_type": "N/A"}, "1809.03149v2-Figure7-1.png": {"caption": "Learning Curves Compared with Policy \u03c03.", "content_type": "figure", "figure_type": "plot"}, "1809.03149v2-Table2-1.png": {"caption": "Table 2: The Performance of Our Approach in One Day.", "content_type": "table", "figure_type": "N/A"}, "1809.03149v2-Figure8-1.png": {"caption": "The changing curves of per-hour advertising rates with one day. Fix: The proportion of ads exposed on each request is fixed and set to 0.35; Oracle: After one day, we could figure out the best dynamical advertising rate available for each hour under conditions that satisfy the daily constraint: PVR = 0.35 through data analysis.", "content_type": "figure", "figure_type": "plot"}, "1809.03149v2-Figure2-1.png": {"caption": "The Framework Structure.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "What is the relationship between position and click-through rate (CTR)?", "answer": "The relationship between position and CTR is complex and non-linear. In general, CTR decreases as position increases, but there are also local peaks and valleys in the CTR curve. This suggests that there are other factors besides position that affect CTR.", "explanation": "The figure shows the real data and a curve fitting for CTR as a function of position. The real data shows a general downward trend, but there are also local peaks and valleys. The curve fitting captures the general trend of the data, but it does not capture all of the local variation. This suggests that there are other factors besides position that affect CTR.", "reference": "1809.03149v2-Figure9-1.png"}, {"question": "How does the advertising rate for the \"Fix\" curve compare to the \"Oracle\" curve at hour 14?", "answer": "The advertising rate for the \"Fix\" curve is lower than the \"Oracle\" curve at hour 14.", "explanation": "The \"Fix\" curve is shown in blue, and the \"Oracle\" curve is shown in red. At hour 14, the red curve is higher than the blue curve, indicating that the advertising rate for the \"Oracle\" curve is higher.", "reference": "1809.03149v2-Figure8-1.png"}, {"question": "What is the role of the Higher Level Policy in the framework?", "answer": "The Higher Level Policy sets constraints for the next sub-trajectory and provides information about the previous stage to the Lower Level Policy.", "explanation": "The figure shows that the Higher Level Policy is located above the Lower Level Policy and provides input to it. The text in the figure also states that the Higher Level Policy sets constraints for the next sub-trajectory.", "reference": "1809.03149v2-Figure2-1.png"}, {"question": "How does the advertising system select the best items to show to the user?", "answer": "The advertising system selects the best items to show to the user by first generating a candidate set of items from the recommender system. This candidate set is then shuffled and sorted by their score, which is determined by the network. The network takes into account the features of the items and the scoring factors, which are likely based on the user's past behavior and preferences.", "explanation": "The figure shows the overall structure of the advertising system. It shows how the candidate set of items is generated, how the items are scored, and how the final set of items is selected.", "reference": "1809.03149v2-Figure1-1.png"}, {"question": "What is the effect of using CHER on the percentage of ads displayed for each user?", "answer": "The percentage of ads displayed for each user is higher when CHER is used.", "explanation": "The figure shows that the blue line (CHER) is consistently higher than the orange line (without CHER) across all user numbers. This indicates that CHER leads to a higher percentage of ads being displayed.", "reference": "1809.03149v2-Figure3-1.png"}]}, "1708.06832v3": {"paper_id": "1708.06832v3", "all_figures": {"1708.06832v3-Figure3-1.png": {"caption": "(a) Average relative percentage increase in error from OPT on CIFAR and SVHN at 1/4, 1/2, 3/4 and 1 of the total cost. E.g., the bottom right entry means that if OPT has a 10% final error rate, then AdaLoss has about 10.27%. (b) Test error rates at different fraction of the total costs on ResANN50 and DenseANN169.", "content_type": "figure", "figure_type": "table"}, "1708.06832v3-Figure1-1.png": {"caption": "(a) The common ANN training strategy increases final errors from the optimal (green vs. blue), which decreases exponentially slowly. By learning to focus more on the final auxiliary losses, the proposed adaptive loss weights make a small ANN (orange) to outperform a large one (green) that has non-adaptive weights. (b) Anytime neural networks contain auxiliary predictions and losses, y\u0302i and `i, for intermediate feature unit fi.", "content_type": "figure", "figure_type": "plot"}, "1708.06832v3-Figure4-1.png": {"caption": "(a-e) Comparing small networks with AdaLoss versus big ones using CONST. With AdaLoss, the small networks achieve the same accuracy levels faster than large networks with CONST. (f) ANNs performance are mostly decided by underlying models, but AdaLoss is beneficial regardless models.", "content_type": "figure", "figure_type": "plot"}, "1708.06832v3-Figure5-1.png": {"caption": "(a) EANN performs better if the ANNs use AdaLoss instead of CONST. (b) EANN outperforms linear ensembles of DNNs on ILSVRC. (c) The learned adaptive weights of the same model on three data-sets.", "content_type": "figure", "figure_type": "plot"}, "1708.06832v3-Figure2-1.png": {"caption": "(a) CONST scheme is increasingly worse than the optimal at deep layers. AdaLoss performs about equally well on all layers in comparison to the OPT. (b) EANN computes its ANNs in order of their depths. An anytime result is used if it is better than all previous ones on a validation set (layers in light blue).", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which method achieves the lowest error rate on ILSVRC at 1/4 of the total cost?", "answer": "MSDNNet38", "explanation": "The table in Figure (b) shows the error rates of different methods on ILSVRC at different fractions of the total cost. MSDNNet38 + AdaLoss has the lowest error rate of 28.0 at 1/4 of the total cost.", "reference": "1708.06832v3-Figure3-1.png"}, {"question": "What is the effect of increasing the budget in FLOPS on the test Top-1 error rate for the three different training strategies?", "answer": "The test Top-1 error rate decreases as the budget in FLOPS increases for all three training strategies.", "explanation": "The figure shows that the test Top-1 error rate decreases as the budget in FLOPS increases for all three training strategies. This is because increasing the budget in FLOPS allows the models to train for longer and learn more complex features.", "reference": "1708.06832v3-Figure1-1.png"}, {"question": "Which model performs the best on CIFAR100 and ILSVRC datasets?", "answer": "EANN with AdaLoss performs the best on both CIFAR100 and ILSVRC datasets.", "explanation": "This can be seen in Figure (a) and (b), where EANN with AdaLoss consistently has the lowest error rate compared to other models.", "reference": "1708.06832v3-Figure5-1.png"}]}, "1906.06589v3": {"paper_id": "1906.06589v3", "all_figures": {"1906.06589v3-Table2-1.png": {"caption": "Table 2: Models trained without any defenses have high test accuracies, Atest, but their high generalization errors, Egen (i.e., Atrain \u2212 Atest) facilitate strong MIAs (\u00a7 5.2). \u201cN/A\u201d means the attack is not evaluated due to lack of data.", "content_type": "table", "figure_type": "N/A"}, "1906.06589v3-Table4-1.png": {"caption": "Table 4: Evaluating three state-of-the-art regularizers, with similar, low MIA risks (high membership privacy) as DMP. A+ test shows the % increase in Atest due to DMP over the corresponding regularizers.", "content_type": "table", "figure_type": "N/A"}, "1906.06589v3-Table5-1.png": {"caption": "Table 5: DP-SGD versus DMP for CIFAR10 and Alexnet. For low MIA risk of \u223c 51.3%, DMP achieves 24.5% higher Atest than of DP-SGD (12.8% absolute increase in Atest).", "content_type": "table", "figure_type": "N/A"}, "1906.06589v3-Table6-1.png": {"caption": "Table 6: Comparing PATE with DMP. DMP has Egen, Atest, and Awb of 1.19%, 76.79%, and 50.8%, respectively. PATE has low accuracy even at high privacy budgets, as it divides data among teachers and produces low accuracy ensembles.", "content_type": "table", "figure_type": "N/A"}, "1906.06589v3-Table3-1.png": {"caption": "Comparing test accuracy (Atest) and generalization error (Egen) of DMP and Adversarial Regularization, for near-equal, low MIA risks (high membership privacy). A+ test shows the % increase in Atest of DMP over Adversarial Regularization.", "content_type": "table", "figure_type": "Table"}, "1906.06589v3-Figure3-1.png": {"caption": "Empirical validation of simplification of (14) to (15): Increase in \u2206LCE increases \u2206LKL, and that of (14) to (19): Increase inH(\u03b8up(z)) increases \u2206LKL.", "content_type": "figure", "figure_type": "Plot"}, "1906.06589v3-Table11-1.png": {"caption": "Table 11: Generalization error (Egen), test accuracy (Atest), and various MIA risks (evaluated using MIAs from Section 5.2) of models trained using state-of-the-art regularization techniques. Here we provide MIA risks for regularized models whose accuracy is close to that of DMP-trained models. We note that, for the same test accuracy, DMP-trained models provide significantly higher resistance to MIAs.", "content_type": "table", "figure_type": "N/A"}, "1906.06589v3-Table12-1.png": {"caption": "Table 12: Best tradeoffs between test accuracy (Atest) and membership inference risks (evaluated using MIAs from Section 5.2) due to adversarial regularization. DMP significantly improves the tradeoffs over the adversarial regularization (results for DMP are in Table 3).", "content_type": "table", "figure_type": "N/A"}, "1906.06589v3-Figure5-1.png": {"caption": "Impact of softmax temperature on training of \u03b8p: Increase in the temperature of softmax layer of \u03b8up reduces \u2206LKL in (13), and hence, the ratioR in (11). This improves the membership privacy and generalization of \u03b8p.", "content_type": "figure", "figure_type": "plot"}, "1906.06589v3-Figure6-1.png": {"caption": "Distributions of gradient norms of members and non-members of private training data. (Upper row): Unlike the distribution of non-members, that of the members of the unprotected model, \u03b8up, is skewed towards 0 as \u03b8up memorizes the members. (Lower row): The distributions of gradient norms for members and non-members for the protected model, \u03b8p, of DMP are almost indistinguishable.", "content_type": "figure", "figure_type": "plot"}, "1906.06589v3-Figure7-1.png": {"caption": "The empirical CDF of the generalization error of models trained with DMP, adversarial regularization (AdvReg), and without defense. The y-axis is the fraction of classes that have generalization error less than the values on x-axis. The generalization error reduction due to DMP is much larger (10\u00d7 for CIFAR100 and 2\u00d7 for Purchase) than due to AdvReg. The low generalization error improves membership privacy due to DMP.", "content_type": "figure", "figure_type": "plot"}, "1906.06589v3-Figure1-1.png": {"caption": "Distillation for Membership Privacy (DMP) defense. (1) In pre-distillation phase, DMP trains an unprotected model \u03b8up on the private training data without any privacy protection. (2.1) In distillation phase, DMP uses \u03b8up to select/generate appropriate reference data Xref that minimizes membership privacy leakage. (2.2) Then, DMP transfers the knowledge of \u03b8up by computing predictions of \u03b8up on Xref , denoted by \u03b8Xref", "content_type": "figure", "figure_type": "Schematic"}, "1906.06589v3-Figure4-1.png": {"caption": "Increasing reference data size, |Xref|, increases accuracy of \u03b8p, but also increases R in (11), which increases the membership inference risk due to \u03b8p.", "content_type": "figure", "figure_type": "plot"}, "1906.06589v3-Table7-1.png": {"caption": "Table 7: Evaluation of PATE using the discriminator architecture in (Salimans et al. 2016) trained on CIFAR10. The corresponding DMP-trained model has 77.98% and 76.79% accuracies on the training and test data, and 50.8% membership inference accuracy. Comparison of results clearly show the superior membership privacy-model utility tradeoffs of DMP over PATE.", "content_type": "table", "figure_type": "N/A"}, "1906.06589v3-Table8-1.png": {"caption": "Table 8: Effect of the softmax temperature on DMP: For a fixed Xref, increasing the temperature of softmax layer of \u03b8up reduces R in (11), which strengthens the membership privacy.", "content_type": "table", "figure_type": "N/A"}, "1906.06589v3-Table9-1.png": {"caption": "Table 9: Temperature of the softmax layers for the different combinations of dataset and network architecture used to produce the results in Table 3 of the main paper.", "content_type": "table", "figure_type": "N/A"}, "1906.06589v3-Table10-1.png": {"caption": "DMP does not pose membership inference risk to the possibly sensitive reference data. Aref and Atest are accuracies of protected model, \u03b8p, on Xref and Dtest, respectively.", "content_type": "table", "figure_type": "table"}, "1906.06589v3-Table1-1.png": {"caption": "Table 1: All the dataset splits are disjoint. D, D\u2032 data are the members and non-members ofDtr known to MIA adversary.", "content_type": "table", "figure_type": "N/A"}, "1906.06589v3-Figure2-1.png": {"caption": "The lower the entropy of predictions of unprotected model on Xref , the higher the membership privacy.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which model performed the best on the test data?", "answer": "P-FC", "explanation": "The table shows that P-FC achieved the highest test accuracy (Atest) of 74.1.", "reference": "1906.06589v3-Table10-1.png"}, {"question": "How does the size of the reference set ($X_\\textsf{ref}$) used for DMP training differ between the Purchase/Texas datasets and the CIFAR datasets? Explain the rationale behind this difference.", "answer": "For Purchase and Texas datasets, $X_\\textsf{ref}$ is specifically selected and contains 10,000 data points. In contrast, for CIFAR datasets, the entire remaining data (25,000 points) after selecting $D_\\textsf{tr}$ is used as $X_\\textsf{ref}$. This difference is due to the smaller size of the CIFAR datasets. Using the entire remaining data as $X_\\textsf{ref}$ ensures sufficient data for effective DMP training in these cases.", "explanation": "The table shows the sizes of different data splits used in the experiment. By comparing the values in the $X_\\textsf{ref}$ column for different datasets, we can see that the selection strategy differs. The passage further clarifies that this difference is intentional and is based on the size of the datasets.", "reference": "1906.06589v3-Table1-1.png"}, {"question": "What is the relationship between the average X_ref entropy and the generalization gap?", "answer": "The generalization gap increases as the average X_ref entropy increases.", "explanation": "The right panel of the figure shows that the generalization gap (red dashed line) increases as the average X_ref entropy increases.", "reference": "1906.06589v3-Figure2-1.png"}]}, "1809.03449v3": {"paper_id": "1809.03449v3", "all_figures": {"1809.03449v3-Figure4-1.png": {"caption": "With KAR, SAN, and QANet (without data augmentation) trained on the training subsets, we evaluate their performance on AddOneSent.", "content_type": "figure", "figure_type": "plot"}, "1809.03449v3-Figure2-1.png": {"caption": "With KAR, SAN, and QANet (without data augmentation) trained on the training subsets, we evaluate their performance on the development set.", "content_type": "figure", "figure_type": "plot"}, "1809.03449v3-Figure3-1.png": {"caption": "With KAR, SAN, and QANet (without data augmentation) trained on the training subsets, we evaluate their performance on AddSent.", "content_type": "figure", "figure_type": "plot"}, "1809.03449v3-Table3-1.png": {"caption": "With \u03ba set to different values in the data enrichment method, we calculate the average number of inter-word semantic connections per word as an estimation of the amount of general knowledge, and evaluate the performance of KAR on the development set.", "content_type": "table", "figure_type": "table"}, "1809.03449v3-Table2-1.png": {"caption": "Model comparison based on SQuAD 1.1 and two of its adversarial sets: AddSent and AddOneSent. All the numbers are up to date as of October 18, 2018. Note that SQuAD 2.0 (Rajpurkar et al., 2018) is not involved in this paper, because it requires MRC models to deal with the problem of answer triggering, but this paper is aimed at improving the hunger for data and robustness to noise of MRC models.", "content_type": "table", "figure_type": "table"}, "1809.03449v3-Table1-1.png": {"caption": "Two examples about the importance of inter-word semantic connections to the reading comprehension ability of human beings: in the first one, we can find the answer because we know \u201cfacilitate\u201d is a synonym of \u201chelp\u201d; in the second one, we can find the answer because we know \u201cBrooklyn\u201d is a hyponym of \u201cborough\u201d.", "content_type": "table", "figure_type": "table"}, "1809.03449v3-Figure1-1.png": {"caption": "An end-to-end MRC model: Knowledge Aided Reader (KAR)", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "How does the average number of inter-word semantic connections per word change as the value of \u03ba increases?", "answer": "The average number of inter-word semantic connections per word increases as the value of \u03ba increases.", "explanation": "The table shows that the average number of inter-word semantic connections per word increases from 0.39 to 5.58 as the value of \u03ba increases from 0 to 5. This suggests that increasing the value of \u03ba leads to a greater number of semantic connections between words.", "reference": "1809.03449v3-Table3-1.png"}, {"question": "Which model performed the best on the AddOneSent dataset?", "answer": "KAR", "explanation": "The table shows that KAR achieved the highest F1 score of 72.3 on the AddOneSent dataset.", "reference": "1809.03449v3-Table2-1.png"}, {"question": "What is the role of the Knowledge Aided Similarity Matrix in the KAR model?", "answer": "The Knowledge Aided Similarity Matrix is used to compute the similarity between the question and passage context embeddings. This similarity score is then used to weight the passage context embeddings, giving more weight to those parts of the passage that are most relevant to the question.", "explanation": "The figure shows that the Knowledge Aided Similarity Matrix is used to compute the similarity between the enhanced question context embeddings and the enhanced passage context embeddings. This similarity score is then used to weight the passage context embeddings, giving more weight to those parts of the passage that are most relevant to the question.", "reference": "1809.03449v3-Figure1-1.png"}, {"question": "How does the performance of KAR, SAN, and QANet (without data augmentation) change as the proportion of available training examples decreases?", "answer": "The performance of all three models decreases as the proportion of available training examples decreases.", "explanation": "The figure shows that the F1 score of all three models decreases as the proportion of available training examples decreases. This indicates that the models are less accurate when they are trained on less data.", "reference": "1809.03449v3-Figure4-1.png"}, {"question": "Which model performs the best when trained on 60% of the training data?", "answer": "KAR", "explanation": "The figure shows that the F1 score for KAR is higher than the F1 score for SAN and QANet when trained on 60% of the training data.", "reference": "1809.03449v3-Figure2-1.png"}, {"question": "Which of the three models, KAR, SAN, or QANet (without data augmentation), performs the best on AddSent when trained on the full training set?", "answer": "KAR", "explanation": "The figure shows the F1 score of each model on AddSent for different proportions of the training set. At 100% of the training set, KAR has the highest F1 score.", "reference": "1809.03449v3-Figure3-1.png"}]}, "1710.05654v2": {"paper_id": "1710.05654v2", "all_figures": {"1710.05654v2-Figure8-1.png": {"caption": "Detail from the manifolds recovered by `2 and log models from \"spherical data\" (262, 144 nodes, 1920 signals). Corner (blue) and middle (green) parts of the manifold. Left: `2 model, k = 4.70. Right: log model, k = 4.73. See Figure 7 for the big picture.", "content_type": "figure", "figure_type": "plot"}, "1710.05654v2-Figure9-1.png": {"caption": "Graph diameter measures manifold recovery quality. Left: small spherical data: 4096 nodes, 1920 signals. Middle: Same data, 40 signals. Right: word2vec: 10,000 nodes, 300 features.", "content_type": "figure", "figure_type": "plot"}, "1710.05654v2-Figure10-1.png": {"caption": "A 2-hop sub-graph of the word \u201duse\u201d. Left: A-NN (k = 5.4). Center: k-NN graph (k = 5.0). Right: Large scale log (k = 5.7) being manifold-like only reaches relevant terms.", "content_type": "figure", "figure_type": "schematic"}, "1710.05654v2-Figure15-1.png": {"caption": "Figure 15: Time needed for learning a graph of 60000 nodes (MNIST images) using the large-scale version of (3). Our algorithm converged after 250 to 450 iterations with a tolerance of 1e\u2212 4. The time needed is linear to the number of variables, that is linear to the average degree of the graph.", "content_type": "figure", "figure_type": "plot"}, "1710.05654v2-Figure1-1.png": {"caption": "Time comparison of different ways to compute a graph. Left: Graph between 10,000 most frequent English words using a word2vec representation. Right: Graph between 1,000,000 nodes from 68 features (US Census 1990). Scalable algorithms benefit from a small average node degree k.", "content_type": "figure", "figure_type": "plot"}, "1710.05654v2-Figure7-1.png": {"caption": "Spherical data, ground truth and recovered manifolds. Up left: The ground truth manifold is on the sphere. We have colored the nodes that correspond to the middle of the 2-D grid and the lower corner so that we track where they are mapped in the recovered manifolds. In Figure 8 we keep only the subgraphs of the green or blue nodes. Up, right: Recovered by A-NN, k = 4.31. Down, left: Recovered by the `2 model, k = 4.70. The middle region is mixed with nodes outside the very center. The corners are much more dense, the blue region is barely visible on the bottom. Note that 46 nodes were disconnected so they are not mapped at all. Down, right: Recovered by the log model, k = 4.73. The middle region is much better mapped. The corners are still very dense, we have to zoom-in for the blue region (Figure 8).", "content_type": "figure", "figure_type": "plot"}, "1710.05654v2-Figure11-1.png": {"caption": "Label frequency (left) and average squared distribution (right) of MNIST train data (60000 nodes). The distances between digits \u201c1\u201d are significantly smaller than distances between other digits.", "content_type": "figure", "figure_type": "plot"}, "1710.05654v2-Figure4-1.png": {"caption": "Figure 4: Effectiveness of \u03b8 bounds eq. (18). Requested versus obtained degree, \"spherical\" data (262, 000 nodes).", "content_type": "figure", "figure_type": "plot"}, "1710.05654v2-Figure5-1.png": {"caption": "Connectivity across classes of MNIST. The graph is normalized so that \u2016W\u20161,1 = 1. We measure the percentage of the total weight for connected pairs of each label. The last columns correspond to the total of the wrong edges, between images of different labels. Left: A-NN graph. Middle: `2 model (4) neglects digits with larger distance. Right: log model (5) does not neglect to connect any cluster even for very sparse graphs of 5 edges per node.", "content_type": "figure", "figure_type": "plot"}, "1710.05654v2-Figure12-1.png": {"caption": "Robustness of the theoretical bounds of \u03b8 in the existence of outliers or duplicate nodes. Same dataset as the one used for Figure 2. Even for extreme cases in terms of distance distribution, the bounds give a good approximation. Left: Results when we add Gaussian noise from N (0, 1) to 10% of the images before calculating Z. Note that the noise added is significant given that the initial pixel values are in [0, 1]. Right: We replaced 10% of the images with duplicates of other images already in the dataset.", "content_type": "figure", "figure_type": "plot"}, "1710.05654v2-Figure13-1.png": {"caption": "Predicted and measured sparsity for different choices of \u03b8. Note that \u03b8 is plotted in logarithmic scale and decreasing. Up left: 400 ATT face images. Up right: 1440 object images from the COIL dataset. Down left: Graph between 1000 samples from a multivariate uniform distribution. Down right: Graph between 1000 samples from a multivariate Gaussian distribution.", "content_type": "figure", "figure_type": "plot"}, "1710.05654v2-Figure6-1.png": {"caption": "Left: Edge accuracy of large scale models for MNIST. Right: Digit classification error with 1% labels. Dashed lines represent nodes in components without known labels (non-classifiable).", "content_type": "figure", "figure_type": "plot"}, "1710.05654v2-Figure14-1.png": {"caption": "Connectivity across different classes of MNIST (60000 nodes). The graph is normalized so that \u2016W\u20161,1 = 1. We measure the percentage of the total weight for connected pairs of each label. The last columns correspond to the total of the wrong edges, between images of different labels. Left: (Daitch et al., 2009) hard model. As the degree is constant over the nodes, the hard model is close the A-NN. Right: (Daitch et al., 2009) soft model. In terms of connextivity, the soft model seems to be between the log and the `2 model. Note that while it favors connections between \"1\"s, this effect becomes worse with higher density. Note also that these algorithms fail to give reasonable graphs for densities outside a small range, making it very difficult to control sparsity.", "content_type": "figure", "figure_type": "plot"}, "1710.05654v2-Table1-1.png": {"caption": "Table 1: Weight comparison between k-NN, A-NN and learned graphs. The weights assigned by graph learning correspond much better to the relevance of the terms.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "How does the time needed for learning a graph with a subset of allowed edges $\\mathcal{E}^\\text{allowed}$ change as the number of edges per node increases?", "answer": "The time needed for learning a graph with a subset of allowed edges $\\mathcal{E}^\\text{allowed}$ increases linearly as the number of edges per node increases.", "explanation": "The figure shows that the time needed for learning a graph increases linearly with the number of edges per node. This is because the cost of learning a graph with a subset of allowed edges $\\mathcal{E}^\\text{allowed}$ is linear to the size of the set.", "reference": "1710.05654v2-Figure15-1.png"}, {"question": "Which method is the fastest for computing a graph with a small average node degree?", "answer": "The proposed method in this paper (k=5) is the fastest for computing a graph with a small average node degree.", "explanation": "The figure on the right shows that the method in this paper (k=5) has the lowest time complexity for computing a graph with a small average node degree.", "reference": "1710.05654v2-Figure1-1.png"}, {"question": "Which digit has the highest average squared distance to other digits in the MNIST dataset?", "answer": "Digit \"1\"", "explanation": "The right plot shows the average squared distance for each digit. We can see that the bar for digit \"1\" is the highest, which means that on average, digit \"1\" is further away from other digits than any other digit.", "reference": "1710.05654v2-Figure11-1.png"}, {"question": "How well do the approximate bounds of $\\theta$ predict sparsity in the \"spherical\" dataset?", "answer": "The approximate bounds of $\\theta$ are very effective at predicting sparsity in the \"spherical\" dataset.", "explanation": "The figure shows that the obtained degree closely follows the requested degree for both the large-scale log and A-NN methods. This indicates that the approximate bounds of $\\theta$ are accurately predicting the sparsity of the resulting graph.", "reference": "1710.05654v2-Figure4-1.png"}, {"question": "Which model is the most effective at connecting digits with larger distances?", "answer": "The log model.", "explanation": "The rightmost plot shows that the log model has the highest percentage of weight for connected pairs of each label, even for very sparse graphs of 5 edges per node. This indicates that the log model is the most effective at connecting digits with larger distances.", "reference": "1710.05654v2-Figure5-1.png"}, {"question": "What is the effect of adding Gaussian noise to the images on the measured sparsity?", "answer": "Adding Gaussian noise to the images increases the measured sparsity.", "explanation": "The left panel of the figure shows that the measured sparsity (solid line) is higher when Gaussian noise is added to the images (orange line) than when no noise is added (blue line). This is because the noise adds additional non-zero entries to the data matrix, which increases the sparsity.", "reference": "1710.05654v2-Figure12-1.png"}, {"question": "How does the connectivity of the Daitch hard scalable model compare to the Daitch soft scalable model?", "answer": "The Daitch hard scalable model has a higher connectivity than the Daitch soft scalable model. This can be seen in the figure, where the bars for the hard model are generally higher than the bars for the soft model.", "explanation": "The figure shows the percentage of the total weight for connected pairs of each label for the Daitch hard scalable model (left) and the Daitch soft scalable model (right). The height of the bars represents the percentage of the total weight, so taller bars indicate a higher connectivity.", "reference": "1710.05654v2-Figure14-1.png"}, {"question": "How does the relevance of terms assigned by the learned graph compare to the relevance assigned by k-NN and A-NN graphs?", "answer": "The learned graph assigns weights that correspond much better to the relevance of the terms compared to k-NN and A-NN graphs.", "explanation": "The caption of Table 1 explicitly states that \"the weights assigned by graph learning correspond much better to the relevance of the terms.\" Additionally, when comparing the terms associated with \"glucose\" and \"academy\" across the different methods, the learned graph generally assigns higher weights to terms that are intuitively more relevant to the respective words. For example, \"insulin\" has a much higher weight for \"glucose\" in the learned graph compared to the other methods, and \"training\" has a higher weight for \"academy\" in the learned graph compared to the other methods. This suggests that the learned graph is better at capturing semantic relationships between words.", "reference": "1710.05654v2-Table1-1.png"}, {"question": "How does the graph diameter change with increasing average degree for different methods and datasets?", "answer": "The graph diameter generally decreases with increasing average degree for all methods and datasets. However, the rate of decrease and the final diameter value vary depending on the method and dataset.", "explanation": "The figure shows the graph diameter as a function of the average degree for different methods and datasets. The diameter is a measure of how far apart nodes are in the graph, and a lower diameter indicates a better manifold recovery. The figure shows that the diameter decreases as the average degree increases, which means that the nodes are becoming more connected and the manifold is being recovered more accurately.", "reference": "1710.05654v2-Figure9-1.png"}]}, "1906.10843v1": {"paper_id": "1906.10843v1", "all_figures": {"1906.10843v1-Figure3-1.png": {"caption": "Figure 3: Causal graph representing Assumption 2. X influences both user sentiment under control Y (T = 0), and propensity to respond under both treatment and control conditions \u2206(T = 0),\u2206(T = 1). There is no other path between user sentiment and propensity to respond. Therefore, Y (T = 0) and \u2206(T = 0),\u2206(T = 1), are independent conditioned on X.", "content_type": "figure", "figure_type": "Schematic"}, "1906.10843v1-Figure5-1.png": {"caption": "Figure 5: Performance of different ATE estimators when true confounders are fully observed. DR and AB has the highest variance.", "content_type": "figure", "figure_type": "** plot"}, "1906.10843v1-Table2-1.png": {"caption": "Table 2: Performance of different ATE estimators when true confounders are fully observed. Estimators are Adversarial Balancing (AB), Doubly Robust (DR), Inverse Propensity Weighing (IPW), Naive mean comparison and Outcome Regression (OR). The naive estimator has the largest bias while AB estimator has the best MSE performance.", "content_type": "figure", "figure_type": "plot"}, "1906.10843v1-Table5-1.png": {"caption": "Table 5: Performance of different ATETR estimators when noisy confounders are observed. Estimators are Adversarial Balancing (AB), Covariate Control (CC), Entrophy Balancing (EB), Inverse Propensity Weighing (IPW), Naive mean comparison and Outcome Regression (OR). Similar to the results in Table 4, EB outperforms across all measures. Similar to Table 4, simple CC estimator provides a comparable performance to EB.", "content_type": "table", "figure_type": "N/A"}, "1906.10843v1-Figure8-1.png": {"caption": "Figure 8: Performance of different ATETR estimators when noisy confounders are observed. Estimators are Adversarial Balancing (AB), Covariate Control (CC), Entrophy Balancing (EB), Inverse Propensity Weighing (IPW), Naive mean comparison and Outcome Regression (OR). Similar to the results in Table 4, EB and CC outperform across all measures. IPW suffers from large variance, OR performs worse than naive estimator.", "content_type": "table", "figure_type": "N/A"}, "1906.10843v1-Figure1-1.png": {"caption": "Figure 1: Sample UI based survey", "content_type": "figure", "figure_type": "other"}, "1906.10843v1-Table1-1.png": {"caption": "Table 1: Population level statistics based on GDP in Appendix B.", "content_type": "table", "figure_type": "N/A"}, "1906.10843v1-Table4-1.png": {"caption": "Table 4: Performance of different ATETR estimators when true confounders are fully observed. Estimators are Adversarial Balancing (AB), Covariate Control (CC), Entrophy Balancing (EB), Inverse Propensity Weighing (IPW), Naive mean comparison and Outcome Regression (OR). EB has the best performance followed by simple CC estimator.", "content_type": "table", "figure_type": "N/A"}, "1906.10843v1-Figure7-1.png": {"caption": "Figure 7: Performance of different ATETR estimators when true confounders are fully observed. CC and EB outperforms AB in contrast to ATE.", "content_type": "figure", "figure_type": "** plot"}, "1906.10843v1-Figure6-1.png": {"caption": "Figure 6: Performance of different ATE estimators when noisy confounders are observed. Increase in variances of OR and DR, AB retains performance characteristics.", "content_type": "figure", "figure_type": "plot"}, "1906.10843v1-Table3-1.png": {"caption": "Table 3: Performance of different ATE estimators when noisy confounders are observed. Estimators are Adversarial Balancing (AB), Doubly Robust (DR), Inverse Propensity Weighing (IPW), Naive mean comparison and Outcome Regression (OR). In contrast to Table 2, the performance of OR drops significantly while AB continues to provide a balance between variance and bias.", "content_type": "table", "figure_type": "N/A"}, "1906.10843v1-Figure4-1.png": {"caption": "Figure 4: Causal graph representing our data generation process. Latent variables (X = [X1, X2]) generate both individual sentiment Y and response behavior under the treatment and control conditions \u2206(1),\u2206(0).", "content_type": "figure", "figure_type": "schematic"}, "1906.10843v1-Figure2-1.png": {"caption": "Figure 2: Causal graph representing Assumption 1. X(T ) influences both user sentiment Y (T ) and propensity to respond \u2206(T ). There is no other path between user sentiment and propensity to respond. Therefore, Y (T ) and \u2206(T ) are independent conditioned on X(T ).", "content_type": "figure", "figure_type": "Schematic"}}, "qa": [{"question": "Which estimator performs best in the presence of noisy confounders and how does it compare to the Covariate Control (CC) estimator?", "answer": "The Entropy Balancing (EB) estimator performs best across all measures (Bias, MAE, and MSE) when confounders are noisy. While the CC estimator also performs well, it exhibits slightly higher bias and MAE compared to EB.", "explanation": "The table presents the performance of different ATETR estimators under the condition of noisy confounders. The performance is evaluated based on three metrics: Bias, Mean Absolute Error (MAE), and Mean Squared Error (MSE). By comparing the values in the table, we can see that EB has the lowest values for all three metrics, indicating its superior performance. Although CC also shows good performance, its metrics are slightly higher than those of EB, suggesting a slightly lower accuracy in this scenario.", "reference": "1906.10843v1-Table5-1.png"}, {"question": "Which ATE estimator is most affected by the presence of noisy confounders?", "answer": "Outcome Regression (OR)", "explanation": "The boxplot for OR shows the largest increase in variance compared to the other estimators. This indicates that OR is more sensitive to the presence of noisy confounders.", "reference": "1906.10843v1-Figure6-1.png"}, {"question": "Which estimator has the smallest bias and best MSE performance in the case of fully observed confounders?", "answer": "The Entropy Balancing (EB) and Covariate Control (CC) estimators.", "explanation": "The boxplots in Figure~\\ref{figure_sim_ATETR_1} show the distribution of ATETR estimates for different estimators. The EB and CC estimators have boxplots that are centered close to the true ATETR value of 0, indicating that they have small biases. Additionally, the passage states that the EB and CC estimators have the best MSE performance across all estimators.", "reference": "1906.10843v1-Figure7-1.png"}]}, "1809.03550v3": {"paper_id": "1809.03550v3", "all_figures": {"1809.03550v3-Table1-1.png": {"caption": "Table 1: A comparison of our approach against five of the best-known RPCA implementations and the recent OMoGMF, featuring the F1 score on the baseline category of http://changedetection.net and mean run time (in seconds per input frame, single-threaded) on the \u201cbaseline/highway\u201d video-sequence of the same benchmark.", "content_type": "table", "figure_type": "N/A"}, "1809.03550v3-Table3-1.png": {"caption": "Table 3: Results of our Algorithm 2, compared to 3 other approaches on 6 categories of http://changedetection.net, evaluated on the 6 performance metrics of (Goyette et al. 2012). For each pair of performance metric and category, the best result across the presented methods is highlighted in bold.", "content_type": "table", "figure_type": "N/A"}, "1809.03550v3-Table2-1.png": {"caption": "Table 2: Results of our Algorithm 2, compared to 6 other approaces on the \u201cbaseline\u201d category of http://changedetection.net, evaluated on the 6 performance metrics of (Goyette et al. 2012). For each performance metric, the best result across the presented methods is highlighted in bold.", "content_type": "table", "figure_type": "N/A"}, "1809.03550v3-Figure3-1.png": {"caption": "Figure 3: A histogram of residuals. The histogram was truncated from the original 3\u00b7255 residuals to allow for some clarity of presentation. In green, there is the middle of the least-width interval representing half of the mass. In yellow, there are the end-points of the interval. In red, the \u201coptimal\u201d threshold we use.", "content_type": "figure", "figure_type": "plot"}, "1809.03550v3-Table5-1.png": {"caption": "Table 5: Further results on http://changedetection.net.", "content_type": "table", "figure_type": "N/A"}, "1809.03550v3-Figure2-1.png": {"caption": "Figure 2: The configurations of the 3\u00d7 3 contiguous patches, whose fraction within all the 3\u00d7 3 contiguous patches is sought.", "content_type": "figure", "figure_type": "schematic"}, "1809.03550v3-Table6-1.png": {"caption": "Table 6: Mean processing time per input frame (in seconds) on the \u201cbaseline/highway\u201d video-sequence from http://changedetection. net. Note, our implementation does not use any parallelisation at the moment. This was done on purpose to run on a machine serving multiple cameras simultaneously.", "content_type": "table", "figure_type": "N/A"}, "1809.03550v3-Table4-1.png": {"caption": "Table 4: Results on changedetection.net.", "content_type": "table", "figure_type": "N/A"}, "1809.03550v3-Figure4-1.png": {"caption": "One snapshot from the video baseline/highway (from the top left, clock-wise): one frame of the original video, our estimate of the background, our residuals prior to thresholding, the ground truth, an exponential smoothing of all frames prior to the current one with smoothing factor of 1/35, and finally, our Boolean map obtained by thresholding residuals.", "content_type": "figure", "figure_type": "photograph(s)"}, "1809.03550v3-Figure1-1.png": {"caption": "Top: Effects of subsampling in the projection (7). Bottom: Performance of Algorithm 2 as a function of the number of epochs per update.", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Why is the optimal threshold chosen to be at the right margin of the region around the mode of the histogram?", "answer": "The region around the mode of the histogram mostly contains noise. Therefore, the optimal threshold is chosen to be at the right margin of this region to avoid including too much noise in the thresholded image.", "explanation": "The figure shows that the region around the mode of the histogram has a high count, which indicates that there are many pixels with similar intensity values in this region. Since noise is typically characterized by random variations in intensity, it is likely that this region contains a significant amount of noise. By choosing the optimal threshold at the right margin of this region, we can exclude most of the noise while still preserving the important features of the image.", "reference": "1809.03550v3-Figure3-1.png"}, {"question": "Which method achieves the best overall F1 score across all categories? Is this method consistently the best across all individual categories?", "answer": "According to the table, Algorithm 2 w/ Geman-McLure) achieves the best overall F1 score of 0.56514. However, this method is not consistently the best across all individual categories. For example, OMoGMF has a higher F1 score for the \"badWeather\" category.", "explanation": "The table presents the performance of various methods for different categories in terms of several metrics, including F1 score. The overall F1 score is shown in the last row. By comparing the F1 scores in this row, we can determine which method performs best overall. However, examining the F1 scores within each category reveals that different methods may excel in different scenarios.", "reference": "1809.03550v3-Table5-1.png"}, {"question": "Which algorithm achieves the fastest processing time per frame and how much faster is it compared to the slowest algorithm listed?", "answer": "Algorithm 12(SCDM with Geman-McLure) achieves the fastest processing time per frame at 0.103 seconds. This is approximately 100 times faster than the slowest algorithm, TTD_3WD, which takes 10.343 seconds per frame.", "explanation": "Table 1 explicitly lists the mean processing time per frame for each algorithm. By comparing these values, we can identify the fastest and slowest algorithms. The caption clarifies that the implementation does not utilize parallelization, ensuring a fair comparison across algorithms.", "reference": "1809.03550v3-Table6-1.png"}, {"question": "What is the relationship between the residuals prior to thresholding and the Boolean map?", "answer": "The Boolean map is obtained by thresholding the residuals prior to thresholding.", "explanation": "The residuals prior to thresholding show the difference between the current frame and the estimated background. The Boolean map is a binary image where pixels are set to 1 if the corresponding residual value is above a certain threshold and 0 otherwise. This means that the Boolean map highlights the areas where the current frame differs significantly from the estimated background, which is likely due to the presence of moving objects.", "reference": "1809.03550v3-Figure4-1.png"}]}, "1709.08294v3": {"paper_id": "1709.08294v3", "all_figures": {"1709.08294v3-Table2-1.png": {"caption": "Table 2: Test error rates on document classification tasks (in percentages). S-model indicates that the model has one single convolutional filter, while M-model indicates that the model has multiple convolutional filters. Results marked with \u2217 are reported by (Zhang et al., 2015), \u2020 are reported by (Conneau et al., 2016), and \u2021 are reported by (Lin et al., 2017).", "content_type": "table", "figure_type": "N/A"}, "1709.08294v3-Table4-1.png": {"caption": "Table 4: Results of our models on SelQA dataset, compared with previous CNN-based methods. Results marked with \u2217 are from (Jurczyk et al., 2016), and marked with \u2021 are from (Santos et al., 2017).", "content_type": "table", "figure_type": "N/A"}, "1709.08294v3-Table3-1.png": {"caption": "Table 3: Results of our models on WikiQA dataset, compared with previous CNN-based methods.", "content_type": "table", "figure_type": "N/A"}, "1709.08294v3-Figure1-1.png": {"caption": "Figure 1: The general ACNN framework. Notably, the input sentences to filter generating module and convolution module could be different (see Section 3.3).", "content_type": "figure", "figure_type": "schematic"}, "1709.08294v3-Table5-1.png": {"caption": "Results on the Quora Question Pairs dataset.", "content_type": "table", "figure_type": "table"}, "1709.08294v3-Figure3-1.png": {"caption": "Comprehensive study of the proposed ACNN framework, including (a) the number of filters (Yelp dataset), and (b) performance vs question types (WikiQA dataset), and (c) t-SNE visualization of learned filter weights (DBpedia dataset).", "content_type": "figure", "figure_type": "plot"}, "1709.08294v3-Figure2-1.png": {"caption": "Figure 2: Schematic description of Adaptive Question Answering (AdaQA) model.", "content_type": "figure", "figure_type": "schematic"}, "1709.08294v3-Table1-1.png": {"caption": "Table 1: Dataset statistics.", "content_type": "table", "figure_type": "N/A"}}, "qa": [{"question": "How does the performance of the two-way AdaQA model compare to the one-way AdaQA model and other CNN-based baseline models on the WikiQA dataset?", "answer": "The two-way AdaQA model significantly outperforms the one-way AdaQA model and all other CNN-based baseline models on the WikiQA dataset. This is evident from the higher MAP and MRR values achieved by the two-way model (0.7107 and 0.7304 respectively) compared to the one-way model (0.7005 and 0.7161) and the baseline models.", "explanation": "Table 1 presents the MAP and MRR scores for various models on the WikiQA dataset. By comparing the scores of the two-way AdaQA model with those of the one-way AdaQA and other CNN-based models, we can directly observe the performance difference. The higher scores of the two-way model indicate its superior performance in answer selection on this dataset.", "reference": "1709.08294v3-Table3-1.png"}, {"question": "How does the ACNN framework learn context-sensitive filters?", "answer": "The ACNN framework learns context-sensitive filters through two modules: the filter generation module and the adaptive convolution module. The filter generation module produces a set of filters conditioned on the input sentence, while the adaptive convolution module applies the generated filters to an input sentence. The two modules are jointly differentiable, and the overall architecture can be trained in an end-to-end manner.", "explanation": "The figure shows the general ACNN framework, with the filter generation module on the left and the convolution module on the right. The arrows between the modules indicate the flow of information, with the filter generation module producing filters based on the input sentence and the convolution module applying those filters to the input sentence.", "reference": "1709.08294v3-Figure1-1.png"}, {"question": "Which model performed the best on the Quora Question Pairs dataset?", "answer": "AdaQA (two-way) + att.", "explanation": "The table shows the accuracy of different models on the Quora Question Pairs dataset. The AdaQA (two-way) + att. model has the highest accuracy of 0.8794.", "reference": "1709.08294v3-Table5-1.png"}, {"question": "Based on the figure, which type of question does ACNN perform the best on?", "answer": "ACNN performs best on \"Who\" questions.", "explanation": "Figure (b) shows the performance of ACNN and AdaQA on different question types. We can see that ACNN performs better than AdaQA on all question types, and it performs the best on \"Who\" questions.", "reference": "1709.08294v3-Figure3-1.png"}, {"question": "How does the Adaptive Question Answering (AdaQA) model generate context-aware filters?", "answer": "The AdaQA model generates context-aware filters through the filter generation module. This module takes the question and answer as input and outputs a set of filters that are specific to the question and answer pair.", "explanation": "The figure shows that the filter generation module is located below the question and answer embedding modules. The question and answer embeddings are fed into the filter generation module, which then outputs the context-aware filters. These filters are then used by the convolution module to encode the question and answer.", "reference": "1709.08294v3-Figure2-1.png"}, {"question": "Based on Table 1, which dataset has the largest vocabulary size and how does this compare to the average number of words per document in that dataset?", "answer": "The Yelp P. dataset has the largest vocabulary size with 25,709 unique words. This is significantly larger than the average number of words per document in the dataset, which is 138.", "explanation": "The table provides information about the vocabulary size and average number of words for each dataset. By comparing these values for each dataset, we can see that the Yelp P. dataset has the largest vocabulary size, indicating a wider variety of unique words used in the documents. However, the average document length is relatively short, suggesting that individual documents may not utilize the full range of vocabulary available. This discrepancy could be due to factors such as frequent use of stop words or a high degree of variation in document length within the dataset.", "reference": "1709.08294v3-Table1-1.png"}, {"question": "Can you explain why the authors claim that their S-ACNN model with a single filter is \"much more expressive\" than the basic S-CNN model, even though it doesn't achieve the best overall performance on either dataset?", "answer": "The authors claim that S-ACNN is more expressive than S-CNN because, despite having only one filter, it significantly outperforms S-CNN on both datasets. This suggests that the filter-generation module in ACNN allows for greater flexibility and adaptability, enabling the model to better capture the specific features of each sentence.", "explanation": "Table~\\ref{tab:topic} shows the test error rates for different models on the Yelp P. and DBpedia datasets. While S-ACNN doesn't achieve the lowest error rate overall, it shows a substantial improvement over S-CNN, which also uses a single filter. This relative improvement suggests that the adaptivity of the filter in S-ACNN allows it to generate more relevant and informative representations for different sentences, leading to better performance even with limited modeling capacity.", "reference": "1709.08294v3-Table2-1.png"}, {"question": "Which model performs best on the SelQA dataset and how does it compare to the baseline CNN model reported in Jurczyk et al. (2016)?", "answer": "The AdaQA (two-way) + att. model achieves the best performance on the SelQA dataset with a MAP score of 0.9021 and an MRR score of 0.9103. Compared to the baseline CNN model from Jurczyk et al. (2016) which has a MAP score of 0.8320 and an MRR score of 0.8420, the AdaQA (two-way) + att. model demonstrates a significant improvement in both metrics.", "explanation": "Table 2 presents the performance of different models on the SelQA dataset, including several baseline models and the proposed AdaQA variants. By comparing the MAP and MRR scores, we can identify the best performing model. The AdaQA (two-way) + att. model shows the highest scores in both metrics, indicating its superior performance. Furthermore, by comparing these scores to the baseline CNN model reported in Jurczyk et al. (2016), we can quantify the improvement achieved by the proposed model.", "reference": "1709.08294v3-Table4-1.png"}]}, "1710.06177v2": {"paper_id": "1710.06177v2", "all_figures": {"1710.06177v2-Table1-1.png": {"caption": "Table 1. Performance of different algorithms for k-shot binary classification problem", "content_type": "table", "figure_type": "N/A"}, "1710.06177v2-Table2-1.png": {"caption": "Table 2. Comparison of VAGER and LR over novel classes with 1-shot binary classification setting", "content_type": "table", "figure_type": "N/A"}, "1710.06177v2-Figure3-1.png": {"caption": "Linear regression of AUC improvement on Similarity Ratio for all novel classes", "content_type": "figure", "figure_type": "plot"}, "1710.06177v2-Figure2-1.png": {"caption": "The change of performance as the number of shots increases in binary classification.", "content_type": "figure", "figure_type": "plot"}, "1710.06177v2-Figure4-1.png": {"caption": "Top-3 most similar base classes to novel class on embedding layer in 5-shot setting.", "content_type": "figure", "figure_type": "photograph(s)"}, "1710.06177v2-Figure5-1.png": {"caption": "Change of performance as shot number increases in 10 classes 1-shot multi-class classification problem.", "content_type": "figure", "figure_type": "plot"}, "1710.06177v2-Table3-1.png": {"caption": "Top-1 Accuracy for m classes 1-shot problem", "content_type": "table", "figure_type": "table"}, "1710.06177v2-Figure1-1.png": {"caption": "The framework of learning to learn image classifiers. Training Base Classes with VAGER: By training base classes with VAGER, we derive the embeddings of each base class and the common mapping function from embeddings to classification parameters. Generalization to a New Class: Given a new class with only a few samples, we can infer its embedding through out-of-sample inference, and then transform the embedding into transferred classification parameters by the mapping function learned by VAGER. After training the classifier with new class samples and getting the model classification parameters, we fuse the two kinds of parameters to form the final classifier.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "How does the performance of VAGER+Voting compare to other VAGER variants in the 1-shot and 20-shot settings?", "answer": "VAGER+Voting consistently outperforms all other VAGER variants in both 1-shot and 20-shot settings, achieving the highest AUC and F1 scores.", "explanation": "Looking at the table, we can compare the bolded values for VAGER+Voting with the corresponding values for other VAGER variants. In both the 1-shot and 20-shot columns, VAGER+Voting has the highest AUC and F1 scores, demonstrating its superior performance compared to other variants. This suggests that the Voting strategy effectively combines the strengths of different components within the VAGER framework.", "reference": "1710.06177v2-Table1-1.png"}, {"question": "Can you explain why the performance of VAGER is worse than LR for the \"Bubble\" class in the 1-shot binary classification setting, while it performs better for the other nine classes?", "answer": "VAGER leverages transfer learning, while LR does not. This means VAGER attempts to apply knowledge from other classes to improve its performance on new classes. For nine out of the ten novel classes, this strategy seems to be successful, as VAGER consistently outperforms LR. However, for the \"Bubble\" class, the transfer learning approach seems to have a negative impact, causing VAGER to perform worse than LR.", "explanation": "Table 1 directly compares the performance of VAGER and LR for each class. While VAGER shows higher accuracy for most classes, the \"Bubble\" class is a clear exception, with LR achieving a higher accuracy. This observation, combined with the passage's information about VAGER's use of transfer learning, suggests that the transferred knowledge might be detrimental for classifying \"Bubble\" images in this specific scenario.", "reference": "1710.06177v2-Table2-1.png"}, {"question": "What is the relationship between the Similarity Ratio and AUC Increasing?", "answer": "There is a positive linear relationship between the Similarity Ratio and AUC Increasing.", "explanation": "The plot shows that as the Similarity Ratio increases, the AUC Increasing also increases. This is evident from the upward trend of the data points and the positive slope of the linear regression line.", "reference": "1710.06177v2-Figure3-1.png"}, {"question": "Which method performs best in the 10 classes 1-shot multi-class classification problem?", "answer": "VAGER + Voting", "explanation": "The figure shows the Top-1 Accuracy of different methods as the number of shots increases. VAGER + Voting has the highest Top-1 Accuracy for all numbers of shots.", "reference": "1710.06177v2-Figure5-1.png"}, {"question": "What is the relationship between the novel class and the top-3 most similar base classes?", "answer": "The top-3 most similar base classes are the three classes that are most similar to the novel class, based on the embedding layer in a 5-shot setting.", "explanation": "The figure shows a table of images, with each row representing a different class. The first row shows the novel class, and the second row shows the top-3 most similar base classes. The images in the second row are similar to the images in the first row, which suggests that the top-3 most similar base classes are indeed similar to the novel class.", "reference": "1710.06177v2-Figure4-1.png"}, {"question": "Which method performs the best when the number of shots is 50?", "answer": "VAGER+Voting", "explanation": "The blue line, which represents VAGER+Voting, has the highest AUC value when the number of shots is 50.", "reference": "1710.06177v2-Figure2-1.png"}]}, "1809.04276v2": {"paper_id": "1809.04276v2", "all_figures": {"1809.04276v2-Table1-1.png": {"caption": "Table 1: An example of a message (MSG), a groundtruth response (GT), a generated response (RSP) and N-best response candidates (C#1 and C#2) during the training process. Similar contents in the response and candidates are in boldface.", "content_type": "table", "figure_type": "N/A"}, "1809.04276v2-Table2-1.png": {"caption": "Table 2: Some statistics of the datasets.", "content_type": "table", "figure_type": "N/A"}, "1809.04276v2-Table4-1.png": {"caption": "Table 4: Classification accuracy of discriminators in AL and our approach.", "content_type": "table", "figure_type": "N/A"}, "1809.04276v2-Table3-1.png": {"caption": "Table 3: Human evaluation results of mean score, proportions of three levels (+2, +1, and 0), and the agreements measured by Fleiss\u2019s Kappa in appropriateness, informativeness, and grammaticality.", "content_type": "table", "figure_type": "N/A"}, "1809.04276v2-Figure1-1.png": {"caption": "Figure 1: An overview of our proposed approach. The discriminator is enhanced by the N-best response candidates returned by a retrieval-based method. The discriminator takes as input a response and outputs the probability that the response is human-generated. The output is then regarded as a reward to guide the generator.", "content_type": "figure", "figure_type": "schematic"}, "1809.04276v2-Table5-1.png": {"caption": "Table 5: Automatic evaluation results of the number of distinct uni-grams (# of UNI) and bi-grams (# of BI), Dist-1, Dist-2 and Originality (Origin). D+ and G+ are two variants of our approach where candidates are only available for the discriminator and the generator, respectively.", "content_type": "table", "figure_type": "N/A"}, "1809.04276v2-Figure2-1.png": {"caption": "Figure 2: An example of a test message (MSG), candidates (C#1 and C#2), and responses from different models. The last column are their translations.", "content_type": "figure", "figure_type": "table"}}, "qa": [{"question": "Why is the model discouraged even though the generated response (RSP) incorporates relevant content from the N-best response candidates (C#1 and C#2)?", "answer": "The model is discouraged because it is trained using the Maximum Likelihood Estimation (MLE) objective, which prioritizes generating responses that are identical to the ground-truth (GT) response. Even though the RSP integrates relevant content from the candidates and seems appropriate in the context, it is penalized because it deviates from the exact wording of the GT.", "explanation": "Table 1 showcases the training process of a Seq2Seq model with N-best response candidates. The highlighted portions in the RSP, C#1, and C#2 indicate similar content. While the RSP successfully incorporates these relevant aspects, it still differs from the GT. This difference leads to the model being discouraged under the MLE objective, which solely focuses on matching the GT response and doesn't account for the semantic similarity or appropriateness of the generated response.", "reference": "1809.04276v2-Table1-1.png"}, {"question": "How does the performance of the discriminator in the proposed approach compare to the conventional discriminator in AL? What evidence suggests this difference in performance?", "answer": "The discriminator in the author's approach achieves higher accuracy (95.72%) compared to the conventional discriminator in AL (94.01%).", "explanation": "Table 1 explicitly shows the classification accuracy for both discriminators. The higher accuracy of the author's discriminator indicates its better ability to distinguish between human-generated and machine-generated responses. This supports the claim in the passage that the N-best response candidates used in the author's approach are helpful for the discriminator.", "reference": "1809.04276v2-Table4-1.png"}, {"question": "Can you explain the discrepancy between the number of messages and responses in each dataset?", "answer": "Number of responses is significantly higher than number of messages in each dataset (training, validation, and test). This is because each message can have multiple responses associated with it. The passage mentions that users on Sina Weibo can post messages and also comment on other users' messages. These comments are considered as responses in the context of the table. Therefore, one message can have several responses, leading to a higher total number of responses compared to messages.", "explanation": "The table presents the number of messages and their corresponding responses separately. By comparing these numbers, we can understand that the data includes messages with multiple associated responses, which is further supported by the information provided in the passage about the nature of user interactions on Sina Weibo.", "reference": "1809.04276v2-Table2-1.png"}, {"question": "How does the discriminator in the proposed REAT approach use the N-best response candidates?", "answer": "The discriminator takes as input a response and the N-best response candidates, and outputs the probability that the response is human-generated.", "explanation": "The figure shows that the discriminator receives both the response and the N-best response candidates as input. The passage explains that the candidates are provided as references to help the discriminator better distinguish between human-generated and machine-generated responses.", "reference": "1809.04276v2-Figure1-1.png"}]}, "1710.01507v4": {"paper_id": "1710.01507v4", "all_figures": {"1710.01507v4-Figure1-1.png": {"caption": "Model Architecture", "content_type": "figure", "figure_type": "schematic"}, "1710.01507v4-Table1-1.png": {"caption": "Model Performance Comparison", "content_type": "table", "figure_type": "table"}}, "qa": [{"question": "What is the role of the LSTM network in the model architecture?", "answer": "The LSTM network is used to process the post text and generate a post text embedding.", "explanation": "The LSTM network is shown in the left-hand side of the figure. It takes the post text as input and outputs a post text embedding. This embedding is then used as input to the fully connected layers that predict the probability of clickbait.", "reference": "1710.01507v4-Figure1-1.png"}]}, "1709.00139v4": {"paper_id": "1709.00139v4", "all_figures": {"1709.00139v4-Table1-1.png": {"caption": "Table 1: Experimental Results of FISVDD and Incremental SVM on Different Data Sets", "content_type": "table", "figure_type": "N/A"}, "1709.00139v4-Figure1-1.png": {"caption": "F-1 Measure for Different Data Sets", "content_type": "figure", "figure_type": "plot"}}, "qa": [{"question": "Which method generally achieved a lower objective function value (OFV) for the different datasets, FISVDD or Incremental SVM? Does this imply that one method is definitively better than the other?", "answer": "For all datasets presented, Incremental SVM achieved a slightly lower OFV compared to FISVDD. However, this does not necessarily mean that Incremental SVM is definitively better.", "explanation": "The table shows that the OFV values for both methods are very close for each dataset. While Incremental SVM consistently has a lower value, the difference is minimal. Additionally, the passage mentions that FISVDD offers significant gains in efficiency, as evidenced by the significantly shorter training times shown in the table. Therefore, the slight decrease in OFV achieved by Incremental SVM might not outweigh its significantly longer training time, making FISVDD a potentially more attractive option depending on the specific needs of the application.", "reference": "1709.00139v4-Table1-1.png"}]}, "1809.01989v2": {"paper_id": "1809.01989v2", "all_figures": {"1809.01989v2-Table1-1.png": {"caption": "Table 1. Absolute percentage errors for different methods", "content_type": "table", "figure_type": "N/A"}, "1809.01989v2-Figure1-1.png": {"caption": "Index tracking performance: Top plots are the index and trackers. Bottom is the percentage tracking error y\u0302\u2212yy .", "content_type": "figure", "figure_type": "** plot"}}, "qa": [{"question": "Which method achieved the highest tracking accuracy in terms of minimizing the sum of absolute percentage errors? Does this necessarily mean it had the best overall performance?", "answer": "The Ridge method achieved the lowest sum of absolute percentage errors (136.84), indicating the highest tracking accuracy in terms of minimizing absolute deviations from the index. However, this doesn't necessarily translate to the best overall performance.", "explanation": "While the sum/mean of absolute percentage errors in Table 2 reflects the tracking accuracy, the passage emphasizes the importance of considering the **sign** of the error. Positive errors, representing better returns than the market, are more desirable than negative errors. Although Ridge has the lowest overall error, the Cluster approach has a much higher proportion of positive errors (237.17) compared to its negative errors (21.42). This suggests that the Cluster approach, despite having a slightly higher total error than Ridge, might actually be achieving better overall performance due to its tendency to outperform the market.", "reference": "1809.01989v2-Table1-1.png"}]}, "1709.02418v2": {"paper_id": "1709.02418v2", "all_figures": {"1709.02418v2-Figure1-1.png": {"caption": "Illustration of how performing a left-swap on binary vector y at index j\u2032 yields a new vector z such that the number of misclassified pairs h(z, y\u0302) is one more than h(y, y\u0302). Specifically, y\u0302 misclassifies pairs (3, 4), (3, 5), (3, 7), and (6, 7) w.r.t. to y, since for each such pair (i, j), y\u0302i < y\u0302j but yi > yj . In contrast, y\u0302 misclassifies (3, 4), (3, 6), (3, 7), (5, 6), and (5, 7) w.r.t. to z.", "content_type": "figure", "figure_type": "Table"}, "1709.02418v2-Figure2-1.png": {"caption": "Illustration of how any binary vector y with n1 1s can be produced by repeatedly leftswapping the 1\u2019s in a right-most binary vector r. In the example above, left-swaps are indicated with blue arrows, with s1 = 3, s2 = 1, and s3 = s4 = s5 = 0.", "content_type": "figure", "figure_type": "schematic"}}, "qa": [{"question": "What is the effect of performing a left-swap on a binary vector y at index j\u2032?", "answer": "The left-swap increases the number of misclassified pairs by one.", "explanation": "The figure shows that the number of misclassified pairs for y is 4, while the number of misclassified pairs for z is 5. This means that the left-swap operation increased the number of misclassified pairs by one.", "reference": "1709.02418v2-Figure1-1.png"}]}}